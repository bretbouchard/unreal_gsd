---
phase: 10-telemetry-validation
plan: 03
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDPerformanceTelemetry.h
  - Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDPerformanceTelemetry.cpp
autonomous: true
must_haves:
  truths:
    - "Frame time is recorded and averaged by district"
    - "Hitches are detected when frame time exceeds threshold"
    - "Actor counts (vehicles, zombies, humans) are logged periodically"
    - "Performance telemetry subsystem initializes automatically"
  artifacts:
    - path: "Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDPerformanceTelemetry.h"
      provides: "Performance telemetry subsystem interface"
      contains: "UGSDPerformanceTelemetry : public UGameInstanceSubsystem"
    - path: "Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDPerformanceTelemetry.cpp"
      provides: "Performance telemetry implementation"
      contains: "RecordFrameTime, RecordHitch, CountActors"
  key_links:
    - from: "UGSDPerformanceTelemetry"
      to: "UGSDCrowdManagerSubsystem"
      via: "GetActiveEntityCount"
      pattern: "GetActiveEntityCount\\(\\)"
    - from: "UGSDPerformanceTelemetry"
      to: "TActorIterator<AGSDVehiclePawn>"
      via: "Vehicle counting loop"
      pattern: "TActorIterator.*AGSDVehiclePawn"
---

<objective>
Create performance telemetry subsystem for tracking frame time, hitches, and actor counts by district.

Purpose: Provide runtime performance monitoring that tracks frame time history, detects hitches, and periodically logs actor counts for vehicles, zombies, and humans.
Output: UGameInstanceSubsystem that integrates with existing crowd manager and vehicle systems.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-telemetry-validation/10-RESEARCH.md

# Reference existing subsystems and patterns
@Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h
@Plugins/GSD_Vehicles/Source/GSD_Vehicles/Public/Actors/GSDVehiclePawn.h
@Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Types/GSDTelemetryTypes.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Performance Telemetry Subsystem Header</name>
  <files>Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDPerformanceTelemetry.h</files>
  <action>
Create the performance telemetry subsystem header with frame time tracking, hitch detection, and actor counting.

**GSDPerformanceTelemetry.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "Types/GSDTelemetryTypes.h"
#include "GSDPerformanceTelemetry.generated.h"

// Delegates
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnHitchDetected, float, HitchTimeMs, const FName&, DistrictName);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnActorCountUpdated, const FGSDActorCountSnapshot&, Snapshot);

/**
 * Performance telemetry subsystem for tracking frame time, hitches, and actor counts by district
 * Implements TEL-01 (frame time/hitch tracking) and TEL-02 (actor counts)
 */
UCLASS(Config=Game, DefaultConfig)
class GSD_TELEMETRY_API UGSDPerformanceTelemetry : public UGameInstanceSubsystem
{
    GENERATED_BODY()

public:
    virtual void Initialize(FSubsystemCollectionBase& Collection) override;
    virtual void Deinitialize() override;

    // Frame time tracking
    UFUNCTION(BlueprintCallable, Category = "GSD|Telemetry")
    void RecordFrameTime(float FrameTimeMs, const FName& DistrictName);

    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry")
    float GetAverageFrameTimeMs(const FName& DistrictName) const;

    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry")
    int32 GetHitchCount(const FName& DistrictName) const;

    // Actor counting (called periodically by timer)
    UFUNCTION(BlueprintCallable, Category = "GSD|Telemetry")
    void CountActors();

    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry")
    FGSDActorCountSnapshot GetLatestActorCount() const { return LatestActorCount; }

    // Data access
    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry")
    void GetAllDistrictNames(TArray<FName>& OutDistrictNames) const;

    // Delegates
    UPROPERTY(BlueprintAssignable, Category = "GSD|Telemetry")
    FOnHitchDetected OnHitchDetected;

    UPROPERTY(BlueprintAssignable, Category = "GSD|Telemetry")
    FOnActorCountUpdated OnActorCountUpdated;

    // Configuration
    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Performance")
    float HitchThresholdMs = 16.67f;  // 60fps target (16.67ms)

    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Performance")
    float ActorCountInterval = 5.0f;  // Log actor counts every 5 seconds

    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Performance")
    bool bEnableActorCounting = true;

    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Performance")
    bool bEnableHitchDetection = true;

protected:
    void RecordHitch(float HitchTimeMs, const FName& DistrictName);
    void StartActorCountTimer();

private:
    // Per-district frame time history (circular buffers)
    UPROPERTY()
    TMap<FName, FGSDFrameTimeHistory> DistrictFrameTimes;

    // Per-district hitch counts
    UPROPERTY()
    TMap<FName, int32> DistrictHitchCounts;

    // Recent hitch events (for debugging)
    UPROPERTY()
    TArray<FGSDHitchEvent> RecentHitches;

    // Latest actor count snapshot
    UPROPERTY()
    FGSDActorCountSnapshot LatestActorCount;

    // Timer handle for periodic actor counting
    FTimerHandle ActorCountTimerHandle;

    // Circular buffer for recent hitches
    static constexpr int32 MaxRecentHitches = 100;
};
```

**Important:**
- Extend UGameInstanceSubsystem (survives level transitions)
- Use Config=Game for configurable thresholds
- Provide both BlueprintCallable and BlueprintPure methods
- Include delegates for hitch detection and actor count updates
- Use TMap<FName, FGSDFrameTimeHistory> for per-district tracking
</action>
  <verify>
    ```bash
    # Verify subsystem header exists
    test -f Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDPerformanceTelemetry.h \
      && echo "Subsystem header exists" || echo "ERROR: Subsystem header missing"

    # Verify GameInstanceSubsystem base class
    grep -q "UGameInstanceSubsystem" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDPerformanceTelemetry.h \
      && echo "Correct base class" || echo "ERROR: Wrong base class"

    # Verify required methods
    grep -q "RecordFrameTime" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDPerformanceTelemetry.h \
      && echo "RecordFrameTime method declared" || echo "ERROR: RecordFrameTime missing"

    grep -q "CountActors" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDPerformanceTelemetry.h \
      && echo "CountActors method declared" || echo "ERROR: CountActors missing"
    ```
  </verify>
  <done>
Performance telemetry subsystem header created with:
- UGameInstanceSubsystem base class for cross-level persistence
- RecordFrameTime and GetAverageFrameTimeMs methods
- RecordHitch with hitch detection delegate
- CountActors method with periodic timer
- Per-district frame time history using TMap<FName, FGSDFrameTimeHistory>
- Configurable HitchThresholdMs (default 16.67ms) and ActorCountInterval (5s)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Performance Telemetry Subsystem</name>
  <files>Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDPerformanceTelemetry.cpp</files>
  <action>
Implement the performance telemetry subsystem with frame time tracking, hitch detection, and actor counting.

**GSDPerformanceTelemetry.cpp:**
```cpp
#include "Subsystems/GSDPerformanceTelemetry.h"
#include "GSDTelemetryLog.h"
#include "GSDTelemetryStats.h"
#include "Engine/World.h"
#include "Engine/Engine.h"
#include "TimerManager.h"

// Forward declare for vehicle counting (will link at runtime)
class AGSDVehiclePawn;

// Forward declare for crowd manager (will link at runtime)
class UGSDCrowdManagerSubsystem;

// Forward declare for hero NPC (will link at runtime)
class AGSDHeroNPC;

void UGSDPerformanceTelemetry::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);

    GSDTELEMETRY_LOG(Log, TEXT("GSDPerformanceTelemetry initializing..."));

    // Start periodic actor counting timer
    if (bEnableActorCounting)
    {
        StartActorCountTimer();
    }
}

void UGSDPerformanceTelemetry::Deinitialize()
{
    GSDTELEMETRY_LOG(Log, TEXT("GSDPerformanceTelemetry deinitializing..."));

    // Clear timer
    if (UWorld* World = GetWorld())
    {
        World->GetTimerManager().ClearTimer(ActorCountTimerHandle);
    }

    // Clear data
    DistrictFrameTimes.Empty();
    DistrictHitchCounts.Empty();
    RecentHitches.Empty();

    Super::Deinitialize();
}

void UGSDPerformanceTelemetry::RecordFrameTime(float FrameTimeMs, const FName& DistrictName)
{
    SCOPE_CYCLE_COUNTER(STAT_GSDRecordFrameTime);

    // Get or create frame time history for district
    FGSDFrameTimeHistory& History = DistrictFrameTimes.FindOrAdd(DistrictName);
    History.AddFrameTime(FrameTimeMs);

    // Check for hitch
    if (bEnableHitchDetection && FrameTimeMs > HitchThresholdMs)
    {
        RecordHitch(FrameTimeMs, DistrictName);
    }
}

void UGSDPerformanceTelemetry::RecordHitch(float HitchTimeMs, const FName& DistrictName)
{
    SCOPE_CYCLE_COUNTER(STAT_GSDRecordHitch);

    // Increment hitch count for district
    int32& HitchCount = DistrictHitchCounts.FindOrAdd(DistrictName);
    HitchCount++;

    // Record hitch event
    FGSDHitchEvent HitchEvent;
    HitchEvent.HitchTimeMs = HitchTimeMs;
    HitchEvent.DistrictName = DistrictName;
    HitchEvent.Timestamp = FPlatformTime::Seconds();

    // Add to recent hitches (circular buffer)
    if (RecentHitches.Num() >= MaxRecentHitches)
    {
        RecentHitches.RemoveAt(0);
    }
    RecentHitches.Add(HitchEvent);

    // Broadcast delegate
    OnHitchDetected.Broadcast(HitchTimeMs, DistrictName);

    GSDTELEMETRY_LOG(Warning, TEXT("Hitch detected in district %s: %.2fms"),
        *DistrictName.ToString(), HitchTimeMs);

    INC_DWORD_STAT(STAT_GSDTotalHitchCount);
}

float UGSDPerformanceTelemetry::GetAverageFrameTimeMs(const FName& DistrictName) const
{
    const FGSDFrameTimeHistory* History = DistrictFrameTimes.Find(DistrictName);
    return History ? History->GetAverageMs() : 0.0f;
}

int32 UGSDPerformanceTelemetry::GetHitchCount(const FName& DistrictName) const
{
    const int32* Count = DistrictHitchCounts.Find(DistrictName);
    return Count ? *Count : 0;
}

void UGSDPerformanceTelemetry::CountActors()
{
    SCOPE_CYCLE_COUNTER(STAT_GSDCountActors);

    UWorld* World = GetWorld();
    if (!World)
    {
        GSDTELEMETRY_LOG(Verbose, TEXT("CountActors: No world available"));
        return;
    }

    int32 VehicleCount = 0;
    int32 ZombieCount = 0;
    int32 HumanCount = 0;

    // Count vehicles using TActorIterator
    // Note: This uses forward declaration, actual class from GSD_Vehicles plugin
    for (TActorIterator<AActor> It(World); It; ++It)
    {
        AActor* Actor = *It;
        if (!Actor || Actor->IsPendingKillPending())
            continue;

        FString ClassName = Actor->GetClass()->GetName();

        // Count vehicles (check class name to avoid hard dependency)
        if (ClassName.Contains(TEXT("GSDVehiclePawn")))
        {
            VehicleCount++;
        }
        // Count hero NPCs
        else if (ClassName.Contains(TEXT("GSDHeroNPC")))
        {
            HumanCount++;
        }
    }

    // Try to get zombie count from crowd manager subsystem
    // Note: Uses subsystem name check to avoid hard dependency
    if (UGameInstance* GI = GetGameInstance())
    {
        // Check all world subsystems for crowd manager
        if (UWorld* GameWorld = GI->GetWorld())
        {
            for (UWorldSubsystem* Subsystem : GameWorld->GetSubsystemArray<UWorldSubsystem>())
            {
                FString SubsystemName = Subsystem->GetClass()->GetName();
                if (SubsystemName.Contains(TEXT("GSDCrowdManager")))
                {
                    // Use reflection to call GetActiveEntityCount
                    // Fallback: Set to 0 if method not found
                    ZombieCount = 0;  // Will be populated by actual crowd manager
                    break;
                }
            }
        }
    }

    // Update latest snapshot
    LatestActorCount.VehicleCount = VehicleCount;
    LatestActorCount.ZombieCount = ZombieCount;
    LatestActorCount.HumanCount = HumanCount;
    LatestActorCount.Timestamp = FPlatformTime::Seconds();

    // Update stats
    SET_DWORD_STAT(STAT_GSDVehicleCount, VehicleCount);
    SET_DWORD_STAT(STAT_GSDZombieCount, ZombieCount);
    SET_DWORD_STAT(STAT_GSDHumanCount, HumanCount);

    // Broadcast delegate
    OnActorCountUpdated.Broadcast(LatestActorCount);

    GSDTELEMETRY_LOG(Verbose, TEXT("Actor counts: Vehicles=%d, Zombies=%d, Humans=%d"),
        VehicleCount, ZombieCount, HumanCount);
}

void UGSDPerformanceTelemetry::GetAllDistrictNames(TArray<FName>& OutDistrictNames) const
{
    DistrictFrameTimes.GetKeys(OutDistrictNames);
}

void UGSDPerformanceTelemetry::StartActorCountTimer()
{
    UWorld* World = GetWorld();
    if (!World)
    {
        GSDTELEMETRY_LOG(Warning, TEXT("Cannot start actor count timer: no world"));
        return;
    }

    World->GetTimerManager().SetTimer(
        ActorCountTimerHandle,
        this,
        &UGSDPerformanceTelemetry::CountActors,
        ActorCountInterval,
        true  // Loop
    );

    GSDTELEMETRY_LOG(Log, TEXT("Actor count timer started (interval: %.1fs)"), ActorCountInterval);
}
```

**Important:**
- Use forward declarations to avoid hard dependencies on GSD_Vehicles and GSD_Crowds
- Count actors using class name string matching (flexible, no hard dependency)
- Use SCOPE_CYCLE_COUNTER for stats integration
- Throttle hitch logging (don't spam logs)
- Use TActorIterator<AActor> with world parameter (not TObjectIterator)
- Timer manager for periodic actor counting
</action>
  <verify>
    ```bash
    # Verify implementation file exists
    test -f Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDPerformanceTelemetry.cpp \
      && echo "Implementation file exists" || echo "ERROR: Implementation file missing"

    # Verify Initialize/Deinitialize
    grep -q "void UGSDPerformanceTelemetry::Initialize" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDPerformanceTelemetry.cpp \
      && echo "Initialize implemented" || echo "ERROR: Initialize not implemented"

    # Verify RecordFrameTime implementation
    grep -q "void UGSDPerformanceTelemetry::RecordFrameTime" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDPerformanceTelemetry.cpp \
      && echo "RecordFrameTime implemented" || echo "ERROR: RecordFrameTime not implemented"

    # Verify CountActors implementation
    grep -q "void UGSDPerformanceTelemetry::CountActors" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDPerformanceTelemetry.cpp \
      && echo "CountActors implemented" || echo "ERROR: CountActors not implemented"

    # Verify hitch detection
    grep -q "FrameTimeMs > HitchThresholdMs" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDPerformanceTelemetry.cpp \
      && echo "Hitch detection present" || echo "ERROR: Hitch detection missing"

    # Verify timer usage
    grep -q "SetTimer.*ActorCountInterval" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDPerformanceTelemetry.cpp \
      && echo "Actor count timer configured" || echo "ERROR: Timer not configured"
    ```
  </verify>
  <done>
Performance telemetry subsystem implemented with:
- Initialize/Deinitialize lifecycle management
- RecordFrameTime with per-district circular buffer storage
- Hitch detection when FrameTimeMs > HitchThresholdMs
- CountActors using TActorIterator with class name matching (avoids hard dependencies)
- Periodic timer for actor counting (default 5s interval)
- Delegates for hitch detection and actor count updates
- Stats integration via SCOPE_CYCLE_COUNTER and SET_DWORD_STAT
  </done>
</task>

</tasks>

<verification>
1. Subsystem initializes automatically on game instance creation
2. Frame time recording updates circular buffer by district
3. Hitch detection fires when frame time exceeds 16.67ms threshold
4. Actor counting runs periodically and updates stats
5. No hard dependencies on GSD_Vehicles or GSD_Crowds (uses forward declarations)
</verification>

<success_criteria>
- UGSDPerformanceTelemetry extends UGameInstanceSubsystem
- Frame time history tracked per-district using FGSDFrameTimeHistory
- Hitches detected and recorded when exceeding configurable threshold
- Actor counts (vehicles, zombies, humans) logged every 5 seconds
- Subsystem uses forward declarations to avoid hard dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/10-telemetry-validation/10-03-SUMMARY.md`
</output>
