---
phase: 10-telemetry-validation
plan: 09
type: execute
wave: 4
depends_on: [10-02, 10-05]
files_modified:
  - tools/validate_asset_budget.py
  - Config/AssetBudgets.json
autonomous: true
must_haves:
  truths:
    - "Asset budget enforcement fails builds when exceeded"
    - "Per-asset-type budgets are configurable via JSON"
    - "CI/CD can run budget validation headlessly"
    - "Build fails with clear error messages on budget violation"
  artifacts:
    - path: "tools/validate_asset_budget.py"
      provides: "Python script for CI asset budget validation"
      contains: "def validate_budget, def get_asset_sizes"
    - path: "Config/AssetBudgets.json"
      provides: "Asset budget configuration"
      contains: "asset_budgets"
  key_links:
    - from: "validate_asset_budget.py"
      to: "Config/AssetBudgets.json"
      via: "Configuration loading"
      pattern: "json.load.*AssetBudgets.json"
---

<objective>
Create asset budget enforcement system for CI/CD integration.

Purpose: Implement TEL-08 by providing a Python script that validates asset budgets and can be integrated into build pipelines to fail builds when budgets are exceeded.
Output: Python script and JSON configuration for per-asset-type budget enforcement.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-telemetry-validation/10-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Asset Budget Configuration</name>
  <files>Config/AssetBudgets.json</files>
  <action>
Create JSON configuration file for per-asset-type budgets.

**Config/AssetBudgets.json:**
```json
{
  "version": 1,
  "description": "Asset budget configuration for GSD Platform",
  "asset_budgets": {
    "StaticMesh": {
      "max_size_mb": 50.0,
      "description": "Static meshes (buildings, props, vehicles)",
      "severity": "error"
    },
    "Texture2D": {
      "max_size_mb": 100.0,
      "description": "Textures (diffuse, normal, roughness, etc.)",
      "severity": "error"
    },
    "SkeletalMesh": {
      "max_size_mb": 75.0,
      "description": "Skeletal meshes (characters, animated objects)",
      "severity": "error"
    },
    "SoundWave": {
      "max_size_mb": 25.0,
      "description": "Audio files (sound effects, music)",
      "severity": "error"
    },
    "AnimSequence": {
      "max_size_mb": 50.0,
      "description": "Animation sequences",
      "severity": "warning"
    },
    "Material": {
      "max_size_mb": 10.0,
      "description": "Material assets",
      "severity": "warning"
    },
    "Blueprint": {
      "max_size_mb": 5.0,
      "description": "Blueprint assets",
      "severity": "warning"
    },
    "default": {
      "max_size_mb": 100.0,
      "description": "Default budget for unclassified assets",
      "severity": "error"
    }
  },
  "global_settings": {
    "max_total_content_size_gb": 10.0,
    "warn_threshold_percent": 80.0,
    "enable_warnings": true,
    "fail_on_error": true
  }
}
```

**Important:**
- Per-asset-type budgets with max_size_mb
- Severity levels: "error" (fail build) or "warning" (log only)
- Default budget for unclassified assets
- Global settings for total content size and thresholds
- warn_threshold_percent triggers warnings at 80% of budget
</action>
  <verify>
    ```bash
    # Verify config file exists
    test -f Config/AssetBudgets.json && echo "Config file exists" || echo "ERROR: Config file missing"

    # Verify JSON is valid
    python3 -m json.tool Config/AssetBudgets.json > /dev/null 2>&1 \
      && echo "JSON is valid" || echo "ERROR: Invalid JSON"

    # Verify required sections
    grep -q "asset_budgets" Config/AssetBudgets.json && echo "asset_budgets section exists" || echo "ERROR: asset_budgets missing"
    grep -q "global_settings" Config/AssetBudgets.json && echo "global_settings section exists" || echo "ERROR: global_settings missing"

    # Verify default budget
    grep -q '"default"' Config/AssetBudgets.json && echo "Default budget defined" || echo "ERROR: Default budget missing"
    ```
  </verify>
  <done>
Asset budget configuration created with:
- Config/AssetBudgets.json with version and description
- Per-asset-type budgets (StaticMesh: 50MB, Texture2D: 100MB, etc.)
- Severity levels (error vs warning)
- Default budget for unclassified assets (100MB)
- Global settings (max_total_content_size_gb, warn_threshold_percent)
- Valid JSON format
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Asset Budget Validation Script</name>
  <files>tools/validate_asset_budget.py</files>
  <action>
Create Python script for CI asset budget validation.

**tools/validate_asset_budget.py:**
```python
#!/usr/bin/env python3
"""
Asset Budget Validation Script for CI/CD Integration

Validates asset sizes against configurable budgets defined in Config/AssetBudgets.json.
Exits with code 0 if all assets within budget, 1 if any asset exceeds budget.

Usage:
    python validate_asset_budget.py --config Config/AssetBudgets.json --content Content/

Arguments:
    --config: Path to asset budget configuration JSON (default: Config/AssetBudgets.json)
    --content: Path to Content directory (default: Content/)
    --verbose: Enable verbose output (default: False)
    --json: Output results as JSON (default: False)
"""

import os
import sys
import json
import argparse
from pathlib import Path
from typing import Dict, List, Tuple

class AssetBudgetValidator:
    def __init__(self, config_path: str, content_dir: str, verbose: bool = False):
        self.config_path = config_path
        self.content_dir = content_dir
        self.verbose = verbose
        self.config = self.load_config()
        self.results = {
            'passed': True,
            'total_assets': 0,
            'errors': 0,
            'warnings': 0,
            'issues': []
        }

    def load_config(self) -> Dict:
        """Load asset budget configuration from JSON file"""
        try:
            with open(self.config_path, 'r') as f:
                config = json.load(f)
            if self.verbose:
                print(f"Loaded config from: {self.config_path}")
            return config
        except FileNotFoundError:
            print(f"ERROR: Config file not found: {self.config_path}", file=sys.stderr)
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"ERROR: Invalid JSON in config file: {e}", file=sys.stderr)
            sys.exit(1)

    def get_asset_type(self, asset_path: str) -> str:
        """Determine asset type from file path"""
        # Unreal asset types based on directory structure or metadata
        # This is a simplified approach - production would parse .uasset files
        path_lower = asset_path.lower()

        if '/geometry/' in path_lower or '/meshes/' in path_lower:
            return 'StaticMesh'
        elif '/textures/' in path_lower or '/materials/' in path_lower:
            return 'Texture2D'
        elif '/characters/' in path_lower or '/skeletal/' in path_lower:
            return 'SkeletalMesh'
        elif '/audio/' in path_lower or '/sounds/' in path_lower:
            return 'SoundWave'
        elif '/animations/' in path_lower:
            return 'AnimSequence'
        elif '/blueprints/' in path_lower:
            return 'Blueprint'
        else:
            return 'default'

    def get_asset_size_mb(self, asset_path: str) -> float:
        """Get asset size in megabytes"""
        try:
            size_bytes = os.path.getsize(asset_path)
            return size_bytes / (1024.0 * 1024.0)
        except OSError as e:
            if self.verbose:
                print(f"Warning: Could not get size for {asset_path}: {e}")
            return 0.0

    def get_all_assets(self) -> List[str]:
        """Find all .uasset files in Content directory"""
        assets = []
        content_path = Path(self.content_dir)

        if not content_path.exists():
            print(f"ERROR: Content directory not found: {self.content_dir}", file=sys.stderr)
            sys.exit(1)

        for root, dirs, files in os.walk(content_path):
            for file in files:
                if file.endswith('.uasset'):
                    asset_path = os.path.join(root, file)
                    assets.append(asset_path)

        return assets

    def validate_asset(self, asset_path: str) -> Tuple[bool, str]:
        """Validate single asset against budget"""
        asset_type = self.get_asset_type(asset_path)
        asset_size_mb = self.get_asset_size_mb(asset_path)

        # Get budget for this asset type
        budgets = self.config.get('asset_budgets', {})
        budget_config = budgets.get(asset_type, budgets.get('default', {'max_size_mb': 100.0}))
        max_size_mb = budget_config.get('max_size_mb', 100.0)
        severity = budget_config.get('severity', 'error')
        description = budget_config.get('description', '')

        self.results['total_assets'] += 1

        # Check against budget
        if asset_size_mb > max_size_mb:
            issue = {
                'asset_path': asset_path,
                'asset_type': asset_type,
                'size_mb': asset_size_mb,
                'budget_mb': max_size_mb,
                'severity': severity,
                'message': f"{asset_path}: {asset_size_mb:.2f}MB exceeds {max_size_mb:.2f}MB budget for {asset_type}"
            }
            self.results['issues'].append(issue)

            if severity == 'error':
                self.results['errors'] += 1
                self.results['passed'] = False
                return False, issue['message']
            else:
                self.results['warnings'] += 1
                return True, issue['message']

        # Check warn threshold
        global_settings = self.config.get('global_settings', {})
        warn_threshold = global_settings.get('warn_threshold_percent', 80.0) / 100.0
        enable_warnings = global_settings.get('enable_warnings', True)

        if enable_warnings and asset_size_mb > (max_size_mb * warn_threshold):
            usage_percent = (asset_size_mb / max_size_mb) * 100.0
            if self.verbose:
                print(f"WARNING: {asset_path} using {usage_percent:.1f}% of budget ({asset_size_mb:.2f}MB / {max_size_mb:.2f}MB)")

        if self.verbose:
            print(f"OK: {asset_path} ({asset_size_mb:.2f}MB, budget: {max_size_mb:.2f}MB)")

        return True, ""

    def validate_all_assets(self) -> bool:
        """Validate all assets against budgets"""
        print(f"Validating assets in: {self.content_dir}")
        print(f"Using config: {self.config_path}")

        assets = self.get_all_assets()
        print(f"Found {len(assets)} assets to validate")

        for asset_path in assets:
            passed, message = self.validate_asset(asset_path)
            if not passed:
                print(f"ERROR: {message}", file=sys.stderr)

        return self.results['passed']

    def print_summary(self):
        """Print validation summary"""
        print("\n" + "="*60)
        print("ASSET BUDGET VALIDATION SUMMARY")
        print("="*60)
        print(f"Total Assets Checked: {self.results['total_assets']}")
        print(f"Errors: {self.results['errors']}")
        print(f"Warnings: {self.results['warnings']}")
        print(f"Status: {'PASSED' if self.results['passed'] else 'FAILED'}")
        print("="*60)

    def output_json(self):
        """Output results as JSON for CI parsing"""
        output = json.dumps(self.results, indent=2)
        print(output)

def main():
    parser = argparse.ArgumentParser(description='Validate asset sizes against budgets')
    parser.add_argument('--config', default='Config/AssetBudgets.json',
                       help='Path to asset budget configuration JSON')
    parser.add_argument('--content', default='Content/',
                       help='Path to Content directory')
    parser.add_argument('--verbose', action='store_true',
                       help='Enable verbose output')
    parser.add_argument('--json', action='store_true',
                       help='Output results as JSON')

    args = parser.parse_args()

    # Create validator
    validator = AssetBudgetValidator(
        config_path=args.config,
        content_dir=args.content,
        verbose=args.verbose
    )

    # Run validation
    passed = validator.validate_all_assets()

    # Output results
    if args.json:
        validator.output_json()
    else:
        validator.print_summary()

    # Exit with appropriate code
    global_settings = validator.config.get('global_settings', {})
    fail_on_error = global_settings.get('fail_on_error', True)

    if not passed and fail_on_error:
        sys.exit(1)
    else:
        sys.exit(0)

if __name__ == '__main__':
    main()
```

**Make executable:**
```bash
chmod +x tools/validate_asset_budget.py
```

**Important:**
- Python 3 script for cross-platform compatibility
- Loads configuration from Config/AssetBudgets.json
- Scans Content/ directory for .uasset files
- Validates sizes against per-asset-type budgets
- Supports --verbose and --json output modes
- Exits with code 0 on success, 1 on failure
- Integrates with CI/CD pipelines (Jenkins, GitHub Actions, etc.)
</action>
  <verify>
    ```bash
    # Verify script exists
    test -f tools/validate_asset_budget.py && echo "Script exists" || echo "ERROR: Script missing"

    # Verify Python syntax
    python3 -m py_compile tools/validate_asset_budget.py && echo "Python syntax valid" || echo "ERROR: Python syntax error"

    # Verify executable
    test -x tools/validate_asset_budget.py && echo "Script is executable" || echo "WARNING: Script not executable"

    # Verify help works
    python3 tools/validate_asset_budget.py --help > /dev/null 2>&1 && echo "Help command works" || echo "ERROR: Help command failed"

    # Verify required functions
    grep -q "def validate_all_assets" tools/validate_asset_budget.py && echo "validate_all_assets defined" || echo "ERROR: validate_all_assets missing"
    grep -q "def validate_asset" tools/validate_asset_budget.py && echo "validate_asset defined" || echo "ERROR: validate_asset missing"
    grep -q "def get_asset_type" tools/validate_asset_budget.py && echo "get_asset_type defined" || echo "ERROR: get_asset_type missing"
    ```
  </verify>
  <done>
Asset budget validation script created with:
- tools/validate_asset_budget.py executable Python script
- AssetBudgetValidator class with validation logic
- get_asset_type() determining asset type from path
- get_asset_size_mb() calculating size in megabytes
- validate_asset() checking against per-asset-type budgets
- validate_all_assets() scanning Content/ directory
- Command-line arguments (--config, --content, --verbose, --json)
- JSON output for CI parsing
- Exit code 0/1 for CI integration
- Print summary for human-readable output
  </done>
</task>

</tasks>

<verification>
1. Script runs with --help to show usage
2. Configuration file is valid JSON
3. Script scans Content/ directory for .uasset files
4. Assets exceeding budgets generate errors
5. Exit code 0 on success, 1 on failure
6. JSON output is parseable by CI systems
</verification>

<success_criteria>
- Config/AssetBudgets.json defines per-asset-type budgets
- tools/validate_asset_budget.py scans Content/ directory
- Assets exceeding budgets are reported as errors
- Script exits with code 0/1 for CI integration
- JSON output enables machine parsing
- Verbose mode provides detailed output
</success_criteria>

<output>
After completion, create `.planning/phases/10-telemetry-validation/10-09-SUMMARY.md`
</output>
