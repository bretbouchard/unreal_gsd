---
phase: 10-telemetry-validation
plan: 05
type: execute
wave: 3
depends_on: [10-02]
files_modified:
  - Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDValidateAssetsCommandlet.h
  - Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDValidateAssetsCommandlet.cpp
autonomous: true
must_haves:
  truths:
    - "GSDValidateAssets commandlet runs asset validation headlessly"
    - "Asset sizes are checked against configurable budgets"
    - "Validation results are output as JSON for CI/CD parsing"
    - "Commandlet returns exit code 0 on success, 1 on failure"
  artifacts:
    - path: "Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDValidateAssetsCommandlet.h"
      provides: "Asset validation commandlet interface"
      contains: "UGSDValidateAssetsCommandlet : public UCommandlet"
    - path: "Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDValidateAssetsCommandlet.cpp"
      provides: "Asset validation implementation"
      contains: "Main, ValidateAsset, OutputJSON"
  key_links:
    - from: "UGSDValidateAssetsCommandlet"
      to: "FGSDValidationResult"
      via: "Validation result aggregation"
      pattern: "FGSDValidationResult.*Result"
---

<objective>
Create GSDValidateAssets commandlet for headless asset validation with CI/CD integration.

Purpose: Implement TEL-04 by providing a commandlet that validates asset sizes against configurable budgets and outputs JSON results for CI pipelines.
Output: UCommandlet that scans assets, checks budgets, and outputs structured JSON.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-telemetry-validation/10-RESEARCH.md

# Reference existing commandlet patterns
@Plugins/GSD_Vehicles/Source/GSD_Vehicles/Private/Commandlets/GSDVehicleTestCommandlet.cpp
@Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Commandlets/GSDCrowdTestCommandlet.cpp
@Plugins/GSD_ValidationTools/Source/GSD_ValidationTools/Public/Types/GSDValidationTypes.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Asset Validation Commandlet Header</name>
  <files>Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDValidateAssetsCommandlet.h</files>
  <action>
Create the asset validation commandlet header following established commandlet patterns.

**GSDValidateAssetsCommandlet.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Commandlets/Commandlet.h"
#include "Types/GSDValidationTypes.h"
#include "GSDValidateAssetsCommandlet.generated.h"

/**
 * Asset validation commandlet for CI pipelines
 * Implements TEL-04 (GSDValidateAssets commandlet)
 *
 * Usage:
 *   UnrealEditor-Cmd.exe MyProject -run=GSDValidateAssets
 *
 * Parameters:
 *   - maxsize=100        : Maximum asset size in MB (default: 100)
 *   - output=path.json   : Output file path for JSON report
 *   - json=true          : Output JSON to stdout (default: true)
 *   - verbose=true       : Enable verbose logging (default: false)
 *
 * Exit codes:
 *   0 = All assets passed validation
 *   1 = One or more assets failed validation
 */
UCLASS()
class GSD_TELEMETRY_API UGSDValidateAssetsCommandlet : public UCommandlet
{
    GENERATED_BODY()

public:
    UGSDValidateAssetsCommandlet();

    virtual int32 Main(const FString& Params) override;

private:
    // Configuration
    UPROPERTY()
    float MaxAssetSizeMB = 100.0f;

    UPROPERTY()
    bool bOutputJSON = true;

    UPROPERTY()
    bool bVerbose = false;

    UPROPERTY()
    FString OutputPath;

    // Per-asset-type budgets
    TMap<FString, float> AssetTypeBudgets;

    // Methods
    void ParseParameters(const FString& Params);
    void InitializeDefaultBudgets();
    bool ValidateAsset(UObject* Asset, FGSDValidationResult& OutResult);
    FString GetAssetType(UObject* Asset) const;
    float GetAssetSizeMB(UObject* Asset) const;
    void OutputJSON(const FGSDValidationResult& Result);
    void OutputText(const FGSDValidationResult& Result);
};
```

**Important:**
- Extend UCommandlet (UE5 commandlet base class)
- Include HelpDescription, HelpUsage, HelpParamNames in constructor
- Use FGSDValidationResult for structured validation results
- Support both JSON and text output formats
- Parse command-line parameters (maxsize, output, json, verbose)
</action>
  <verify>
    ```bash
    # Verify commandlet header exists
    test -f Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDValidateAssetsCommandlet.h \
      && echo "Commandlet header exists" || echo "ERROR: Commandlet header missing"

    # Verify UCommandlet base class
    grep -q "UCommandlet" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDValidateAssetsCommandlet.h \
      && echo "Correct base class" || echo "ERROR: Wrong base class"

    # Verify Main method
    grep -q "virtual int32 Main.*override" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDValidateAssetsCommandlet.h \
      && echo "Main method declared" || echo "ERROR: Main method missing"

    # Verify validation method
    grep -q "ValidateAsset" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDValidateAssetsCommandlet.h \
      && echo "ValidateAsset method declared" || echo "ERROR: ValidateAsset missing"
    ```
  </verify>
  <done>
Asset validation commandlet header created with:
- UCommandlet base class for headless execution
- Main() override with parameter parsing
- ValidateAsset() method for individual asset checks
- Per-asset-type budgets via TMap<FString, float>
- JSON and text output support
- Exit code 0/1 for CI/CD integration
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Asset Validation Commandlet</name>
  <files>Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDValidateAssetsCommandlet.cpp</files>
  <action>
Implement the asset validation commandlet following established patterns from GSDVehicleTestCommandlet and GSDCrowdTestCommandlet.

**GSDValidateAssetsCommandlet.cpp:**
```cpp
#include "Commandlets/GSDValidateAssetsCommandlet.h"
#include "GSDTelemetryLog.h"
#include "JsonObjectConverter.h"
#include "Misc/CommandLine.h"
#include "Misc/Parse.h"
#include "UObject/UObjectIterator.h"

UGSDValidateAssetsCommandlet::UGSDValidateAssetsCommandlet()
{
    HelpDescription = TEXT("Asset validation commandlet for CI pipelines");
    HelpUsage = TEXT("UnrealEditor-Cmd.exe MyProject -run=GSDValidateAssets");
    HelpParamNames.Add(TEXT("maxsize"));
    HelpParamDescriptions.Add(TEXT("Maximum asset size in MB (default: 100)"));
    HelpParamNames.Add(TEXT("output"));
    HelpParamDescriptions.Add(TEXT("Output file path for JSON report"));
    HelpParamNames.Add(TEXT("json"));
    HelpParamDescriptions.Add(TEXT("Output JSON to stdout (default: true)"));
    HelpParamNames.Add(TEXT("verbose"));
    HelpParamDescriptions.Add(TEXT("Enable verbose logging (default: false)"));
}

void UGSDValidateAssetsCommandlet::ParseParameters(const FString& Params)
{
    // Parse maxsize
    float ParsedMaxSize;
    if (FParse::Value(*Params, TEXT("maxsize="), ParsedMaxSize))
    {
        MaxAssetSizeMB = ParsedMaxSize;
        GSDTELEMETRY_LOG(Log, TEXT("Parsed maxsize: %.2f MB"), MaxAssetSizeMB);
    }

    // Parse output path
    FString ParsedOutputPath;
    if (FParse::Value(*Params, TEXT("output="), ParsedOutputPath))
    {
        OutputPath = ParsedOutputPath;
        GSDTELEMETRY_LOG(Log, TEXT("Parsed output path: %s"), *OutputPath);
    }

    // Parse json flag
    FString JsonFlag;
    if (FParse::Value(*Params, TEXT("json="), JsonFlag))
    {
        bOutputJSON = JsonFlag.ToLower() == TEXT("true");
        GSDTELEMETRY_LOG(Log, TEXT("Parsed json output: %s"), bOutputJSON ? TEXT("true") : TEXT("false"));
    }

    // Parse verbose flag
    FString VerboseFlag;
    if (FParse::Value(*Params, TEXT("verbose="), VerboseFlag))
    {
        bVerbose = VerboseFlag.ToLower() == TEXT("true");
        GSDTELEMETRY_LOG(Log, TEXT("Parsed verbose: %s"), bVerbose ? TEXT("true") : TEXT("false"));
    }
}

void UGSDValidateAssetsCommandlet::InitializeDefaultBudgets()
{
    // Set per-asset-type budgets (in MB)
    AssetTypeBudgets.Add(TEXT("StaticMesh"), 50.0f);
    AssetTypeBudgets.Add(TEXT("Texture2D"), 100.0f);
    AssetTypeBudgets.Add(TEXT("SkeletalMesh"), 75.0f);
    AssetTypeBudgets.Add(TEXT("SoundWave"), 25.0f);
    AssetTypeBudgets.Add(TEXT("AnimSequence"), 50.0f);
    AssetTypeBudgets.Add(TEXT("Material"), 10.0f);
    // Default fallback uses MaxAssetSizeMB
}

int32 UGSDValidateAssetsCommandlet::Main(const FString& Params)
{
    GSDTELEMETRY_LOG(Log, TEXT("GSDValidateAssetsCommandlet starting..."));

    const double StartTime = FPlatformTime::Seconds();

    // Parse parameters
    ParseParameters(Params);

    // Initialize budgets
    InitializeDefaultBudgets();

    // Validation result
    FGSDValidationResult Result;

    // Iterate all assets
    int32 TotalAssets = 0;
    for (TObjectIterator<UObject> It; It; ++It)
    {
        UObject* Asset = *It;
        if (!Asset || !Asset->IsAsset())
            continue;

        TotalAssets++;
        Result.TotalAssetsChecked++;

        // Validate asset
        if (!ValidateAsset(Asset, Result))
        {
            // Error already added by ValidateAsset
            if (bVerbose)
            {
                GSDTELEMETRY_LOG(Warning, TEXT("Asset validation failed: %s"), *Asset->GetPathName());
            }
        }
    }

    const double EndTime = FPlatformTime::Seconds();
    Result.ValidationTimeSeconds = EndTime - StartTime;

    // Output results
    if (bOutputJSON)
    {
        OutputJSON(Result);
    }
    else
    {
        OutputText(Result);
    }

    GSDTELEMETRY_LOG(Log, TEXT("GSDValidateAssetsCommandlet completed: %s"),
        Result.bPassed ? TEXT("SUCCESS") : TEXT("FAILED"));
    GSDTELEMETRY_LOG(Log, TEXT("Assets checked: %d | Errors: %d | Warnings: %d | Time: %.2fs"),
        Result.TotalAssetsChecked, Result.ErrorCount, Result.WarningCount, Result.ValidationTimeSeconds);

    return Result.bPassed ? 0 : 1;
}

bool UGSDValidateAssetsCommandlet::ValidateAsset(UObject* Asset, FGSDValidationResult& OutResult)
{
    if (!Asset)
        return false;

    const FString AssetPath = Asset->GetPathName();
    const FString AssetType = GetAssetType(Asset);
    const float AssetSizeMB = GetAssetSizeMB(Asset);

    // Get budget for this asset type (or use default)
    const float* BudgetPtr = AssetTypeBudgets.Find(AssetType);
    const float BudgetMB = BudgetPtr ? *BudgetPtr : MaxAssetSizeMB;

    // Check size against budget
    if (AssetSizeMB > BudgetMB)
    {
        const FString Description = FString::Printf(
            TEXT("Asset size %.2f MB exceeds budget %.2f MB for type %s"),
            AssetSizeMB, BudgetMB, *AssetType);

        const FString Suggestion = TEXT("Reduce asset size or increase budget in validation config");

        OutResult.AddError(AssetPath, TEXT("SizeExceeded"), Description, Suggestion);

        GSDTELEMETRY_LOG(Error, TEXT("%s"), *Description);
        return false;
    }

    if (bVerbose)
    {
        GSDTELEMETRY_LOG(Log, TEXT("Asset OK: %s (%.2f MB, budget: %.2f MB)"),
            *AssetPath, AssetSizeMB, BudgetMB);
    }

    return true;
}

FString UGSDValidateAssetsCommandlet::GetAssetType(UObject* Asset) const
{
    if (!Asset)
        return TEXT("Unknown");

    UClass* Class = Asset->GetClass();
    if (!Class)
        return TEXT("Unknown");

    // Return class name without U prefix
    FString ClassName = Class->GetName();
    if (ClassName.StartsWith(TEXT("U")))
    {
        ClassName.RemoveAt(0);
    }

    return ClassName;
}

float UGSDValidateAssetsCommandlet::GetAssetSizeMB(UObject* Asset) const
{
    if (!Asset)
        return 0.0f;

    // Get asset size from its outermost package
    if (UPackage* Package = Asset->GetOutermost())
    {
        FString PackagePath;
        if (FPackageName::TryConvertLongPackageNameToFilename(Package->GetName(), PackagePath))
        {
            if (FPaths::FileExists(PackagePath))
            {
                const int64 FileSize = IFileManager::Get().FileSize(*PackagePath);
                return static_cast<float>(FileSize) / (1024.0f * 1024.0f);
            }
        }
    }

    return 0.0f;
}

void UGSDValidateAssetsCommandlet::OutputJSON(const FGSDValidationResult& Result)
{
    TSharedPtr<FJsonObject> JsonObject = MakeShareable(new FJsonObject);

    JsonObject->SetBoolField(TEXT("passed"), Result.bPassed);
    JsonObject->SetNumberField(TEXT("total_assets_checked"), Result.TotalAssetsChecked);
    JsonObject->SetNumberField(TEXT("error_count"), Result.ErrorCount);
    JsonObject->SetNumberField(TEXT("warning_count"), Result.WarningCount);
    JsonObject->SetNumberField(TEXT("validation_time_seconds"), Result.ValidationTimeSeconds);

    // Issues array
    TArray<TSharedPtr<FJsonValue>> IssuesArray;
    for (const FGSDValidationIssue& Issue : Result.Issues)
    {
        TSharedPtr<FJsonObject> IssueObj = MakeShareable(new FJsonObject);
        IssueObj->SetStringField(TEXT("asset_path"), Issue.AssetPath);
        IssueObj->SetStringField(TEXT("issue_type"), Issue.IssueType);
        IssueObj->SetStringField(TEXT("description"), Issue.Description);
        IssueObj->SetNumberField(TEXT("severity"), Issue.Severity);
        IssueObj->SetStringField(TEXT("suggestion"), Issue.Suggestion);
        IssuesArray.Add(MakeShareable(new FJsonValueObject(IssueObj)));
    }
    JsonObject->SetArrayField(TEXT("issues"), IssuesArray);

    // Serialize to string
    FString OutputString;
    TSharedRef<TJsonWriter<>> JsonWriter = TJsonWriterFactory<>::Create(&OutputString);
    FJsonSerializer::Serialize(JsonObject.ToSharedRef(), JsonWriter);

    // Output to stdout for CI parsing
    fprintf(stdout, "%s\n", *OutputString);
    fflush(stdout);

    // Log for visibility
    GSDTELEMETRY_LOG(Log, TEXT("JSON_OUTPUT: %s"), *OutputString);

    // Write to file if path specified
    if (!OutputPath.IsEmpty())
    {
        FFileHelper::SaveStringToFile(OutputString, *OutputPath, FFileHelper::EEncodingOptions::ForceUTF8WithoutBOM);
        GSDTELEMETRY_LOG(Log, TEXT("JSON report written to: %s"), *OutputPath);
    }
}

void UGSDValidateAssetsCommandlet::OutputText(const FGSDValidationResult& Result)
{
    const FString Status = Result.bPassed ? TEXT("PASSED") : TEXT("FAILED");

    GSDTELEMETRY_LOG(Log, TEXT("=== ASSET VALIDATION RESULT ==="));
    GSDTELEMETRY_LOG(Log, TEXT("Status: %s"), *Status);
    GSDTELEMETRY_LOG(Log, TEXT("Total Assets Checked: %d"), Result.TotalAssetsChecked);
    GSDTELEMETRY_LOG(Log, TEXT("Errors: %d"), Result.ErrorCount);
    GSDTELEMETRY_LOG(Log, TEXT("Warnings: %d"), Result.WarningCount);
    GSDTELEMETRY_LOG(Log, TEXT("Validation Time: %.2f seconds"), Result.ValidationTimeSeconds);

    if (Result.Issues.Num() > 0)
    {
        GSDTELEMETRY_LOG(Log, TEXT(""));
        GSDTELEMETRY_LOG(Log, TEXT("Issues:"));
        for (const FGSDValidationIssue& Issue : Result.Issues)
        {
            const FString SeverityStr = Issue.Severity > 0.5f ? TEXT("ERROR") : TEXT("WARNING");
            GSDTELEMETRY_LOG(Log, TEXT("  [%s] %s"), *SeverityStr, *Issue.AssetPath);
            GSDTELEMETRY_LOG(Log, TEXT("    Type: %s"), *Issue.IssueType);
            GSDTELEMETRY_LOG(Log, TEXT("    Description: %s"), *Issue.Description);
            if (!Issue.Suggestion.IsEmpty())
            {
                GSDTELEMETRY_LOG(Log, TEXT("    Suggestion: %s"), *Issue.Suggestion);
            }
        }
    }
}
```

**Important:**
- Follow GSDVehicleTestCommandlet pattern for parameter parsing
- Use TObjectIterator to scan all assets
- Calculate asset size from package file on disk
- Use FJsonObjectConverter for JSON serialization
- Output to stdout for CI parsing (fprintf + fflush)
- Support optional file output with -output parameter
- Return 0 on success, 1 on failure for CI integration
</action>
  <verify>
    ```bash
    # Verify implementation file exists
    test -f Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDValidateAssetsCommandlet.cpp \
      && echo "Implementation file exists" || echo "ERROR: Implementation file missing"

    # Verify Main implementation
    grep -q "int32 UGSDValidateAssetsCommandlet::Main" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDValidateAssetsCommandlet.cpp \
      && echo "Main implemented" || echo "ERROR: Main not implemented"

    # Validate JSON output
    grep -q "fprintf.*stdout.*OutputString" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDValidateAssetsCommandlet.cpp \
      && echo "JSON output to stdout configured" || echo "ERROR: JSON output missing"

    # Verify asset iteration
    grep -q "TObjectIterator<UObject>" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDValidateAssetsCommandlet.cpp \
      && echo "Asset iteration present" || echo "ERROR: Asset iteration missing"

    # Verify exit code
    grep -q "return Result.bPassed ? 0 : 1" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDValidateAssetsCommandlet.cpp \
      && echo "Exit code logic present" || echo "ERROR: Exit code missing"
    ```
  </verify>
  <done>
Asset validation commandlet implemented with:
- Main() with parameter parsing (maxsize, output, json, verbose)
- ValidateAsset() checking size against per-asset-type budgets
- GetAssetSizeMB() calculating size from package file on disk
- OutputJSON() using FJsonObjectConverter for structured output
- OutputText() for human-readable format
- stdout output for CI parsing (fprintf + fflush)
- Exit code 0/1 for CI integration
- Per-asset-type budgets (StaticMesh: 50MB, Texture2D: 100MB, etc.)
  </done>
</task>

</tasks>

<verification>
1. Commandlet runs headlessly with -run=GSDValidateAssets
2. Asset sizes are checked against per-asset-type budgets
3. JSON output is parseable by CI systems
4. Exit code 0 on success, 1 on failure
5. Optional file output with -output parameter
</verification>

<success_criteria>
- UGSDValidateAssetsCommandlet extends UCommandlet
- Asset validation scans all assets via TObjectIterator
- Size checking uses per-asset-type budgets (StaticMesh: 50MB, Texture2D: 100MB, etc.)
- JSON output includes passed, total_assets_checked, error_count, issues array
- Exit code 0/1 enables CI/CD integration
</success_criteria>

<output>
After completion, create `.planning/phases/10-telemetry-validation/10-05-SUMMARY.md`
</output>
