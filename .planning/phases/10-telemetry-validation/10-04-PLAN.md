---
phase: 10-telemetry-validation
plan: 04
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDStreamingTelemetry.h
  - Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDStreamingTelemetry.cpp
autonomous: true
must_haves:
  truths:
    - "Streaming cell load times are captured and recorded"
    - "Cell load times are associated with districts"
    - "Telemetry integrates with existing streaming system"
    - "Cell load metrics are queryable by district"
  artifacts:
    - path: "Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDStreamingTelemetry.h"
      provides: "Extended streaming telemetry interface"
      contains: "RecordCellLoadTime, GetCellLoadTimesByDistrict"
    - path: "Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDStreamingTelemetry.cpp"
      provides: "Streaming telemetry implementation"
      contains: "Cell load time tracking and district mapping"
  key_links:
    - from: "UGSDStreamingTelemetry"
      to: "FGSDCellLoadTimeRecord"
      via: "Cell load time storage"
      pattern: "TArray<FGSDCellLoadTimeRecord>"
---

<objective>
Extend existing GSDStreamingTelemetry to capture cell load times by district.

Purpose: Implement TEL-03 by tracking World Partition cell load times and associating them with districts for performance analysis.
Output: Extended streaming telemetry subsystem with cell load time tracking and district-based metrics.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-telemetry-validation/10-RESEARCH.md

# Reference existing streaming telemetry (if exists)
# If not, this plan creates it from scratch
@Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Types/GSDTelemetryTypes.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Streaming Telemetry Subsystem Header</name>
  <files>Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDStreamingTelemetry.h</files>
  <action>
Create streaming telemetry subsystem for tracking cell load times by district.

**GSDStreamingTelemetry.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "Types/GSDTelemetryTypes.h"
#include "GSDStreamingTelemetry.generated.h"

// Delegates
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnCellLoaded, const FName&, CellName, float, LoadTimeMs);

/**
 * Streaming telemetry subsystem for tracking World Partition cell load times by district
 * Implements TEL-03 (streaming cell load times in telemetry)
 */
UCLASS(Config=Game, DefaultConfig)
class GSD_TELEMETRY_API UGSDStreamingTelemetry : public UGameInstanceSubsystem
{
    GENERATED_BODY()

public:
    virtual void Initialize(FSubsystemCollectionBase& Collection) override;
    virtual void Deinitialize() override;

    // Cell load time tracking
    UFUNCTION(BlueprintCallable, Category = "GSD|Telemetry|Streaming")
    void RecordCellLoadTime(const FName& CellName, float LoadTimeMs, const FName& DistrictName);

    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry|Streaming")
    TArray<FGSDCellLoadTimeRecord> GetCellLoadTimesByDistrict(const FName& DistrictName) const;

    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry|Streaming")
    float GetAverageCellLoadTimeMs(const FName& DistrictName) const;

    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry|Streaming")
    void GetAllCellLoadTimes(TArray<FGSDCellLoadTimeRecord>& OutRecords) const;

    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry|Streaming")
    void GetAllDistrictNames(TArray<FName>& OutDistrictNames) const;

    // Statistics
    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry|Streaming")
    int32 GetTotalCellsLoaded() const { return TotalCellsLoaded; }

    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry|Streaming")
    float GetMaxCellLoadTimeMs() const { return MaxCellLoadTimeMs; }

    // Delegates
    UPROPERTY(BlueprintAssignable, Category = "GSD|Telemetry|Streaming")
    FOnCellLoaded OnCellLoaded;

    // Configuration
    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Streaming")
    int32 MaxRecordsPerDistrict = 100;  // Circular buffer size

    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Streaming")
    float SlowLoadThresholdMs = 100.0f;  // Warn if cell load exceeds this

    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Streaming")
    bool bLogSlowLoads = true;

protected:
    void PruneOldRecords(const FName& DistrictName);

private:
    // Per-district cell load time records
    UPROPERTY()
    TMap<FName, TArray<FGSDCellLoadTimeRecord>> DistrictCellLoadTimes;

    // Statistics
    int32 TotalCellsLoaded = 0;
    float MaxCellLoadTimeMs = 0.0f;
};
```

**Important:**
- Extend UGameInstanceSubsystem for cross-level persistence
- Use TMap<FName, TArray<FGSDCellLoadTimeRecord>> for per-district tracking
- Implement circular buffer pattern (MaxRecordsPerDistrict)
- Include SlowLoadThresholdMs for warning logs
- Provide both BlueprintCallable and BlueprintPure methods
</action>
  <verify>
    ```bash
    # Verify subsystem header exists
    test -f Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDStreamingTelemetry.h \
      && echo "Subsystem header exists" || echo "ERROR: Subsystem header missing"

    # Verify GameInstanceSubsystem base class
    grep -q "UGameInstanceSubsystem" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDStreamingTelemetry.h \
      && echo "Correct base class" || echo "ERROR: Wrong base class"

    # Verify required methods
    grep -q "RecordCellLoadTime" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDStreamingTelemetry.h \
      && echo "RecordCellLoadTime method declared" || echo "ERROR: RecordCellLoadTime missing"

    grep -q "GetCellLoadTimesByDistrict" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Subsystems/GSDStreamingTelemetry.h \
      && echo "GetCellLoadTimesByDistrict method declared" || echo "ERROR: GetCellLoadTimesByDistrict missing"
    ```
  </verify>
  <done>
Streaming telemetry subsystem header created with:
- UGameInstanceSubsystem base class for cross-level persistence
- RecordCellLoadTime method for tracking cell loads by district
- GetCellLoadTimesByDistrict and GetAverageCellLoadTimeMs query methods
- Circular buffer pattern with configurable MaxRecordsPerDistrict (default 100)
- SlowLoadThresholdMs (100ms) for warning slow cell loads
- FOnCellLoaded delegate for real-time notifications
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Streaming Telemetry Subsystem</name>
  <files>Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDStreamingTelemetry.cpp</files>
  <action>
Implement the streaming telemetry subsystem with cell load time tracking and district-based metrics.

**GSDStreamingTelemetry.cpp:**
```cpp
#include "Subsystems/GSDStreamingTelemetry.h"
#include "GSDTelemetryLog.h"
#include "GSDTelemetryStats.h"

void UGSDStreamingTelemetry::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);

    GSDTELEMETRY_LOG(Log, TEXT("GSDStreamingTelemetry initializing..."));
}

void UGSDStreamingTelemetry::Deinitialize()
{
    GSDTELEMETRY_LOG(Log, TEXT("GSDStreamingTelemetry deinitializing..."));

    // Clear data
    DistrictCellLoadTimes.Empty();
    TotalCellsLoaded = 0;
    MaxCellLoadTimeMs = 0.0f;

    Super::Deinitialize();
}

void UGSDStreamingTelemetry::RecordCellLoadTime(const FName& CellName, float LoadTimeMs, const FName& DistrictName)
{
    SCOPE_CYCLE_COUNTER(STAT_GSDRecordCellLoadTime);

    // Create record
    FGSDCellLoadTimeRecord Record;
    Record.CellName = CellName;
    Record.LoadTimeMs = LoadTimeMs;
    Record.DistrictName = DistrictName;
    Record.Timestamp = FPlatformTime::Seconds();

    // Get or create array for district
    TArray<FGSDCellLoadTimeRecord>& Records = DistrictCellLoadTimes.FindOrAdd(DistrictName);

    // Add record
    Records.Add(Record);

    // Prune old records if exceeding limit
    if (Records.Num() > MaxRecordsPerDistrict)
    {
        PruneOldRecords(DistrictName);
    }

    // Update statistics
    TotalCellsLoaded++;
    if (LoadTimeMs > MaxCellLoadTimeMs)
    {
        MaxCellLoadTimeMs = LoadTimeMs;
    }

    // Log slow loads
    if (bLogSlowLoads && LoadTimeMs > SlowLoadThresholdMs)
    {
        GSDTELEMETRY_LOG(Warning, TEXT("Slow cell load detected: %s in district %s took %.2fms (threshold: %.2fms)"),
            *CellName.ToString(), *DistrictName.ToString(), LoadTimeMs, SlowLoadThresholdMs);
    }

    // Broadcast delegate
    OnCellLoaded.Broadcast(CellName, LoadTimeMs);

    GSDTELEMETRY_LOG(Verbose, TEXT("Cell loaded: %s in %.2fms (district: %s)"),
        *CellName.ToString(), LoadTimeMs, *DistrictName.ToString());
}

void UGSDStreamingTelemetry::PruneOldRecords(const FName& DistrictName)
{
    TArray<FGSDCellLoadTimeRecord>* Records = DistrictCellLoadTimes.Find(DistrictName);
    if (Records && Records->Num() > MaxRecordsPerDistrict)
    {
        // Remove oldest records (keep most recent MaxRecordsPerDistrict)
        const int32 NumToRemove = Records->Num() - MaxRecordsPerDistrict;
        Records->RemoveAt(0, NumToRemove);
    }
}

TArray<FGSDCellLoadTimeRecord> UGSDStreamingTelemetry::GetCellLoadTimesByDistrict(const FName& DistrictName) const
{
    const TArray<FGSDCellLoadTimeRecord>* Records = DistrictCellLoadTimes.Find(DistrictName);
    return Records ? *Records : TArray<FGSDCellLoadTimeRecord>();
}

float UGSDStreamingTelemetry::GetAverageCellLoadTimeMs(const FName& DistrictName) const
{
    const TArray<FGSDCellLoadTimeRecord>* Records = DistrictCellLoadTimes.Find(DistrictName);
    if (!Records || Records->Num() == 0)
    {
        return 0.0f;
    }

    float TotalTime = 0.0f;
    for (const FGSDCellLoadTimeRecord& Record : *Records)
    {
        TotalTime += Record.LoadTimeMs;
    }

    return TotalTime / static_cast<float>(Records->Num());
}

void UGSDStreamingTelemetry::GetAllCellLoadTimes(TArray<FGSDCellLoadTimeRecord>& OutRecords) const
{
    OutRecords.Empty();

    for (const auto& Pair : DistrictCellLoadTimes)
    {
        OutRecords.Append(Pair.Value);
    }
}

void UGSDStreamingTelemetry::GetAllDistrictNames(TArray<FName>& OutDistrictNames) const
{
    DistrictCellLoadTimes.GetKeys(OutDistrictNames);
}
```

**Important:**
- Use SCOPE_CYCLE_COUNTER for stats integration
- Prune old records to prevent unbounded memory growth
- Log warnings for slow loads (configurable threshold)
- Calculate average load time from all records in district
- Broadcast delegate for real-time cell load notifications
</action>
  <verify>
    ```bash
    # Verify implementation file exists
    test -f Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDStreamingTelemetry.cpp \
      && echo "Implementation file exists" || echo "ERROR: Implementation file missing"

    # Verify Initialize/Deinitialize
    grep -q "void UGSDStreamingTelemetry::Initialize" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDStreamingTelemetry.cpp \
      && echo "Initialize implemented" || echo "ERROR: Initialize not implemented"

    # Verify RecordCellLoadTime implementation
    grep -q "void UGSDStreamingTelemetry::RecordCellLoadTime" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDStreamingTelemetry.cpp \
      && echo "RecordCellLoadTime implemented" || echo "ERROR: RecordCellLoadTime not implemented"

    # Verify pruning logic
    grep -q "PruneOldRecords" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDStreamingTelemetry.cpp \
      && echo "Pruning logic present" || echo "ERROR: Pruning logic missing"

    # Verify slow load warning
    grep -q "SlowLoadThresholdMs" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Subsystems/GSDStreamingTelemetry.cpp \
      && echo "Slow load warning configured" || echo "ERROR: Slow load warning missing"
    ```
  </verify>
  <done>
Streaming telemetry subsystem implemented with:
- Initialize/Deinitialize lifecycle management
- RecordCellLoadTime with district-based storage and circular buffer pruning
- GetCellLoadTimesByDistrict and GetAverageCellLoadTimeMs query methods
- PruneOldRecords to maintain MaxRecordsPerDistrict limit
- Slow load warning when LoadTimeMs > SlowLoadThresholdMs (100ms)
- FOnCellLoaded delegate for real-time notifications
- Stats integration via SCOPE_CYCLE_COUNTER
  </done>
</task>

</tasks>

<verification>
1. Subsystem initializes automatically on game instance creation
2. Cell load times are recorded and associated with districts
3. Circular buffer prevents unbounded memory growth
4. Slow loads (over 100ms) generate warnings
5. Average load times are queryable by district
</verification>

<success_criteria>
- UGSDStreamingTelemetry extends UGameInstanceSubsystem
- Cell load times tracked per-district using TArray<FGSDCellLoadTimeRecord>
- Circular buffer maintains MaxRecordsPerDistrict (100) records per district
- Slow load threshold (100ms) generates warnings
- GetAverageCellLoadTimeMs calculates average from district records
</success_criteria>

<output>
After completion, create `.planning/phases/10-telemetry-validation/10-04-SUMMARY.md`
</output>
