---
phase: 10-telemetry-validation
plan: 07
type: execute
wave: 3
depends_on: [10-01, 10-02]
files_modified:
  - Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDRunPerfRouteCommandlet.h
  - Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDRunPerfRouteCommandlet.cpp
autonomous: true
must_haves:
  truths:
    - "GSDRunPerfRoute commandlet captures performance baseline"
    - "Metrics are captured at defined waypoints"
    - "Baseline comparison identifies performance regressions"
    - "Results are output as JSON for CI/CD parsing"
  artifacts:
    - path: "Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDRunPerfRouteCommandlet.h"
      provides: "Performance route commandlet interface"
      contains: "UGSDRunPerfRouteCommandlet : public UCommandlet"
    - path: "Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDRunPerfRouteCommandlet.cpp"
      provides: "Performance route implementation"
      contains: "Main, RunRoute, CaptureMetricsAtWaypoint"
  key_links:
    - from: "UGSDRunPerfRouteCommandlet"
      to: "FGSDPerfRouteWaypoint"
      via: "Waypoint definitions"
      pattern: "TArray<FGSDPerfRouteWaypoint>"
---

<objective>
Create GSDRunPerfRoute commandlet for performance baseline capture.

Purpose: Implement TEL-06 by capturing performance metrics along a predefined route for regression detection.
Output: UCommandlet that follows waypoints, captures metrics, and outputs JSON results.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-telemetry-validation/10-RESEARCH.md

# Reference existing commandlet patterns
@Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Commandlets/GSDCrowdTestCommandlet.cpp
@Plugins/GSD_ValidationTools/Source/GSD_ValidationTools/Public/Types/GSDValidationTypes.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Performance Route Commandlet</name>
  <files>
    Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDRunPerfRouteCommandlet.h
    Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDRunPerfRouteCommandlet.cpp
  </files>
  <action>
Create the performance route commandlet for baseline capture.

**GSDRunPerfRouteCommandlet.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Commandlets/Commandlet.h"
#include "Types/GSDValidationTypes.h"
#include "GSDRunPerfRouteCommandlet.generated.h"

/**
 * Performance route waypoint result
 */
USTRUCT(BlueprintType)
struct FGSDWaypointResult
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Performance")
    FString WaypointName;

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Performance")
    float CapturedFrameTimeMs = 0.0f;

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Performance")
    float ExpectedFrameTimeMs = 16.67f;

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Performance")
    bool bPassed = true;

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Performance")
    float DeltaMs = 0.0f;  // Actual - Expected
};

/**
 * Performance route commandlet for CI pipelines
 * Implements TEL-06 (GSDRunPerfRoute commandlet)
 *
 * Usage:
 *   UnrealEditor-Cmd.exe MyProject -run=GSDRunPerfRoute
 *
 * Parameters:
 *   - targetfps=60      : Target FPS for validation (default: 60)
 *   - tolerance=0.1     : Tolerance for frame time (default: 0.1 = 10%)
 *   - duration=5.0      : Test duration in seconds (default: 5.0)
 *   - json=true         : Output JSON to stdout (default: true)
 *
 * Exit codes:
 *   0 = Performance within baseline
 *   1 = Performance regression detected
 */
UCLASS()
class GSD_TELEMETRY_API UGSDRunPerfRouteCommandlet : public UCommandlet
{
    GENERATED_BODY()

public:
    UGSDRunPerfRouteCommandlet();

    virtual int32 Main(const FString& Params) override;

private:
    // Configuration
    UPROPERTY()
    float TargetFPS = 60.0f;

    UPROPERTY()
    float Tolerance = 0.1f;  // 10% tolerance

    UPROPERTY()
    float TestDuration = 5.0f;

    UPROPERTY()
    bool bOutputJSON = true;

    UPROPERTY()
    bool bVerbose = false;

    // Waypoints (simplified - actual implementation would load from config)
    UPROPERTY()
    TArray<FGSDPerfRouteWaypoint> Waypoints;

    // Results
    UPROPERTY()
    TArray<FGSDWaypointResult> WaypointResults;

    // Methods
    void ParseParameters(const FString& Params);
    void InitializeDefaultWaypoints();
    bool RunRoute(UWorld* World);
    FGSDWaypointResult CaptureMetricsAtWaypoint(const FGSDPerfRouteWaypoint& Waypoint, UWorld* World);
    void OutputJSON(const TArray<FGSDWaypointResult>& Results);
    void OutputText(const TArray<FGSDWaypointResult>& Results);
};
```

**GSDRunPerfRouteCommandlet.cpp:**
```cpp
#include "Commandlets/GSDRunPerfRouteCommandlet.h"
#include "GSDTelemetryLog.h"
#include "Subsystems/GSDPerformanceTelemetry.h"
#include "JsonObjectConverter.h"
#include "Misc/CommandLine.h"
#include "Misc/Parse.h"
#include "Engine/World.h"
#include "Engine/Engine.h"

UGSDRunPerfRouteCommandlet::UGSDRunPerfRouteCommandlet()
{
    HelpDescription = TEXT("Performance route commandlet for CI pipelines");
    HelpUsage = TEXT("UnrealEditor-Cmd.exe MyProject -run=GSDRunPerfRoute");
    HelpParamNames.Add(TEXT("targetfps"));
    HelpParamDescriptions.Add(TEXT("Target FPS for validation (default: 60)"));
    HelpParamNames.Add(TEXT("tolerance"));
    HelpParamDescriptions.Add(TEXT("Tolerance for frame time (default: 0.1 = 10%)"));
    HelpParamNames.Add(TEXT("duration"));
    HelpParamDescriptions.Add(TEXT("Test duration in seconds (default: 5.0)"));
    HelpParamNames.Add(TEXT("json"));
    HelpParamDescriptions.Add(TEXT("Output JSON to stdout (default: true)"));
}

void UGSDRunPerfRouteCommandlet::ParseParameters(const FString& Params)
{
    if (FParse::Value(*Params, TEXT("targetfps="), TargetFPS))
    {
        GSDTELEMETRY_LOG(Log, TEXT("Parsed targetfps: %.1f"), TargetFPS);
    }

    if (FParse::Value(*Params, TEXT("tolerance="), Tolerance))
    {
        GSDTELEMETRY_LOG(Log, TEXT("Parsed tolerance: %.2f"), Tolerance);
    }

    if (FParse::Value(*Params, TEXT("duration="), TestDuration))
    {
        GSDTELEMETRY_LOG(Log, TEXT("Parsed duration: %.1f"), TestDuration);
    }

    FString JsonFlag;
    if (FParse::Value(*Params, TEXT("json="), JsonFlag))
    {
        bOutputJSON = JsonFlag.ToLower() == TEXT("true");
    }

    FString VerboseFlag;
    if (FParse::Value(*Params, TEXT("verbose="), VerboseFlag))
    {
        bVerbose = VerboseFlag.ToLower() == TEXT("true");
    }
}

void UGSDRunPerfRouteCommandlet::InitializeDefaultWaypoints()
{
    // Create default waypoints for testing
    // In production, these would be loaded from config or test map
    Waypoints.Empty();

    FGSDPerfRouteWaypoint Waypoint1;
    Waypoint1.Location = FVector(0.0f, 0.0f, 0.0f);
    Waypoint1.WaypointName = TEXT("Start");
    Waypoint1.ExpectedFrameTimeMs = 1000.0f / TargetFPS;
    Waypoints.Add(Waypoint1);

    FGSDPerfRouteWaypoint Waypoint2;
    Waypoint2.Location = FVector(10000.0f, 0.0f, 0.0f);
    Waypoint2.WaypointName = TEXT("District_A");
    Waypoint2.ExpectedFrameTimeMs = 1000.0f / TargetFPS;
    Waypoints.Add(Waypoint2);

    FGSDPerfRouteWaypoint Waypoint3;
    Waypoint3.Location = FVector(10000.0f, 10000.0f, 0.0f);
    Waypoint3.WaypointName = TEXT("District_B");
    Waypoint3.ExpectedFrameTimeMs = 1000.0f / TargetFPS;
    Waypoints.Add(Waypoint3);
}

int32 UGSDRunPerfRouteCommandlet::Main(const FString& Params)
{
    GSDTELEMETRY_LOG(Log, TEXT("GSDRunPerfRouteCommandlet starting..."));

    const double StartTime = FPlatformTime::Seconds();

    // Parse parameters
    ParseParameters(Params);

    // Initialize waypoints
    InitializeDefaultWaypoints();

    // Get world
    UWorld* World = GWorld;
    if (!World)
    {
        GSDTELEMETRY_LOG(Error, TEXT("No world available for performance route"));
        FGSDWaypointResult ErrorResult;
        ErrorResult.WaypointName = TEXT("Error");
        ErrorResult.bPassed = false;
        WaypointResults.Add(ErrorResult);
        OutputJSON(WaypointResults);
        return 1;
    }

    // Run performance route
    const bool bAllPassed = RunRoute(World);

    const double EndTime = FPlatformTime::Seconds();

    // Output results
    if (bOutputJSON)
    {
        OutputJSON(WaypointResults);
    }
    else
    {
        OutputText(WaypointResults);
    }

    GSDTELEMETRY_LOG(Log, TEXT("GSDRunPerfRouteCommandlet completed: %s (Time: %.2fs)"),
        bAllPassed ? TEXT("SUCCESS") : TEXT("FAILED"), EndTime - StartTime);

    return bAllPassed ? 0 : 1;
}

bool UGSDRunPerfRouteCommandlet::RunRoute(UWorld* World)
{
    GSDTELEMETRY_LOG(Log, TEXT("Running performance route with %d waypoints..."), Waypoints.Num());

    bool bAllPassed = true;

    for (const FGSDPerfRouteWaypoint& Waypoint : Waypoints)
    {
        GSDTELEMETRY_LOG(Log, TEXT("Capturing metrics at waypoint: %s"), *Waypoint.WaypointName);

        // Capture metrics at waypoint
        FGSDWaypointResult Result = CaptureMetricsAtWaypoint(Waypoint, World);
        WaypointResults.Add(Result);

        if (!Result.bPassed)
        {
            bAllPassed = false;
            GSDTELEMETRY_LOG(Warning, TEXT("Waypoint %s failed: %.2fms (expected: %.2fms)"),
                *Waypoint.WaypointName, Result.CapturedFrameTimeMs, Result.ExpectedFrameTimeMs);
        }
        else if (bVerbose)
        {
            GSDTELEMETRY_LOG(Log, TEXT("Waypoint %s passed: %.2fms"), *Waypoint.WaypointName, Result.CapturedFrameTimeMs);
        }
    }

    return bAllPassed;
}

FGSDWaypointResult UGSDRunPerfRouteCommandlet::CaptureMetricsAtWaypoint(const FGSDPerfRouteWaypoint& Waypoint, UWorld* World)
{
    FGSDWaypointResult Result;
    Result.WaypointName = Waypoint.WaypointName;
    Result.ExpectedFrameTimeMs = Waypoint.ExpectedFrameTimeMs;

    // Note: In a real implementation, this would:
    // 1. Move player/camera to waypoint location
    // 2. Wait for streaming to settle
    // 3. Capture frame time samples over TestDuration
    // 4. Calculate average frame time

    // Simplified implementation: Simulate frame time capture
    TArray<float> FrameTimeSamples;
    const double WaypointStartTime = FPlatformTime::Seconds();
    const double WaypointEndTime = WaypointStartTime + TestDuration;

    while (FPlatformTime::Seconds() < WaypointEndTime)
    {
        // Tick world
        if (World)
        {
            World->Tick(LEVELTICK_All, 1.0f / TargetFPS);
        }

        // Simulate frame time capture (placeholder)
        // In production, use actual frame time from stats or telemetry
        const float FrameTimeMs = 1000.0f / TargetFPS;  // Placeholder
        FrameTimeSamples.Add(FrameTimeMs);

        // Small delay to prevent tight loop
        FPlatformProcess::Sleep(1.0f / TargetFPS);
    }

    // Calculate average frame time
    if (FrameTimeSamples.Num() > 0)
    {
        float TotalFrameTime = 0.0f;
        for (float FrameTime : FrameTimeSamples)
        {
            TotalFrameTime += FrameTime;
        }
        Result.CapturedFrameTimeMs = TotalFrameTime / static_cast<float>(FrameTimeSamples.Num());
    }

    // Calculate delta
    Result.DeltaMs = Result.CapturedFrameTimeMs - Result.ExpectedFrameTimeMs;

    // Check if within tolerance
    const float MaxAllowedFrameTimeMs = Result.ExpectedFrameTimeMs * (1.0f + Tolerance);
    Result.bPassed = Result.CapturedFrameTimeMs <= MaxAllowedFrameTimeMs;

    return Result;
}

void UGSDRunPerfRouteCommandlet::OutputJSON(const TArray<FGSDWaypointResult>& Results)
{
    TSharedPtr<FJsonObject> JsonObject = MakeShareable(new FJsonObject);

    const bool bAllPassed = [Results]() {
        for (const FGSDWaypointResult& Result : Results)
        {
            if (!Result.bPassed) return false;
        }
        return true;
    }();

    JsonObject->SetBoolField(TEXT("passed"), bAllPassed);
    JsonObject->SetNumberField(TEXT("target_fps"), TargetFPS);
    JsonObject->SetNumberField(TEXT("tolerance"), Tolerance);
    JsonObject->SetNumberField(TEXT("test_duration_seconds"), TestDuration);
    JsonObject->SetNumberField(TEXT("waypoint_count"), Results.Num());

    // Waypoints array
    TArray<TSharedPtr<FJsonValue>> WaypointsArray;
    for (const FGSDWaypointResult& Result : Results)
    {
        TSharedPtr<FJsonObject> WaypointObj = MakeShareable(new FJsonObject);
        WaypointObj->SetStringField(TEXT("waypoint_name"), Result.WaypointName);
        WaypointObj->SetNumberField(TEXT("captured_frame_time_ms"), Result.CapturedFrameTimeMs);
        WaypointObj->SetNumberField(TEXT("expected_frame_time_ms"), Result.ExpectedFrameTimeMs);
        WaypointObj->SetBoolField(TEXT("passed"), Result.bPassed);
        WaypointObj->SetNumberField(TEXT("delta_ms"), Result.DeltaMs);
        WaypointsArray.Add(MakeShareable(new FJsonValueObject(WaypointObj)));
    }
    JsonObject->SetArrayField(TEXT("waypoints"), WaypointsArray);

    // Serialize to string
    FString OutputString;
    TSharedRef<TJsonWriter<>> JsonWriter = TJsonWriterFactory<>::Create(&OutputString);
    FJsonSerializer::Serialize(JsonObject.ToSharedRef(), JsonWriter);

    // Output to stdout for CI parsing
    fprintf(stdout, "%s\n", *OutputString);
    fflush(stdout);

    GSDTELEMETRY_LOG(Log, TEXT("JSON_OUTPUT: %s"), *OutputString);
}

void UGSDRunPerfRouteCommandlet::OutputText(const TArray<FGSDWaypointResult>& Results)
{
    const FString Status = [Results]() {
        for (const FGSDWaypointResult& Result : Results)
        {
            if (!Result.bPassed) return TEXT("FAILED");
        }
        return TEXT("PASSED");
    }();

    GSDTELEMETRY_LOG(Log, TEXT("=== PERFORMANCE ROUTE RESULT ==="));
    GSDTELEMETRY_LOG(Log, TEXT("Status: %s"), *Status);
    GSDTELEMETRY_LOG(Log, TEXT("Target FPS: %.1f"), TargetFPS);
    GSDTELEMETRY_LOG(Log, TEXT("Tolerance: %.0f%%"), Tolerance * 100.0f);
    GSDTELEMETRY_LOG(Log, TEXT("Waypoints: %d"), Results.Num());

    for (const FGSDWaypointResult& Result : Results)
    {
        GSDTELEMETRY_LOG(Log, TEXT(""));
        GSDTELEMETRY_LOG(Log, TEXT("  Waypoint: %s"), *Result.WaypointName);
        GSDTELEMETRY_LOG(Log, TEXT("    Captured: %.2f ms"), Result.CapturedFrameTimeMs);
        GSDTELEMETRY_LOG(Log, TEXT("    Expected: %.2f ms"), Result.ExpectedFrameTimeMs);
        GSDTELEMETRY_LOG(Log, TEXT("    Delta: %.2f ms"), Result.DeltaMs);
        GSDTELEMETRY_LOG(Log, TEXT("    Status: %s"), Result.bPassed ? TEXT("PASS") : TEXT("FAIL"));
    }
}
```

**Important:**
- Waypoints define locations for metric capture
- Frame time captured over TestDuration at each waypoint
- Tolerance allows configurable performance threshold (10% default)
- Simplified implementation simulates frame time (production uses actual telemetry)
- JSON output includes per-waypoint results
- Exit code 0/1 for CI integration
</action>
  <verify>
    ```bash
    # Verify commandlet files exist
    test -f Plugins/GSD_Telemetry/Source/GSD_Telemetry/Public/Commandlets/GSDRunPerfRouteCommandlet.h \
      && echo "Header exists" || echo "ERROR: Header missing"

    test -f Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDRunPerfRouteCommandlet.cpp \
      && echo "Implementation exists" || echo "ERROR: Implementation missing"

    # Verify Main implementation
    grep -q "int32 UGSDRunPerfRouteCommandlet::Main" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDRunPerfRouteCommandlet.cpp \
      && echo "Main implemented" || echo "ERROR: Main not implemented"

    # Verify route execution
    grep -q "RunRoute" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDRunPerfRouteCommandlet.cpp \
      && echo "Route execution present" || echo "ERROR: Route execution missing"

    # Verify waypoint capture
    grep -q "CaptureMetricsAtWaypoint" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDRunPerfRouteCommandlet.cpp \
      && echo "Waypoint capture present" || echo "ERROR: Waypoint capture missing"

    # Verify tolerance check
    grep -q "Tolerance" \
      Plugins/GSD_Telemetry/Source/GSD_Telemetry/Private/Commandlets/GSDRunPerfRouteCommandlet.cpp \
      && echo "Tolerance check present" || echo "ERROR: Tolerance check missing"
    ```
  </verify>
  <done>
Performance route commandlet created with:
- UGSDRunPerfRouteCommandlet extends UCommandlet
- Main() with parameter parsing (targetfps, tolerance, duration, json, verbose)
- InitializeDefaultWaypoints() creating test waypoints
- RunRoute() executing waypoint traversal
- CaptureMetricsAtWaypoint() capturing frame time over duration
- FGSDWaypointResult struct for per-waypoint metrics
- Tolerance-based pass/fail (10% default)
- JSON output with waypoints array for CI parsing
- Exit code 0/1 for CI integration
  </done>
</task>

</tasks>

<verification>
1. Commandlet runs headlessly with -run=GSDRunPerfRoute
2. Waypoints are traversed and metrics captured
3. Frame time is compared against expected with tolerance
4. JSON output is parseable by CI systems
5. Exit code 0 on success, 1 on failure
</verification>

<success_criteria>
- UGSDRunPerfRouteCommandlet extends UCommandlet
- Waypoints define locations for metric capture (default 3 waypoints)
- Frame time captured over TestDuration (5s default)
- Tolerance allows configurable threshold (10% default)
- JSON output includes passed, waypoint_count, waypoints array
- Exit code 0/1 enables CI/CD integration
</success_criteria>

<output>
After completion, create `.planning/phases/10-telemetry-validation/10-07-SUMMARY.md`
</output>
