---
phase: 08-event-system-core
plan: 05
type: execute
wave: 4
depends_on: ["08-02", "08-03", "08-04"]
files_modified:
  - Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Subsystems/GSDEventSchedulerSubsystem.h
  - Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Subsystems/GSDEventSchedulerSubsystem.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Same date + seed always produces same event schedule"
    - "Event schedule persists across level loads"
    - "Scheduler uses GSDDeterminismManager::EventCategory for RNG"
    - "DateToSeed pattern converts dates to reproducible seeds"
    - "Scheduled events have time, location, and intensity"
    - "Events execute in deterministic order"
  artifacts:
    - path: "Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Subsystems/GSDEventSchedulerSubsystem.h"
      provides: "Deterministic event scheduling"
      contains: "UGSDEventSchedulerSubsystem"
      contains: "FGSDEventInstance"
      contains: "GenerateDailySchedule"
      min_lines: 80
    - path: "Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Subsystems/GSDEventSchedulerSubsystem.cpp"
      provides: "Scheduler implementation"
      contains: "DateToSeed"
      contains: "EventCategory"
      contains: "GetStream"
  key_links:
    - from: "GenerateDailySchedule"
      to: "GSDDeterminismManager"
      via: "GetStream(EventCategory)"
      pattern: "EventCategory"
    - from: "DateToSeed"
      to: "FDateTime"
      via: "Year*10000 + Month*100 + Day"
      pattern: "GetYear.*GetMonth.*GetDay"
    - from: "UGSDEventSchedulerSubsystem"
      to: "UGameInstanceSubsystem"
      via: "inheritance for cross-level persistence"
      pattern: ": public UGameInstanceSubsystem"
---

<objective>
Create the event scheduler subsystem for deterministic daily event generation.

Purpose: Generate event schedules from date + seed using GSDDeterminismManager::EventCategory. Same inputs always produce same outputs. Persists across level loads via UGameInstanceSubsystem.

Event Ordering (Pitfall 1 from research): Events execute in deterministic order to prevent dependencies causing race conditions. Events are sorted by scheduling timestamp first. For same-timestamp events, deterministic sort by EventTag name ensures consistent execution order across all runs.

Output: UGSDEventSchedulerSubsystem with GenerateDailySchedule, GetEventsForDate, StartEvent, and EndEvent methods.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-event-system-core/08-RESEARCH.md

# Reference patterns
@Plugins/GSD_Core/Source/GSD_Core/Public/Managers/GSDDeterminismManager.h
@Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Event Scheduler Subsystem Header</name>
  <files>
    Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Subsystems/GSDEventSchedulerSubsystem.h
  </files>
  <action>
    Create the event scheduler subsystem header with deterministic generation support.

    1. Create GSDEventSchedulerSubsystem.h:

    ```cpp
    #pragma once

    #include "CoreMinimal.h"
    #include "Subsystems/GameInstanceSubsystem.h"
    #include "GameplayTagContainer.h"
    #include "GSDEventSchedulerSubsystem.generated.h"

    class UGSDDailyEventConfig;
    class UGSDDeterminismManager;

    /** Scheduled event instance */
    USTRUCT(BlueprintType)
    struct FGSDEventInstance
    {
        GENERATED_BODY()

        UPROPERTY()
        TObjectPtr<UGSDDailyEventConfig> EventConfig;

        UPROPERTY()
        FGameplayTag EventTag;

        UPROPERTY()
        FDateTime ScheduledTime;

        UPROPERTY()
        FVector Location = FVector::ZeroVector;

        UPROPERTY()
        float Intensity = 1.0f;

        UPROPERTY()
        bool bIsActive = false;

        bool IsValid() const { return EventConfig != nullptr; }
    };

    DECLARE_DYNAMIC_DELEGATE_OneParam(FOnEventScheduled, const FGSDEventInstance&, Event);
    DECLARE_DYNAMIC_DELEGATE_OneParam(FOnEventStarted, const FGSDEventInstance&, Event);
    DECLARE_DYNAMIC_DELEGATE_OneParam(FOnEventEnded, const FGSDEventInstance&, Event);

    /**
     * Game instance subsystem for deterministic daily event scheduling.
     * Persists across level loads, generates schedules from date + seed.
     *
     * Determinism: Same date + world seed always produces same events.
     * Uses GSDDeterminismManager::EventCategory for isolated RNG.
     *
     * EVENT ORDERING (Pitfall 1 Mitigation):
     * Events execute in deterministic order to prevent race conditions:
     * 1. Primary sort: By ScheduledTime (earliest first)
     * 2. Secondary sort: By EventTag name (alphabetical) for same-timestamp events
     *
     * This ensures events with dependencies always execute in the same order
     * across all runs with the same seed.
     *
     * Usage:
     * 1. GenerateDailySchedule(Date, WorldSeed) - Generate events for a day
     * 2. GetEventsForDate(Date) - Retrieve scheduled events
     * 3. StartEvent(Event) - Begin event execution
     * 4. EndEvent(EventTag) - End active event
     */
    UCLASS()
    class GSD_DAILYEVENTS_API UGSDEventSchedulerSubsystem : public UGameInstanceSubsystem
    {
        GENERATED_BODY()

    public:
        //-- Schedule Generation --

        /**
         * Generate deterministic schedule for a specific date.
         * Uses GSDDeterminismManager::EventCategory for reproducible RNG.
         *
         * @param Date The date to generate events for
         * @param WorldSeed World-specific seed for variation
         */
        UFUNCTION(BlueprintCallable, Category = "GSD|Events")
        void GenerateDailySchedule(FDateTime Date, int32 WorldSeed);

        /**
         * Get events scheduled for a date.
         * Returns events sorted by ScheduledTime, then by EventTag for determinism.
         */
        UFUNCTION(BlueprintPure, Category = "GSD|Events")
        void GetEventsForDate(FDateTime Date, TArray<FGSDEventInstance>& OutEvents) const;

        //-- Runtime Control --

        /**
         * Start a scheduled event.
         * Calls EventConfig->OnEventStart and broadcasts to EventBus.
         */
        void StartEvent(const FGSDEventInstance& Event);

        /**
         * End an active event.
         * Calls EventConfig->OnEventEnd and broadcasts to EventBus.
         */
        UFUNCTION(BlueprintCallable, Category = "GSD|Events")
        void EndEvent(FGameplayTag EventTag);

        //-- Queries --

        UFUNCTION(BlueprintPure, Category = "GSD|Events")
        int32 GetScheduledEventCount() const { return ScheduledEvents.Num(); }

        UFUNCTION(BlueprintPure, Category = "GSD|Events")
        int32 GetActiveEventCount() const { return ActiveEvents.Num(); }

        //-- Delegates --

        FOnEventStarted& GetOnEventStarted() { return OnEventStarted; }
        FOnEventEnded& GetOnEventEnded() { return OnEventEnded; }

    protected:
        //-- State --
        UPROPERTY()
        TArray<FGSDEventInstance> ScheduledEvents;

        UPROPERTY()
        TArray<FGSDEventInstance> ActiveEvents;

        //-- Delegates --
        FOnEventStarted OnEventStarted;
        FOnEventEnded OnEventEnded;

        //-- Helpers --
        int32 DateToSeed(FDateTime Date) const;
        FVector GetRandomEventLocation(FRandomStream& Stream) const;
        TArray<UGSDDailyEventConfig*> LoadAvailableEvents() const;

        /**
         * Sort events for deterministic execution order.
         * Primary: ScheduledTime (earliest first)
         * Secondary: EventTag name (alphabetical) for same-timestamp events
         */
        void SortEventsForDeterministicExecution(TArray<FGSDEventInstance>& Events) const;
    };
    ```

    Key design decisions:
    - UGameInstanceSubsystem for cross-level persistence (not UWorldSubsystem)
    - FGSDEventInstance struct for serializable event data
    - DateToSeed helper for reproducible seed derivation
    - SortEventsForDeterministicExecution ensures consistent event order (Pitfall 1 mitigation)
  </action>
  <verify>
    grep -l "UGSDEventSchedulerSubsystem" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Subsystems/GSDEventSchedulerSubsystem.h
    grep -l "FGSDEventInstance" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Subsystems/GSDEventSchedulerSubsystem.h
    grep -l "GenerateDailySchedule" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Subsystems/GSDEventSchedulerSubsystem.h
    grep -l "UGameInstanceSubsystem" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Subsystems/GSDEventSchedulerSubsystem.h
    grep -l "SortEventsForDeterministicExecution" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Subsystems/GSDEventSchedulerSubsystem.h
  </verify>
  <done>
    Scheduler header exists with FGSDEventInstance struct, GenerateDailySchedule, StartEvent, EndEvent, and deterministic ordering documentation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Event Scheduler Subsystem</name>
  <files>
    Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Subsystems/GSDEventSchedulerSubsystem.cpp
  </files>
  <action>
    Implement the event scheduler with deterministic generation using GSDDeterminismManager.

    1. Create GSDEventSchedulerSubsystem.cpp:

    ```cpp
    #include "Subsystems/GSDEventSchedulerSubsystem.h"
    #include "Subsystems/GSDEventBusSubsystem.h"
    #include "DataAssets/GSDDailyEventConfig.h"
    #include "Managers/GSDDeterminismManager.h"
    #include "Tags/GSDEventTags.h"
    #include "GSDEventLog.h"

    int32 UGSDEventSchedulerSubsystem::DateToSeed(FDateTime Date) const
    {
        // Convert date to integer: 20250115 for Jan 15, 2025
        // This ensures same date always produces same seed
        return Date.GetYear() * 10000 + Date.GetMonth() * 100 + Date.GetDay();
    }

    void UGSDEventSchedulerSubsystem::SortEventsForDeterministicExecution(TArray<FGSDEventInstance>& Events) const
    {
        // Sort for deterministic execution order (Pitfall 1 mitigation)
        // Primary: ScheduledTime (earliest first)
        // Secondary: EventTag name (alphabetical) for same-timestamp events
        Events.Sort([](const FGSDEventInstance& A, const FGSDEventInstance& B)
        {
            if (A.ScheduledTime != B.ScheduledTime)
            {
                return A.ScheduledTime < B.ScheduledTime;
            }
            // Same timestamp - use EventTag name for deterministic ordering
            return A.EventTag.ToString() < B.EventTag.ToString();
        });
    }

    void UGSDEventSchedulerSubsystem::GenerateDailySchedule(FDateTime Date, int32 WorldSeed)
    {
        GSDEVENT_LOG(Log, TEXT("Generating daily schedule for %s with world seed %d"),
            *Date.ToString(), WorldSeed);

        // Get determinism manager
        UGSDDeterminismManager* DeterminismMgr = GetGameInstance()->GetSubsystem<UGSDDeterminismManager>();
        if (!DeterminismMgr)
        {
            GSDEVENT_LOG(Error, TEXT("GSDDeterminismManager not found!"));
            return;
        }

        // Combine date and world seed for daily seed
        int32 DailySeed = DateToSeed(Date) ^ WorldSeed;
        DeterminismMgr->InitializeWithSeed(DailySeed);

        // Get event-specific stream (uses EventCategory from GSDDeterminismManager!)
        FRandomStream& EventStream = DeterminismMgr->GetStream(UGSDDeterminismManager::EventCategory);

        // Load available events
        TArray<UGSDDailyEventConfig*> AvailableEvents = LoadAvailableEvents();
        if (AvailableEvents.Num() == 0)
        {
            GSDEVENT_LOG(Warning, TEXT("No event configs found"));
            return;
        }

        // Select events for today (2-5 events per day)
        int32 NumEventsToday = EventStream.RandRange(2, 5);
        GSDEVENT_LOG(Log, TEXT("Scheduling %d events for today"), NumEventsToday);

        for (int32 i = 0; i < NumEventsToday && AvailableEvents.Num() > 0; ++i)
        {
            int32 EventIndex = EventStream.RandHelper(AvailableEvents.Num());
            UGSDDailyEventConfig* SelectedEvent = AvailableEvents[EventIndex];

            // Random time slot (8:00 - 22:00)
            int32 Hour = EventStream.RandRange(8, 22);
            FDateTime EventTime = Date + FTimespan(Hour, 0, 0);

            // Random location
            FVector EventLocation = GetRandomEventLocation(EventStream);

            // Random intensity (0.5 - 1.5)
            float Intensity = EventStream.FRandRange(0.5f, 1.5f);

            // Create event instance
            FGSDEventInstance Instance;
            Instance.EventConfig = SelectedEvent;
            Instance.EventTag = SelectedEvent->EventTag;
            Instance.ScheduledTime = EventTime;
            Instance.Location = EventLocation;
            Instance.Intensity = Intensity;
            Instance.bIsActive = false;

            ScheduledEvents.Add(Instance);

            GSDEVENT_LOG(Log, TEXT("Scheduled event %s at %s"),
                *SelectedEvent->EventTag.ToString(), *EventTime.ToString());

            // Remove to prevent duplicates
            AvailableEvents.RemoveAtSwap(EventIndex);
        }

        // Sort for deterministic execution order (Pitfall 1 mitigation)
        SortEventsForDeterministicExecution(ScheduledEvents);
    }

    void UGSDEventSchedulerSubsystem::GetEventsForDate(FDateTime Date, TArray<FGSDEventInstance>& OutEvents) const
    {
        OutEvents.Empty();
        for (const FGSDEventInstance& Event : ScheduledEvents)
        {
            if (Event.ScheduledTime.GetDate() == Date.GetDate())
            {
                OutEvents.Add(Event);
            }
        }

        // Return already sorted (was sorted on generation)
        // But re-sort to ensure determinism if caller modifies
        const_cast<UGSDEventSchedulerSubsystem*>(this)->SortEventsForDeterministicExecution(OutEvents);
    }

    void UGSDEventSchedulerSubsystem::StartEvent(const FGSDEventInstance& Event)
    {
        if (!Event.IsValid())
        {
            return;
        }

        GSDEVENT_LOG(Log, TEXT("Starting event: %s"), *Event.EventTag.ToString());

        // Call event start handler
        if (Event.EventConfig)
        {
            Event.EventConfig->OnEventStart(this, Event.Location, Event.Intensity);
        }

        // Broadcast to event bus
        if (UWorld* World = GetWorld())
        {
            if (UGSDEventBusSubsystem* EventBus = World->GetSubsystem<UGSDEventBusSubsystem>())
            {
                EventBus->BroadcastEvent(Event.EventTag, Event.Location, Event.Intensity);
            }
        }

        // Track as active
        FGSDEventInstance ActiveEvent = Event;
        ActiveEvent.bIsActive = true;
        ActiveEvents.Add(ActiveEvent);

        // Broadcast delegate
        OnEventStarted.Broadcast(Event);
    }

    void UGSDEventSchedulerSubsystem::EndEvent(FGameplayTag EventTag)
    {
        GSDEVENT_LOG(Log, TEXT("Ending event: %s"), *EventTag.ToString());

        for (int32 i = ActiveEvents.Num() - 1; i >= 0; --i)
        {
            if (ActiveEvents[i].EventTag == EventTag)
            {
                // Call event end handler
                if (ActiveEvents[i].EventConfig)
                {
                    ActiveEvents[i].EventConfig->OnEventEnd(this);
                }

                // Broadcast delegate
                OnEventEnded.Broadcast(ActiveEvents[i]);

                // Remove from active
                ActiveEvents.RemoveAtSwap(i);
            }
        }
    }

    FVector UGSDEventSchedulerSubsystem::GetRandomEventLocation(FRandomStream& Stream) const
    {
        // TODO: Implement proper location selection from valid spawn areas
        // For now, return random location within 5000 units of origin
        return FVector(
            Stream.FRandRange(-5000.0f, 5000.0f),
            Stream.FRandRange(-5000.0f, 5000.0f),
            0.0f
        );
    }

    TArray<UGSDDailyEventConfig*> UGSDEventSchedulerSubsystem::LoadAvailableEvents() const
    {
        TArray<UGSDDailyEventConfig*> Events;

        // TODO: Load from asset registry or config
        // For now, return empty array - Phase 9 will add concrete events

        GSDEVENT_LOG(Warning, TEXT("LoadAvailableEvents not implemented - no events loaded"));
        return Events;
    }
    ```

    CRITICAL: Uses UGSDDeterminismManager::EventCategory for seeded RNG. Same date + seed = same events.

    EVENT ORDERING (Pitfall 1 Mitigation):
    - Events sorted by ScheduledTime first
    - Same-timestamp events sorted by EventTag name (deterministic string comparison)
    - This prevents race conditions when events have dependencies

    AVOID: Do not use FMath::Rand*. Do not use system time. Do not store state in world subsystem.
  </action>
  <verify>
    grep -l "DateToSeed" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Subsystems/GSDEventSchedulerSubsystem.cpp
    grep -l "EventCategory" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Subsystems/GSDEventSchedulerSubsystem.cpp
    grep -l "GetStream" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Subsystems/GSDEventSchedulerSubsystem.cpp
    grep -l "GenerateDailySchedule" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Subsystems/GSDEventSchedulerSubsystem.cpp
    grep -l "SortEventsForDeterministicExecution" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Subsystems/GSDEventSchedulerSubsystem.cpp
  </verify>
  <done>
    Scheduler implementation uses GSDDeterminismManager::EventCategory. DateToSeed pattern converts dates to seeds. Same inputs produce same outputs. Deterministic event ordering implemented (Pitfall 1 mitigation).
  </done>
</task>

</tasks>

<verification>
1. Scheduler compiles without errors
2. DateToSeed(2025, 1, 15) returns 20250115
3. GenerateDailySchedule uses EventCategory for RNG
4. Same date + seed produces identical event schedules
5. Events execute in deterministic order (time, then tag name)
6. SortEventsForDeterministicExecution ensures consistent ordering
</verification>

<success_criteria>
- UGSDEventSchedulerSubsystem extends UGameInstanceSubsystem for cross-level persistence
- GenerateDailySchedule uses GSDDeterminismManager::EventCategory
- DateToSeed pattern: Year*10000 + Month*100 + Day
- FGSDEventInstance struct serializable for save/load
- StartEvent broadcasts to EventBus
- SortEventsForDeterministicExecution ensures deterministic event order (Pitfall 1 mitigation documented)
</success_criteria>

<output>
After completion, create `.planning/phases/08-event-system-core/08-05-SUMMARY.md`
</output>
