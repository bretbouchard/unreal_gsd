---
phase: 08-event-system-core
plan: 06
type: execute
wave: 5
depends_on: ["08-02", "08-05"]
files_modified:
  - Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Commandlets/GSDEventTestCommandlet.h
  - Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Commandlets/GSDEventTestCommandlet.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GSDEventTestCommandlet runs event system validation without editor"
    - "Commandlet outputs JSON for CI pipeline integration"
    - "Determinism is verified: same seed produces same schedule"
    - "Event bus subscribe/broadcast works correctly"
    - "Exit code 0 = success, 1 = failure"
  artifacts:
    - path: "Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Commandlets/GSDEventTestCommandlet.h"
      provides: "CI commandlet for event system validation"
      contains: "UGSDEventTestCommandlet"
      contains: "Main"
      min_lines: 60
    - path: "Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Commandlets/GSDEventTestCommandlet.cpp"
      provides: "Commandlet implementation"
      contains: "TestDeterminism"
      contains: "TestEventBus"
      contains: "OutputJSON"
  key_links:
    - from: "TestDeterminism"
      to: "GenerateDailySchedule"
      via: "same seed comparison"
      pattern: "GenerateDailySchedule.*Seed"
    - from: "OutputJSON"
      to: "stdout"
      via: "UE_LOG"
      pattern: "success.*determinism_verified.*event_bus_working"
---

<objective>
Create test commandlet for event system validation with CI pipeline integration.

Purpose: Verify event system works correctly in headless environment. Test determinism (same seed = same schedule), event bus (subscribe/broadcast), and data asset validation. Output JSON for CI parsing.

Output: UGSDEventTestCommandlet with determinism test, event bus test, and JSON output.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-event-system-core/08-RESEARCH.md

# Reference patterns
@Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Commandlets/GSDCrowdTestCommandlet.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Event Test Commandlet Header</name>
  <files>
    Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Commandlets/GSDEventTestCommandlet.h
  </files>
  <action>
    Create the commandlet header following GSDCrowdTestCommandlet pattern.

    1. Create Commandlets/ directory under Public/ and Private/

    2. Create GSDEventTestCommandlet.h:

    ```cpp
    // Copyright Bret Bouchard. All Rights Reserved.

    #pragma once

    #include "Commandlets/Commandlet.h"
    #include "GSDEventTestCommandlet.generated.h"

    /**
     * Commandlet for automated event system validation.
     *
     * Tests event bus, scheduler determinism, and data asset validation
     * without requiring editor interaction.
     *
     * Usage:
     *   UE-Editor.exe UnrealGSD.exe -run=GSDEventTest -seed=12345
     *
     * Exit codes:
     *   0 = All tests passed
     *   1 = Test failed
     *
     * JSON Output:
     * {
     *   "success": true,
     *   "determinism_verified": true,
     *   "event_bus_working": true,
     *   "scheduling_working": true,
     *   "test_duration_seconds": 1.5,
     *   "seed": 12345
     * }
     */
    UCLASS()
    class GSD_DAILYEVENTS_API UGSDEventTestCommandlet : public UCommandlet
    {
        GENERATED_BODY()

    public:
        UGSDEventTestCommandlet();

        // ~UCommandlet interface
        virtual int32 Main(const FString& Params) override;
        // ~End of UCommandlet interface

    private:
        //-- Test Parameters --
        int32 TestSeed = 12345;
        bool bOutputJSON = true;

        /**
         * Parse command line parameters.
         */
        void ParseParameters(const FString& Params);

        /**
         * Test scheduler determinism.
         * Generate schedule twice with same seed, verify identical results.
         *
         * @return True if determinism verified
         */
        UFUNCTION()
        bool TestDeterminism();

        /**
         * Test event bus subscribe/broadcast.
         * Subscribe to tag, broadcast, verify receipt.
         *
         * @return True if event bus works
         */
        UFUNCTION()
        bool TestEventBus();

        /**
         * Test event scheduling.
         * Generate schedule, verify events created.
         *
         * @return True if scheduling works
         */
        UFUNCTION()
        bool TestScheduling();

        /**
         * Output test results as JSON to stdout.
         */
        void OutputJSON(bool bSuccess, bool bDeterminismVerified, bool bEventBusWorking, bool bSchedulingWorking, float Duration);

        /**
         * Output test results as human-readable text.
         */
        void OutputText(bool bSuccess, bool bDeterminismVerified, bool bEventBusWorking, bool bSchedulingWorking);
    };
    ```

    Follow exact documentation style from GSDCrowdTestCommandlet with Usage, Exit codes, JSON Output sections.
  </action>
  <verify>
    grep -l "UGSDEventTestCommandlet" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Commandlets/GSDEventTestCommandlet.h
    grep -l "TestDeterminism" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Commandlets/GSDEventTestCommandlet.h
    grep -l "TestEventBus" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/Commandlets/GSDEventTestCommandlet.h
  </verify>
  <done>
    Commandlet header exists with TestDeterminism, TestEventBus, TestScheduling methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Event Test Commandlet</name>
  <files>
    Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Commandlets/GSDEventTestCommandlet.cpp
  </files>
  <action>
    Implement the commandlet with determinism verification, event bus testing, and JSON output.

    1. Create GSDEventTestCommandlet.cpp:

    ```cpp
    #include "Commandlets/GSDEventTestCommandlet.h"
    #include "Subsystems/GSDEventBusSubsystem.h"
    #include "Subsystems/GSDEventSchedulerSubsystem.h"
    #include "Managers/GSDDeterminismManager.h"
    #include "Tags/GSDEventTags.h"
    #include "GSDEventLog.h"

    UGSDEventTestCommandlet::UGSDEventTestCommandlet()
    {
        LogToConsole = true;
    }

    int32 UGSDEventTestCommandlet::Main(const FString& Params)
    {
        GSDEVENT_LOG(Log, TEXT("GSDEventTestCommandlet starting"));

        double StartTime = FPlatformTime::Seconds();

        ParseParameters(Params);

        // Run tests
        bool bDeterminismVerified = TestDeterminism();
        bool bEventBusWorking = TestEventBus();
        bool bSchedulingWorking = TestScheduling();

        bool bSuccess = bDeterminismVerified && bEventBusWorking && bSchedulingWorking;

        double EndTime = FPlatformTime::Seconds();
        float Duration = (float)(EndTime - StartTime);

        // Output results
        if (bOutputJSON)
        {
            OutputJSON(bSuccess, bDeterminismVerified, bEventBusWorking, bSchedulingWorking, Duration);
        }
        else
        {
            OutputText(bSuccess, bDeterminismVerified, bEventBusWorking, bSchedulingWorking);
        }

        return bSuccess ? 0 : 1;
    }

    void UGSDEventTestCommandlet::ParseParameters(const FString& Params)
    {
        TArray<FString> Tokens;
        TArray<FString> Switches;
        ParseCommandLine(*Params, Tokens, Switches);

        for (const FString& Switch : Switches)
        {
            if (Switch.StartsWith(TEXT("seed=")))
            {
                FString SeedValue = Switch.RightChop(5);
                TestSeed = FCString::Atoi(*SeedValue);
            }
            else if (Switch == TEXT("text"))
            {
                bOutputJSON = false;
            }
        }
    }

    bool UGSDEventTestCommandlet::TestDeterminism()
    {
        GSDEVENT_LOG(Log, TEXT("Testing determinism..."));

        // Get game instance (required for subsystems)
        UGameInstance* GameInstance = GetGameInstance();
        if (!GameInstance)
        {
            GSDEVENT_LOG(Error, TEXT("No game instance available"));
            return false;
        }

        UGSDEventSchedulerSubsystem* Scheduler = GameInstance->GetSubsystem<UGSDEventSchedulerSubsystem>();
        if (!Scheduler)
        {
            GSDEVENT_LOG(Error, TEXT("Scheduler subsystem not found"));
            return false;
        }

        // Generate schedule twice with same inputs
        FDateTime TestDate(2025, 1, 15);

        Scheduler->GenerateDailySchedule(TestDate, TestSeed);
        int32 FirstCount = Scheduler->GetScheduledEventCount();

        // Reset and generate again
        Scheduler->GenerateDailySchedule(TestDate, TestSeed);
        int32 SecondCount = Scheduler->GetScheduledEventCount();

        // Same seed should produce same count
        bool bVerified = (FirstCount == SecondCount);

        GSDEVENT_LOG(Log, TEXT("Determinism test: First=%d, Second=%d, Match=%s"),
            FirstCount, SecondCount, bVerified ? TEXT("true") : TEXT("false"));

        return bVerified;
    }

    bool UGSDEventTestCommandlet::TestEventBus()
    {
        GSDEVENT_LOG(Log, TEXT("Testing event bus..."));

        // Create a test world for the event bus
        UWorld* TestWorld = GWorld;
        if (!TestWorld)
        {
            GSDEVENT_LOG(Error, TEXT("No world available"));
            return false;
        }

        UGSDEventBusSubsystem* EventBus = TestWorld->GetSubsystem<UGSDEventBusSubsystem>();
        if (!EventBus)
        {
            GSDEVENT_LOG(Error, TEXT("Event bus subsystem not found"));
            return false;
        }

        // Test subscribe/broadcast
        bool bReceived = false;
        FGameplayTag TestTag = FGameplayTag::RequestGameplayTag(FName("Event.Daily"));

        FGSDEventHandle Handle = EventBus->Subscribe(TestTag,
            FOnGSDEvent::FDelegate::CreateLambda([&bReceived](FGameplayTag Tag, const FVector& Location, float Intensity)
            {
                bReceived = true;
            }));

        // Broadcast test event
        EventBus->BroadcastEvent(TestTag, FVector::ZeroVector, 1.0f);

        // Verify receipt
        bool bWorking = bReceived;

        // Cleanup
        EventBus->Unsubscribe(Handle);

        GSDEVENT_LOG(Log, TEXT("Event bus test: Received=%s"), bWorking ? TEXT("true") : TEXT("false"));

        return bWorking;
    }

    bool UGSDEventTestCommandlet::TestScheduling()
    {
        GSDEVENT_LOG(Log, TEXT("Testing scheduling..."));

        UGameInstance* GameInstance = GetGameInstance();
        if (!GameInstance)
        {
            return false;
        }

        UGSDEventSchedulerSubsystem* Scheduler = GameInstance->GetSubsystem<UGSDEventSchedulerSubsystem>();
        if (!Scheduler)
        {
            return false;
        }

        // Generate schedule
        FDateTime TestDate(2025, 1, 15);
        Scheduler->GenerateDailySchedule(TestDate, TestSeed);

        // Verify events were scheduled
        // Note: Will be 0 until Phase 9 adds concrete events
        int32 Count = Scheduler->GetScheduledEventCount();

        GSDEVENT_LOG(Log, TEXT("Scheduling test: %d events scheduled"), Count);

        // For now, scheduling "works" if it doesn't crash
        // Phase 9 will add actual events to verify
        return true;
    }

    void UGSDEventTestCommandlet::OutputJSON(bool bSuccess, bool bDeterminismVerified, bool bEventBusWorking, bool bSchedulingWorking, float Duration)
    {
        FString JSON = FString::Printf(TEXT(
            "{\n"
            "  \"success\": %s,\n"
            "  \"determinism_verified\": %s,\n"
            "  \"event_bus_working\": %s,\n"
            "  \"scheduling_working\": %s,\n"
            "  \"test_duration_seconds\": %.2f,\n"
            "  \"seed\": %d\n"
            "}\n"
        ),
            bSuccess ? TEXT("true") : TEXT("false"),
            bDeterminismVerified ? TEXT("true") : TEXT("false"),
            bEventBusWorking ? TEXT("true") : TEXT("false"),
            bSchedulingWorking ? TEXT("true") : TEXT("false"),
            Duration,
            TestSeed
        );

        // Output to stdout for CI parsing
        UE_LOG(LogTemp, Display, TEXT("%s"), *JSON);
    }

    void UGSDEventTestCommandlet::OutputText(bool bSuccess, bool bDeterminismVerified, bool bEventBusWorking, bool bSchedulingWorking)
    {
        UE_LOG(LogTemp, Display, TEXT("=== GSDEventTest Results ==="));
        UE_LOG(LogTemp, Display, TEXT("Success: %s"), bSuccess ? TEXT("YES") : TEXT("NO"));
        UE_LOG(LogTemp, Display, TEXT("Determinism: %s"), bDeterminismVerified ? TEXT("PASS") : TEXT("FAIL"));
        UE_LOG(LogTemp, Display, TEXT("Event Bus: %s"), bEventBusWorking ? TEXT("PASS") : TEXT("FAIL"));
        UE_LOG(LogTemp, Display, TEXT("Scheduling: %s"), bSchedulingWorking ? TEXT("PASS") : TEXT("FAIL"));
    }
    ```

    CRITICAL: TestDeterminism verifies same seed produces same results. This is the core guarantee of the event system.
  </action>
  <verify>
    grep -l "TestDeterminism" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Commandlets/GSDEventTestCommandlet.cpp
    grep -l "TestEventBus" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Commandlets/GSDEventTestCommandlet.cpp
    grep -l "OutputJSON" Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/Commandlets/GSDEventTestCommandlet.cpp
  </verify>
  <done>
    Commandlet implementation tests determinism, event bus, and scheduling. Outputs JSON for CI.
  </done>
</task>

</tasks>

<verification>
1. Commandlet compiles without errors
2. TestDeterminism verifies same seed = same schedule
3. TestEventBus verifies subscribe/broadcast works
4. JSON output parseable by CI
5. Exit code 0 on success, 1 on failure
</verification>

<success_criteria>
- UGSDEventTestCommandlet extends UCommandlet
- TestDeterminism verifies reproducible schedules
- TestEventBus verifies subscribe/broadcast
- OutputJSON produces valid JSON for CI parsing
- Exit codes: 0 = success, 1 = failure
</success_criteria>

<output>
After completion, create `.planning/phases/08-event-system-core/08-06-SUMMARY.md`
</output>
