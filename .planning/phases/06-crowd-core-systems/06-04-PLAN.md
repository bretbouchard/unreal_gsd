---
phase: 06-crowd-core-systems
plan: 04
type: execute
wave: 4
depends_on: ["06-03"]
files_modified:
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp
autonomous: true
must_haves:
  truths:
    - "World subsystem provides centralized crowd spawning"
    - "200+ entities can be spawned in a defined area"
    - "Spawned entity handles are tracked for cleanup"
    - "Entity destruction uses Defer() for thread safety"
  artifacts:
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h"
      provides: "Crowd manager world subsystem"
      contains: "UWorldSubsystem"
      min_lines: 60
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp"
      provides: "Spawning implementation"
      contains: "SpawnEntities"
      min_lines: 100
  key_links:
    - from: "GSDCrowdManagerSubsystem"
      to: "UMassEntitySubsystem"
      via: "GetSubsystem"
      pattern: "GetSubsystem.*UMassEntitySubsystem"
    - from: "GSDCrowdManagerSubsystem"
      to: "GSDCrowdEntityConfig"
      via: "SpawnEntities"
      pattern: "LoadObject.*GSDCrowdEntityConfig"
---

<objective>
Create crowd manager subsystem for spawning and tracking entities.

Purpose: Provide centralized spawning and management of crowd entities using the world subsystem pattern established in GSD_Vehicles. This subsystem interfaces with Mass Entity subsystem to spawn 200+ entities and track them for cleanup.

Output: Functional UGSDCrowdManagerSubsystem that can spawn, track, and despawn crowd entities.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-crowd-core-systems/06-RESEARCH.md

# Reference: Vehicle spawner subsystem pattern
@Plugins/GSD_Vehicles/Source/GSD_Vehicles/Public/Subsystems/GSDVehicleSpawnerSubsystem.h
@Plugins/GSD_Vehicles/Source/GSD_Vehicles/Private/Subsystems/GSDVehicleSpawnerSubsystem.cpp

# Entity config from plan 03
@.planning/phases/06-crowd-core-systems/06-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Create crowd manager subsystem</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp
  </files>
  <action>
    Create UGSDCrowdManagerSubsystem following the GSDVehicleSpawnerSubsystem pattern:

    **Header** (GSDCrowdManagerSubsystem.h):
    ```cpp
    #pragma once
    #include "CoreMinimal.h"
    #include "Subsystems/WorldSubsystem.h"
    #include "MassEntitySubsystem.h"
    #include "GSDCrowdManagerSubsystem.generated.h"

    class UGSDCrowdEntityConfig;
    struct FMassEntityHandle;

    /**
     * Delegate for async crowd spawn completion.
     */
    DECLARE_DYNAMIC_DELEGATE_OneParam(FOnCrowdSpawnComplete, int32, NumSpawned);

    /**
     * Delegate for all entities despawned notification.
     */
    DECLARE_DYNAMIC_DELEGATE(FOnAllEntitiesDespawned);

    /**
     * World subsystem for spawning and managing crowd entities.
     *
     * Provides centralized entity spawning from GSDCrowdEntityConfig Data Assets
     * with tracking and cleanup. Uses Mass Entity subsystem for efficient ECS-based crowds.
     *
     * Usage:
     * 1. Get subsystem: GetWorld()->GetSubsystem<UGSDCrowdManagerSubsystem>()
     * 2. Spawn entities: Subsystem->SpawnEntities(200, Location, Radius)
     * 3. Track entities: Subsystem->GetActiveEntityCount()
     * 4. Cleanup: Subsystem->DespawnAllEntities()
     */
    UCLASS()
    class GSD_CROWDS_API UGSDCrowdManagerSubsystem : public UWorldSubsystem
    {
        GENERATED_BODY()

    public:
        //-- Spawning --

        /**
         * Spawn crowd entities in a circular area around a center point.
         *
         * @param Count Number of entities to spawn
         * @param Center World location for spawn area center
         * @param Radius Radius of spawn area (entities randomly placed within)
         * @param EntityConfig Optional entity config (uses default if nullptr)
         * @return Number of entities successfully spawned
         */
        UFUNCTION(BlueprintCallable, Category = "GSD|Crowds")
        int32 SpawnEntities(int32 Count, FVector Center, float Radius, UGSDCrowdEntityConfig* EntityConfig = nullptr);

        /**
         * Spawn entities asynchronously with completion callback.
         *
         * @param Count Number of entities to spawn
         * @param Center World location for spawn area center
         * @param Radius Radius of spawn area
         * @param EntityConfig Optional entity config
         * @param OnComplete Delegate called when spawn completes
         */
        UFUNCTION(BlueprintCallable, Category = "GSD|Crowds")
        void SpawnEntitiesAsync(int32 Count, FVector Center, float Radius, UGSDCrowdEntityConfig* EntityConfig, const FOnCrowdSpawnComplete& OnComplete);

        /**
         * Despawn all tracked entities.
         * Uses Defer() for thread-safe destruction.
         * Broadcasts OnAllEntitiesDespawned when complete.
         */
        UFUNCTION(BlueprintCallable, Category = "GSD|Crowds")
        void DespawnAllEntities();

        //-- Queries --

        /**
         * Get count of active spawned entities.
         *
         * @return Number of tracked entities
         */
        UFUNCTION(BlueprintPure, Category = "GSD|Crowds")
        int32 GetActiveEntityCount() const { return SpawnedEntityHandles.Num(); }

        /**
         * Get delegate for all entities despawned notification.
         */
        FOnAllEntitiesDespawned& GetOnAllEntitiesDespawned() { return AllEntitiesDespawnedDelegate; }

    protected:
        //-- Tracked Entities --
        UPROPERTY()
        TArray<FMassEntityHandle> SpawnedEntityHandles;

        //-- Delegates --
        FOnAllEntitiesDespawned AllEntitiesDespawnedDelegate;

        // ~UWorldSubsystem interface
        virtual bool ShouldCreateSubsystem(UWorld* World) const override;
        // ~End of UWorldSubsystem interface

    private:
        /**
         * Get default entity config asset.
         * Loads from /GSD_Crowds/EntityConfigs/BP_GSDZombieEntityConfig
         *
         * @return Default entity config, or nullptr if not found
         */
        UGSDCrowdEntityConfig* GetDefaultEntityConfig();

        /**
         * Generate random spawn transforms in a circular area.
         *
         * @param Count Number of transforms to generate
         * @param Center Center of spawn area
         * @param Radius Radius of spawn area
         * @return Array of spawn transforms
         */
        TArray<FTransform> GenerateSpawnTransforms(int32 Count, FVector Center, float Radius) const;
    };
    ```

    **Implementation** (GSDCrowdManagerSubsystem.cpp):
    ```cpp
    #include "Subsystems/GSDCrowdManagerSubsystem.h"
    #include "DataAssets/GSDCrowdEntityConfig.h"
    #include "Fragments/GSDZombieStateFragment.h"
    #include "MassCommonFragments.h"
    #include "MassSpawner.h"
    #include "GSDCrowdLog.h"

    bool UGSDCrowdManagerSubsystem::ShouldCreateSubsystem(UWorld* World) const
    {
        // Only create in game worlds (not editor preview worlds)
        return World && (World->IsGameWorld() || World->IsPlayInEditor());
    }

    int32 UGSDCrowdManagerSubsystem::SpawnEntities(int32 Count, FVector Center, float Radius, UGSDCrowdEntityConfig* EntityConfig)
    {
        UWorld* World = GetWorld();
        if (!World)
        {
            UE_LOG(LOG_GSDCROWDS, Error, TEXT("SpawnEntities: No world context"));
            return 0;
        }

        UMassEntitySubsystem* MassSubsystem = World->GetSubsystem<UMassEntitySubsystem>();
        if (!MassSubsystem)
        {
            UE_LOG(LOG_GSDCROWDS, Error, TEXT("SpawnEntities: Mass Entity subsystem not found"));
            return 0;
        }

        // Use provided config or load default
        if (!EntityConfig)
        {
            EntityConfig = GetDefaultEntityConfig();
        }

        if (!EntityConfig)
        {
            UE_LOG(LOG_GSDCROWDS, Error, TEXT("SpawnEntities: No entity config available"));
            return 0;
        }

        // Generate spawn transforms
        TArray<FTransform> SpawnTransforms = GenerateSpawnTransforms(Count, Center, Radius);
        if (SpawnTransforms.Num() == 0)
        {
            UE_LOG(LOG_GSDCROWDS, Warning, TEXT("SpawnEntities: No spawn transforms generated"));
            return 0;
        }

        // Spawn entities using Mass Entity subsystem
        TArray<FMassEntityHandle> NewEntityHandles;
        MassSubsystem->SpawnEntities(EntityConfig, SpawnTransforms, NewEntityHandles);

        // Track spawned entities
        SpawnedEntityHandles.Append(NewEntityHandles);

        UE_LOG(LOG_GSDCROWDS, Log, TEXT("Spawned %d crowd entities at center %s with radius %.1f"),
            NewEntityHandles.Num(), *Center.ToString(), Radius);

        return NewEntityHandles.Num();
    }

    void UGSDCrowdManagerSubsystem::SpawnEntitiesAsync(int32 Count, FVector Center, float Radius, UGSDCrowdEntityConfig* EntityConfig, const FOnCrowdSpawnComplete& OnComplete)
    {
        // For now, spawn synchronously and call delegate
        // TODO: Implement true async spawning with loading screen support
        int32 NumSpawned = SpawnEntities(Count, Center, Radius, EntityConfig);

        if (OnComplete.IsBound())
        {
            OnComplete.Execute(NumSpawned);
        }
    }

    void UGSDCrowdManagerSubsystem::DespawnAllEntities()
    {
        if (SpawnedEntityHandles.Num() == 0)
        {
            UE_LOG(LOG_GSDCROWDS, Log, TEXT("DespawnAllEntities: No entities to despawn"));
            return;
        }

        UWorld* World = GetWorld();
        if (!World)
        {
            return;
        }

        UMassEntitySubsystem* MassSubsystem = World->GetSubsystem<UMassEntitySubsystem>();
        if (!MassSubsystem)
        {
            return;
        }

        // CRITICAL: Use Defer() for thread-safe entity destruction
        // See RESEARCH.md Pitfall 2 for details
        // Direct destruction during processing causes crashes
        MassSubsystem->Defer().DestroyEntities(SpawnedEntityHandles);

        const int32 NumDespawned = SpawnedEntityHandles.Num();
        SpawnedEntityHandles.Empty();

        UE_LOG(LOG_GSDCROWDS, Log, TEXT("Despawned %d crowd entities"), NumDespawned);

        // Broadcast completion
        if (AllEntitiesDespawnedDelegate.IsBound())
        {
            AllEntitiesDespawnedDelegate.Broadcast();
        }
    }

    UGSDCrowdEntityConfig* UGSDCrowdManagerSubsystem::GetDefaultEntityConfig()
    {
        // Load default zombie entity config
        static const FString DefaultConfigPath = TEXT("/GSD_Crowds/EntityConfigs/BP_GSDZombieEntityConfig.BP_GSDZombieEntityConfig");

        UGSDCrowdEntityConfig* Config = LoadObject<UGSDCrowdEntityConfig>(nullptr, *DefaultConfigPath);
        if (!Config)
        {
            UE_LOG(LOG_GSDCROWDS, Warning, TEXT("Default entity config not found at: %s"), *DefaultConfigPath);
        }

        return Config;
    }

    TArray<FTransform> UGSDCrowdManagerSubsystem::GenerateSpawnTransforms(int32 Count, FVector Center, float Radius) const
    {
        TArray<FTransform> Transforms;
        Transforms.Reserve(Count);

        for (int32 i = 0; i < Count; ++i)
        {
            FTransform SpawnTransform;

            // Random position within circular area
            const FVector2D RandomOffset = FMath::RandPointInCircle(Radius);
            const FVector SpawnLocation = Center + FVector(RandomOffset.X, RandomOffset.Y, 0.0f);

            // Random rotation (yaw only for ground-based entities)
            const float RandomYaw = FMath::RandRange(0.0f, 360.0f);
            const FRotator SpawnRotation(0.0f, RandomYaw, 0.0f);

            SpawnTransform.SetLocation(SpawnLocation);
            SpawnTransform.SetRotation(SpawnRotation.Quaternion());
            SpawnTransform.SetScale3D(FVector::OneVector);

            Transforms.Add(SpawnTransform);
        }

        return Transforms;
    }
    ```

    **Key patterns:**
    - World subsystem pattern (same as GSDVehicleSpawnerSubsystem)
    - ShouldCreateSubsystem limits to game worlds (not editor preview)
    - GetDefaultEntityConfig loads blueprint entity config
    - GenerateSpawnTransforms creates random positions in circular area
    - Defer().DestroyEntities() for thread-safe destruction (CRITICAL - see RESEARCH.md Pitfall 2)
    - Delegate for despawn completion notification

    **Thread Safety (CRITICAL from RESEARCH.md Pitfall 2):**
    - NEVER call DestroyEntity() directly during processor execution
    - ALWAYS use Defer().DestroyEntities() to queue destruction
    - Mass Entity processes destruction at safe synchronization points

    **File structure:**
    - Public/Subsystems/GSDCrowdManagerSubsystem.h
    - Private/Subsystems/GSDCrowdManagerSubsystem.cpp
  </action>
  <verify>
    # Subsystem compiles and registers with world
    # SpawnEntities creates entities with Mass Entity subsystem
    # GenerateSpawnTransforms produces valid transforms
    # DespawnAllEntities uses Defer() for safe destruction

    # In editor with entity config created:
    # 1. GetSubsystem<UGSDCrowdManagerSubsystem>() returns valid subsystem
    # 2. SpawnEntities(200, Location, 5000.0f) spawns entities
    # 3. GetActiveEntityCount() returns 200
    # 4. DespawnAllEntities() clears all entities
  </verify>
  <done>
    - UGSDCrowdManagerSubsystem compiles
    - SpawnEntities interfaces with Mass Entity subsystem
    - Entity handles tracked in SpawnedEntityHandles array
    - DespawnAllEntities uses Defer() for thread safety
    - GetDefaultEntityConfig loads blueprint entity config
    - Random spawn positions generated in circular area
  </done>
</task>

</tasks>

<verification>
1. Subsystem compiles and registers with world
2. SpawnEntities creates entities via Mass Entity subsystem
3. Entity handles tracked for cleanup
4. DespawnAllEntities uses Defer() (thread-safe)
5. Default entity config loads successfully
</verification>

<success_criteria>
- UGSDCrowdManagerSubsystem world subsystem created
- Can spawn 200+ entities in circular area
- Entity handles tracked in array
- Thread-safe destruction using Defer()
- Follows established world subsystem pattern from GSD_Vehicles
</success_criteria>

<output>
After completion, create `.planning/phases/06-crowd-core-systems/06-04-SUMMARY.md`
</output>
