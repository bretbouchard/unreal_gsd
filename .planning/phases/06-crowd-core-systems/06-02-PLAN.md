---
phase: 06-crowd-core-systems
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDZombieStateFragment.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Fragments/GSDZombieStateFragment.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDZombieBehaviorProcessor.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDZombieBehaviorProcessor.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDCrowdLODProcessor.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDCrowdLODProcessor.cpp
autonomous: true
must_haves:
  truths:
    - "Mass Entity fragments define zombie state data"
    - "Processors execute logic on entities in parallel"
    - "LOD significance is calculated based on distance from viewer"
    - "Fragment access flags are correctly specified (ReadOnly vs ReadWrite)"
  artifacts:
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDZombieStateFragment.h"
      provides: "Zombie state fragment"
      contains: "FMassFragment"
      min_lines: 30
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDZombieBehaviorProcessor.h"
      provides: "Behavior processor"
      contains: "UMassProcessor"
      min_lines: 40
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDCrowdLODProcessor.h"
      provides: "LOD processor"
      contains: "FMassRepresentationLODFragment"
      min_lines: 40
  key_links:
    - from: "GSDZombieBehaviorProcessor"
      to: "FGSDZombieStateFragment"
      via: "EntityQuery.AddRequirement"
      pattern: "AddRequirement.*FGSDZombieStateFragment"
    - from: "GSDCrowdLODProcessor"
      to: "FMassRepresentationLODFragment"
      via: "EntityQuery.ForEachEntityChunk"
      pattern: "GetMutableFragmentView.*LODFragment"
---

<objective>
Create Mass Entity fragments and processors for zombie crowd simulation.

Purpose: Define the data structures (Fragments) and logic (Processors) that power crowd behavior using Mass Entity's data-oriented design. This enables 200+ entities to be processed efficiently in parallel.

Output: Functional zombie state fragment and processors for behavior and LOD calculations.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-crowd-core-systems/06-RESEARCH.md

# Fragment and Processor patterns from research
@.planning/phases/06-crowd-core-systems/06-RESEARCH.md (Pattern 1: Mass Entity Definition Setup)
@.planning/phases/06-crowd-core-systems/06-RESEARCH.md (Pattern 2: Mass Representation LOD Switching)
</context>

<tasks>

<task type="auto">
  <name>Create zombie state fragment</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDZombieStateFragment.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Fragments/GSDZombieStateFragment.cpp
  </files>
  <action>
    Create FGSDZombieStateFragment as a Mass Entity fragment:

    **Header** (GSDZombieStateFragment.h):
    ```cpp
    #pragma once
    #include "MassEntityTypes.h"
    #include "GSDZombieStateFragment.generated.h"

    /**
     * Fragment containing zombie entity state.
     *
     * CRITICAL: Do NOT store UObject pointers in fragments.
     * Fragments are not UObjects and cannot hold strong references.
     * Use indices or raw data instead.
     */
    USTRUCT()
    struct GSD_CROWDS_API FGSDZombieStateFragment : public FMassFragment
    {
        GENERATED_BODY()

        //-- State --
        UPROPERTY()
        float Health = 100.0f;

        UPROPERTY()
        float MovementSpeed = 150.0f;

        UPROPERTY()
        float TargetMovementSpeed = 150.0f;

        //-- Flags --
        UPROPERTY()
        uint8 bIsAggressive : 1;

        UPROPERTY()
        uint8 bIsAlive : 1;

        UPROPERTY()
        uint8 bIsActive : 1;

        //-- Behavior --
        UPROPERTY()
        float WanderDirection = 0.0f;

        UPROPERTY()
        float TimeSinceLastBehaviorUpdate = 0.0f;

        //-- Constructor --
        FGSDZombieStateFragment()
            : bIsAggressive(false)
            , bIsAlive(true)
            , bIsActive(true)
        {
        }
    };
    ```

    **Implementation** (GSDZombieStateFragment.cpp):
    - Empty implementation file (fragment is header-only)
    - Include the header for completeness

    **Key design decisions:**
    - NO UObject pointers (avoids GC issues - see RESEARCH.md Pitfall 5)
    - Use bitfields for boolean flags (memory efficient)
    - MovementSpeed + TargetMovementSpeed for smooth interpolation
    - TimeSinceLastBehaviorUpdate for throttled updates

    **File location:**
    - Public/Fragments/GSDZombieStateFragment.h
    - Private/Fragments/GSDZombieStateFragment.cpp (empty, just includes)
  </action>
  <verify>
    # Fragment compiles without errors
    # No UObject pointers in struct
    # Inherits from FMassFragment correctly

    # Check for proper USTRUCT macro usage
    # Verify GENERATED_BODY() is present
  </verify>
  <done>
    - FGSDZombieStateFragment compiles
    - No UObject pointer members
    - Inherits from FMassFragment
    - All properties use UPROPERTY() macro
  </done>
</task>

<task type="auto">
  <name>Create zombie behavior processor</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDZombieBehaviorProcessor.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDZombieBehaviorProcessor.cpp
  </files>
  <action>
    Create UGSDZombieBehaviorProcessor for zombie logic:

    **Header** (GSDZombieBehaviorProcessor.h):
    ```cpp
    #pragma once
    #include "MassProcessor.h"
    #include "GSDZombieBehaviorProcessor.generated.h"

    class FGSDZombieStateFragment;
    struct FDataFragment_Transform;

    /**
     * Processor for zombie behavior updates.
     *
     * Updates movement speed, wander behavior, and state.
     * Runs in PrePhysics phase before movement is applied.
     */
    UCLASS()
    class GSD_CROWDS_API UGSDZombieBehaviorProcessor : public UMassProcessor
    {
        GENERATED_BODY()

    public:
        UGSDZombieBehaviorProcessor();

    protected:
        // ~UMassProcessor interface
        virtual void ConfigureQueries() override;
        virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;
        // ~End of UMassProcessor interface

    private:
        FMassEntityQuery EntityQuery;

        //-- Configuration --
        UPROPERTY(EditDefaultsOnly, Category = "Configuration")
        float BehaviorUpdateInterval = 0.5f;

        UPROPERTY(EditDefaultsOnly, Category = "Configuration")
        float SpeedVariation = 0.2f;
    };
    ```

    **Implementation** (GSDZombieBehaviorProcessor.cpp):
    ```cpp
    #include "Processors/GSDZombieBehaviorProcessor.h"
    #include "Fragments/GSDZombieStateFragment.h"
    #include "MassCommonFragments.h"
    #include "GSDCrowdLog.h"

    UGSDZombieBehaviorProcessor::UGSDZombieBehaviorProcessor()
    {
        ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorld;
        ProcessingPhase = EMassProcessingPhase::PrePhysics;
    }

    void UGSDZombieBehaviorProcessor::ConfigureQueries()
    {
        // CRITICAL: Specify correct access flags
        EntityQuery.AddRequirement<FGSDZombieStateFragment>(EMassFragmentAccess::ReadWrite);
        EntityQuery.AddRequirement<FDataFragment_Transform>(EMassFragmentAccess::ReadOnly);
    }

    void UGSDZombieBehaviorProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
    {
        EntityQuery.ForEachEntityChunk(EntityManager, Context,
            [this](FMassExecutionContext& Context)
            {
                const int32 NumEntities = Context.GetNumEntities();
                auto ZombieStates = Context.GetMutableFragmentView<FGSDZombieStateFragment>();
                const auto& Transforms = Context.GetFragmentView<FDataFragment_Transform>();
                const float DeltaTime = Context.GetDeltaTimeSeconds();

                for (int32 i = 0; i < NumEntities; ++i)
                {
                    FGSDZombieStateFragment& State = ZombieStates[i];

                    if (!State.bIsAlive || !State.bIsActive)
                    {
                        continue;
                    }

                    // Update behavior timer
                    State.TimeSinceLastBehaviorUpdate += DeltaTime;

                    if (State.TimeSinceLastBehaviorUpdate >= BehaviorUpdateInterval)
                    {
                        State.TimeSinceLastBehaviorUpdate = 0.0f;

                        // Apply speed variation (prevents synchronized movement)
                        const float SpeedMultiplier = 1.0f + FMath::FRandRange(-SpeedVariation, SpeedVariation);
                        State.TargetMovementSpeed = State.MovementSpeed * SpeedMultiplier;

                        // Update wander direction
                        State.WanderDirection += FMath::FRandRange(-45.0f, 45.0f);
                        State.WanderDirection = FMath::Clamp(State.WanderDirection, -180.0f, 180.0f);
                    }

                    // Smooth speed interpolation
                    State.MovementSpeed = FMath::Lerp(State.MovementSpeed, State.TargetMovementSpeed, DeltaTime * 2.0f);
                }
            });
    }
    ```

    **Key patterns:**
    - ExecutionOrder.ExecuteInGroup ensures proper processor ordering
    - ProcessingPhase::PrePhysics runs before physics simulation
    - ReadWrite access for fragments being modified
    - ReadOnly access for fragments only being read
    - DeltaTime-based updates for frame-rate independence

    **Avoid (from RESEARCH.md Pitfall 3):**
    - Using ReadOnly when you need ReadWrite
    - Using ReadWrite when you only need ReadOnly
  </action>
  <verify>
    # Processor compiles and registers with Mass Entity subsystem
    # ConfigureQueries specifies correct access flags
    # Execute iterates over entity chunks correctly

    # In editor:
    # Processor should appear in Mass Entity processor list
    # No errors when entity subsystem initializes
  </verify>
  <done>
    - UGSDZombieBehaviorProcessor compiles
    - ConfigureQueries sets correct fragment access flags
    - Execute processes entities in chunks
    - Processor registered in SyncWorld group
    - Speed variation prevents synchronized movement
  </done>
</task>

<task type="auto">
  <name>Create LOD processor</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDCrowdLODProcessor.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDCrowdLODProcessor.cpp
  </files>
  <action>
    Create UGSDCrowdLODProcessor for distance-based LOD calculations:

    **Header** (GSDCrowdLODProcessor.h):
    ```cpp
    #pragma once
    #include "MassProcessor.h"
    #include "GSDCrowdLODProcessor.generated.h"

    struct FMassRepresentationLODFragment;
    struct FDataFragment_Transform;

    /**
     * Processor for calculating LOD significance based on viewer distance.
     *
     * LOD Significance values:
     * - 0.0 - 0.5: High Actor (full detail)
     * - 0.5 - 1.5: Low Actor (simplified)
     * - 1.5 - 2.5: ISM (instanced mesh)
     * - 2.5 - 3.0: Culled (invisible)
     */
    UCLASS()
    class GSD_CROWDS_API UGSDCrowdLODProcessor : public UMassProcessor
    {
        GENERATED_BODY()

    public:
        UGSDCrowdLODProcessor();

    protected:
        // ~UMassProcessor interface
        virtual void ConfigureQueries() override;
        virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;
        // ~End of UMassProcessor interface

    private:
        FMassEntityQuery EntityQuery;

        //-- LOD Distance Thresholds --
        UPROPERTY(EditDefaultsOnly, Category = "LOD Configuration")
        float HighActorDistance = 2000.0f;

        UPROPERTY(EditDefaultsOnly, Category = "LOD Configuration")
        float LowActorDistance = 5000.0f;

        UPROPERTY(EditDefaultsOnly, Category = "LOD Configuration")
        float ISMDistance = 10000.0f;

        UPROPERTY(EditDefaultsOnly, Category = "LOD Configuration")
        float CullDistance = 20000.0f;

        /**
         * Calculate LOD significance from distance.
         * Returns value 0.0-3.0 based on LOD thresholds.
         */
        float CalculateLODSignificance(float Distance) const;

        /**
         * Get viewer location (player camera).
         * Returns world location of primary player camera.
         */
        FVector GetViewerLocation(FMassExecutionContext& Context) const;
    };
    ```

    **Implementation** (GSDCrowdLODProcessor.cpp):
    ```cpp
    #include "Processors/GSDCrowdLODProcessor.h"
    #include "MassRepresentationFragments.h"
    #include "MassCommonFragments.h"
    #include "GameFramework/PlayerController.h"
    #include "Camera/PlayerCameraManager.h"
    #include "GSDCrowdLog.h"

    UGSDCrowdLODProcessor::UGSDCrowdLODProcessor()
    {
        ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorld);
        ProcessingPhase = EMassProcessingPhase::PrePhysics;
    }

    void UGSDCrowdLODProcessor::ConfigureQueries()
    {
        EntityQuery.AddRequirement<FMassRepresentationLODFragment>(EMassFragmentAccess::ReadWrite);
        EntityQuery.AddRequirement<FDataFragment_Transform>(EMassFragmentAccess::ReadOnly);
    }

    void UGSDCrowdLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
    {
        const FVector ViewerLocation = GetViewerLocation(Context);

        EntityQuery.ForEachEntityChunk(EntityManager, Context,
            [&](FMassExecutionContext& Context)
            {
                auto LODFragments = Context.GetMutableFragmentView<FMassRepresentationLODFragment>();
                const auto& Transforms = Context.GetFragmentView<FDataFragment_Transform>();

                for (int32 i = 0; i < Context.GetNumEntities(); ++i)
                {
                    const FVector EntityLocation = Transforms[i].GetTransform().GetLocation();
                    const float Distance = FVector::Dist(EntityLocation, ViewerLocation);
                    LODFragments[i].LODSignificance = CalculateLODSignificance(Distance);
                }
            });
    }

    float UGSDCrowdLODProcessor::CalculateLODSignificance(float Distance) const
    {
        // Map distance to LOD significance (0.0 = close, 3.0 = far)
        if (Distance < HighActorDistance) return 0.0f;      // High Actor
        if (Distance < LowActorDistance) return 0.75f;      // Low Actor
        if (Distance < ISMDistance) return 1.75f;           // ISM
        if (Distance < CullDistance) return 2.5f;           // Culled
        return 3.0f;                                        // Far culled
    }

    FVector UGSDCrowdLODProcessor::GetViewerLocation(FMassExecutionContext& Context) const
    {
        if (UWorld* World = Context.GetWorld())
        {
            if (APlayerController* PC = World->GetFirstPlayerController())
            {
                if (APlayerCameraManager* CameraManager = PC->PlayerCameraManager)
                {
                    return CameraManager->GetCameraLocation();
                }
            }
        }
        return FVector::ZeroVector;
    }
    ```

    **LOD Threshold Rationale:**
    - 2000 units (High Actor): ~20 meters - close interaction range
    - 5000 units (Low Actor): ~50 meters - medium distance
    - 10000 units (ISM): ~100 meters - far distance, instanced rendering
    - 20000 units (Culled): ~200 meters - very far, invisible

    **Key patterns:**
    - ExecuteAfter SyncWorld ensures transforms are updated
    - GetViewerLocation gets player camera position
    - Distance-based LOD significance calculation
    - Mass Representation subsystem uses LODSignificance for switching
  </action>
  <verify>
    # Processor compiles and registers
    # LOD significance values are in 0.0-3.0 range
    # Viewer location retrieval works (returns camera position)

    # In editor with entities spawned:
    # LOD should switch based on camera distance
    # No crashes when player camera is not available
  </verify>
  <done>
    - UGSDCrowdLODProcessor compiles
    - LOD significance calculated from viewer distance
    - 4 LOD levels: High Actor, Low Actor, ISM, Culled
    - Processor runs after SyncWorld group
    - Safe handling when no player camera exists
  </done>
</task>

</tasks>

<verification>
1. All fragments and processors compile
2. Fragment access flags are correct (ReadOnly vs ReadWrite)
3. Processors register with Mass Entity subsystem
4. LOD significance values in expected range (0.0-3.0)
5. Behavior processor applies speed variation
</verification>

<success_criteria>
- FGSDZombieStateFragment defines zombie state without UObject pointers
- UGSDZombieBehaviorProcessor updates behavior with proper execution order
- UGSDCrowdLODProcessor calculates LOD based on viewer distance
- All processors use correct fragment access flags
- Speed variation prevents synchronized movement
</success_criteria>

<output>
After completion, create `.planning/phases/06-crowd-core-systems/06-02-SUMMARY.md`
</output>
