---
phase: 07-crowd-ai-navigation
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDNavigationProcessor.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/DataAssets/GSDCrowdEntityConfig.h
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Entities move along ZoneGraph lanes"
    - "Entities find nearest lane when not on one"
    - "Entities have fallback movement when ZoneGraph unavailable"
  artifacts:
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDNavigationProcessor.h"
      provides: "ZoneGraph lane following processor"
      exports: ["UGSDNavigationProcessor"]
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp"
      provides: "Lane movement implementation"
      contains: "ZoneGraphSubsystem"
  key_links:
    - from: "GSDNavigationProcessor"
      to: "UZoneGraphSubsystem"
      via: "GetSubsystem<UZoneGraphSubsystem>()"
      pattern: "ZoneGraphSubsystem"
    - from: "GSDNavigationProcessor"
      to: "FGSDNavigationFragment"
      via: "ReadWrite access"
      pattern: "FGSDNavigationFragment"
---

<objective>
Create navigation processor that moves entities along ZoneGraph lanes with fallback to direct movement when ZoneGraph is unavailable.

Purpose: Implement the core navigation logic for crowd entities. The processor queries ZoneGraphSubsystem for lane data, updates entity positions along lanes, and gracefully falls back to direct movement if ZoneGraph is unavailable (experimental status handling).

Output: UGSDNavigationProcessor that handles lane finding, lane following, and fallback movement.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-crowd-ai-navigation/07-RESEARCH.md
@.planning/phases/06-crowd-core-systems/06-02-SUMMARY.md

# Existing processor pattern from Phase 6
@Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDZombieBehaviorProcessor.h

# Navigation fragment from Plan 01
@Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDNavigationFragment.h

# Research patterns
See RESEARCH.md Pattern 2 for ZoneGraph navigation implementation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Navigation Processor Header</name>
  <files>Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDNavigationProcessor.h</files>
  <action>
Create UGSDNavigationProcessor header following Phase 6 processor pattern (GSDZombieBehaviorProcessor).

```cpp
#pragma once

#include "CoreMinimal.h"
#include "MassEntity/Processors/MassProcessor.h"
#include "MassEntity/Types/MassEntityTypes.h"
#include "GSDNavigationProcessor.generated.h"

class UZoneGraphSubsystem;
struct FGSDNavigationFragment;
struct FGSDZombieStateFragment;
struct FDataFragment_Transform;

/**
 * Navigation processor for ZoneGraph-based crowd movement.
 * Moves entities along ZoneGraph lanes with fallback to direct movement.
 */
UCLASS()
class GSD_CROWDS_API UGSDNavigationProcessor : public UMassProcessor
{
    GENERATED_BODY()

public:
    UGSDNavigationProcessor();

    virtual void ConfigureQueries() override;
    virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

protected:
    //-- Helper Methods --

    /** Find nearest lane to entity and bind to it */
    void FindNearestLane(
        FGSDNavigationFragment& Nav,
        const FDataFragment_Transform& Transform,
        const UZoneGraphSubsystem* ZoneGraphSubsystem) const;

    /** Update entity transform from current lane position */
    void UpdateTransformFromLane(
        FGSDNavigationFragment& Nav,
        FDataFragment_Transform& Transform,
        const UZoneGraphSubsystem* ZoneGraphSubsystem) const;

    /** Check if entity reached end of lane, transition to next if available */
    void CheckLaneProgress(
        FGSDNavigationFragment& Nav,
        const UZoneGraphSubsystem* ZoneGraphSubsystem) const;

    /** Fallback movement when ZoneGraph unavailable */
    void ExecuteFallbackMovement(
        FGSDNavigationFragment& Nav,
        FDataFragment_Transform& Transform,
        const FGSDZombieStateFragment& Zombie,
        float DeltaTime) const;

    /** Pick a random nearby lane for wandering */
    FZoneGraphLaneHandle PickRandomNearbyLane(
        const FVector& Location,
        const UZoneGraphSubsystem* ZoneGraphSubsystem) const;

private:
    FMassEntityQuery EntityQuery;

    //-- Configuration --
    UPROPERTY(EditDefaultsOnly, Category = "Configuration")
    float LaneSearchRadius = 2000.0f;

    UPROPERTY(EditDefaultsOnly, Category = "Configuration")
    float FallbackMoveSpeed = 100.0f;
};
```

Key design decisions:
1. Execution in Movement group after SyncWorld
2. ReadWrite access to NavigationFragment and Transform
3. ReadOnly access to ZombieStateFragment (for speed)
4. Helper methods for lane finding, transform update, progress check
5. Fallback movement for ZoneGraph unavailability
</action>
  <verify>
test -f Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDNavigationProcessor.h && \
grep -q "UGSDNavigationProcessor" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDNavigationProcessor.h && \
grep -q "UZoneGraphSubsystem" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDNavigationProcessor.h && \
echo "Navigation processor header created"
  </verify>
  <done>UGSDNavigationProcessor class defined with Execute(), ConfigureQueries(), and helper methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement Navigation Processor</name>
  <files>Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp</files>
  <action>
Implement GSDNavigationProcessor.cpp with ZoneGraph lane following logic.

```cpp
#include "Processors/GSDNavigationProcessor.h"
#include "Fragments/GSDNavigationFragment.h"
#include "Fragments/GSDZombieStateFragment.h"
#include "MassEntity/DataFragmentTypes.h"
#include "MassRepresentation/RepresentationFragment.h"
#include "ZoneGraph/ZoneGraphSubsystem.h"
#include "ZoneGraph/ZoneGraphTypes.h"

UGSDNavigationProcessor::UGSDNavigationProcessor()
{
    ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Movement;
    ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorld);
    ProcessingPhase = EMassProcessingPhase::PrePhysics;
}

void UGSDNavigationProcessor::ConfigureQueries()
{
    EntityQuery.AddRequirement<FGSDNavigationFragment>(EMassFragmentAccess::ReadWrite);
    EntityQuery.AddRequirement<FDataFragment_Transform>(EMassFragmentAccess::ReadWrite);
    EntityQuery.AddRequirement<FGSDZombieStateFragment>(EMassFragmentAccess::ReadOnly);
}

void UGSDNavigationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
    const UWorld* World = GetWorld();
    if (!World)
    {
        return;
    }

    const UZoneGraphSubsystem* ZoneGraphSubsystem = World->GetSubsystem<UZoneGraphSubsystem>();
    const bool bZoneGraphAvailable = ZoneGraphSubsystem && ZoneGraphSubsystem->GetNumLanes() > 0;
    const float DeltaTime = Context.GetDeltaTimeSeconds();

    EntityQuery.ForEachEntityChunk(EntityManager, Context,
        [this, ZoneGraphSubsystem, bZoneGraphAvailable, DeltaTime](FMassExecutionContext& Context)
        {
            auto NavFragments = Context.GetMutableFragmentView<FGSDNavigationFragment>();
            auto Transforms = Context.GetMutableFragmentView<FDataFragment_Transform>();
            const auto ZombieStates = Context.GetFragmentView<FGSDZombieStateFragment>();

            for (int32 i = 0; i < Context.GetNumEntities(); ++i)
            {
                FGSDNavigationFragment& Nav = NavFragments[i];
                FDataFragment_Transform& Transform = Transforms[i];
                const FGSDZombieStateFragment& Zombie = ZombieStates[i];

                // Check if ZoneGraph is available
                if (!bZoneGraphAvailable)
                {
                    Nav.bUseFallbackMovement = true;
                    ExecuteFallbackMovement(Nav, Transform, Zombie, DeltaTime);
                    continue;
                }

                // Not on a lane yet - find one
                if (!Nav.bIsOnLane || !Nav.CurrentLane.IsValid())
                {
                    FindNearestLane(Nav, Transform, ZoneGraphSubsystem);
                    if (!Nav.bIsOnLane)
                    {
                        // Still no lane, use fallback
                        Nav.bUseFallbackMovement = true;
                        ExecuteFallbackMovement(Nav, Transform, Zombie, DeltaTime);
                        continue;
                    }
                }

                // Move along lane
                Nav.bUseFallbackMovement = false;
                const float MoveSpeed = Zombie.MovementSpeed;
                Nav.LanePosition += MoveSpeed * DeltaTime;

                // Update transform from lane position
                UpdateTransformFromLane(Nav, Transform, ZoneGraphSubsystem);

                // Check if reached end of lane
                CheckLaneProgress(Nav, ZoneGraphSubsystem);
            }
        });
}

void UGSDNavigationProcessor::FindNearestLane(
    FGSDNavigationFragment& Nav,
    const FDataFragment_Transform& Transform,
    const UZoneGraphSubsystem* ZoneGraphSubsystem) const
{
    if (!ZoneGraphSubsystem)
    {
        return;
    }

    const FVector Location = Transform.GetTransform().GetLocation();

    // Query lanes in bounds
    TArray<FZoneGraphLaneHandle> NearbyLanes;
    ZoneGraphSubsystem->FindLanesInBounds(
        FBoxCenterAndExtent(Location, FVector(LaneSearchRadius)),
        NearbyLanes
    );

    if (NearbyLanes.IsEmpty())
    {
        Nav.bIsOnLane = false;
        return;
    }

    // Pick nearest lane (or random for variety)
    Nav.CurrentLane = NearbyLanes[FMath::RandHelper(NearbyLanes.Num())];
    Nav.LanePosition = 0.0f;
    Nav.bIsOnLane = true;
    Nav.bReachedDestination = false;
}

void UGSDNavigationProcessor::UpdateTransformFromLane(
    FGSDNavigationFragment& Nav,
    FDataFragment_Transform& Transform,
    const UZoneGraphSubsystem* ZoneGraphSubsystem) const
{
    if (!Nav.CurrentLane.IsValid() || !ZoneGraphSubsystem)
    {
        return;
    }

    FZoneGraphLaneLocation LaneLocation;
    if (ZoneGraphSubsystem->GetLaneLocation(Nav.CurrentLane, Nav.LanePosition, LaneLocation))
    {
        FTransform NewTransform = Transform.GetTransform();
        NewTransform.SetLocation(LaneLocation.Position);
        NewTransform.SetRotation(LaneLocation.Direction.ToOrientationQuat());
        Transform.SetTransform(NewTransform);
    }
}

void UGSDNavigationProcessor::CheckLaneProgress(
    FGSDNavigationFragment& Nav,
    const UZoneGraphSubsystem* ZoneGraphSubsystem) const
{
    if (!Nav.CurrentLane.IsValid() || !ZoneGraphSubsystem)
    {
        return;
    }

    // Get lane length
    const FZoneGraphLaneHandle& Lane = Nav.CurrentLane;
    const float LaneLength = ZoneGraphSubsystem->GetLaneLength(Lane);

    if (Nav.LanePosition >= LaneLength)
    {
        Nav.bReachedDestination = true;

        // Try to find a connected lane or pick a new random one
        Nav.CurrentLane = PickRandomNearbyLane(
            FVector::ZeroVector, // Will use entity's current location
            ZoneGraphSubsystem
        );

        if (Nav.CurrentLane.IsValid())
        {
            Nav.LanePosition = 0.0f;
            Nav.bReachedDestination = false;
        }
        else
        {
            Nav.bIsOnLane = false;
        }
    }
}

void UGSDNavigationProcessor::ExecuteFallbackMovement(
    FGSDNavigationFragment& Nav,
    FDataFragment_Transform& Transform,
    const FGSDZombieStateFragment& Zombie,
    float DeltaTime) const
{
    // Simple direct movement when ZoneGraph unavailable
    FTransform CurrentTransform = Transform.GetTransform();
    FVector Location = CurrentTransform.GetLocation();

    // Move in a random direction if no target
    if (Nav.FallbackTargetLocation.IsNearlyZero())
    {
        const float RandomAngle = FMath::FRand() * 2.0f * PI;
        Nav.FallbackTargetLocation = Location + FVector(
            FMath::Cos(RandomAngle) * 500.0f,
            FMath::Sin(RandomAngle) * 500.0f,
            0.0f
        );
    }

    // Move toward target
    const FVector Direction = (Nav.FallbackTargetLocation - Location).GetSafeNormal();
    const float MoveSpeed = Zombie.MovementSpeed * FallbackMoveSpeed / 100.0f;
    Location += Direction * MoveSpeed * DeltaTime;

    // Update transform
    CurrentTransform.SetLocation(Location);
    if (!Direction.IsNearlyZero())
    {
        CurrentTransform.SetRotation(Direction.ToOrientationQuat());
    }
    Transform.SetTransform(CurrentTransform);

    // Check if reached target
    if (FVector::DistSquared(Location, Nav.FallbackTargetLocation) < 100.0f)
    {
        Nav.FallbackTargetLocation = FVector::ZeroVector;
    }
}

FZoneGraphLaneHandle UGSDNavigationProcessor::PickRandomNearbyLane(
    const FVector& Location,
    const UZoneGraphSubsystem* ZoneGraphSubsystem) const
{
    if (!ZoneGraphSubsystem)
    {
        return FZoneGraphLaneHandle();
    }

    TArray<FZoneGraphLaneHandle> NearbyLanes;
    ZoneGraphSubsystem->FindLanesInBounds(
        FBoxCenterAndExtent(Location, FVector(LaneSearchRadius)),
        NearbyLanes
    );

    if (NearbyLanes.IsEmpty())
    {
        return FZoneGraphLaneHandle();
    }

    return NearbyLanes[FMath::RandHelper(NearbyLanes.Num())];
}
```

Key implementation details:
1. Check ZoneGraph availability before use (experimental status handling)
2. Fallback movement when ZoneGraph unavailable
3. Lane finding with search radius
4. Transform update from lane position
5. Lane progress checking and transition
</action>
  <verify>
test -f Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp && \
grep -q "ZoneGraphSubsystem" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp && \
grep -q "ExecuteFallbackMovement" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp && \
echo "Navigation processor implemented"
  </verify>
  <done>UGSDNavigationProcessor moves entities along ZoneGraph lanes with fallback to direct movement</done>
</task>

<task type="auto">
  <name>Task 3: Add Navigation Fragment to Entity Config</name>
  <files>Plugins/GSD_Crowds/Source/GSD_Crowds/Public/DataAssets/GSDCrowdEntityConfig.h</files>
  <action>
Update GSDCrowdEntityConfig to include navigation configuration.

Add to the header (after existing fields):
```cpp
    //-- Navigation Configuration (Phase 7) --
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Navigation")
    bool bEnableNavigation = true;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Navigation")
    float DefaultMoveSpeed = 150.0f;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Navigation")
    float LaneSearchRadius = 2000.0f;
```

These fields allow per-config navigation tuning. The processor will read these values when spawning entities.
</action>
  <verify>
grep -q "bEnableNavigation" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/DataAssets/GSDCrowdEntityConfig.h && \
grep -q "DefaultMoveSpeed" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/DataAssets/GSDCrowdEntityConfig.h && \
echo "Entity config updated with navigation fields"
  </verify>
  <done>GSDCrowdEntityConfig has navigation configuration fields (bEnableNavigation, DefaultMoveSpeed, LaneSearchRadius)</done>
</task>

</tasks>

<verification>
1. Navigation processor header exists with proper structure
2. Implementation includes ZoneGraphSubsystem queries
3. Fallback movement implemented for ZoneGraph unavailability
4. Lane finding, transform update, progress check helpers exist
5. Entity config has navigation fields
</verification>

<success_criteria>
- UGSDNavigationProcessor compiles and follows Phase 6 processor patterns
- Processor queries ZoneGraphSubsystem for lane data
- Fallback movement works when ZoneGraph unavailable
- Entity config has navigation configuration options
- Processor execution order correct (Movement group after SyncWorld)
</success_criteria>

<output>
After completion, create `.planning/phases/07-crowd-ai-navigation/07-02-SUMMARY.md`
</output>
