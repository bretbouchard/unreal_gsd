---
phase: 07-crowd-ai-navigation
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDSmartObjectFragment.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Fragments/GSDSmartObjectFragment.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDSmartObjectSubsystem.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDSmartObjectProcessor.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDSmartObjectProcessor.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Smart Object fragment stores interaction state"
    - "Smart Object subsystem queries and claims objects"
    - "Smart Object processor handles claiming and releasing"
  artifacts:
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDSmartObjectFragment.h"
      provides: "Smart Object interaction state"
      exports: ["FGSDSmartObjectFragment"]
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDSmartObjectSubsystem.h"
      provides: "Smart Object query and claim wrapper"
      exports: ["UGSDSmartObjectSubsystem"]
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDSmartObjectProcessor.h"
      provides: "Smart Object interaction processor"
      exports: ["UGSDSmartObjectProcessor"]
  key_links:
    - from: "GSDSmartObjectSubsystem"
      to: "USmartObjectSubsystem"
      via: "GetSubsystem<USmartObjectSubsystem>()"
      pattern: "SmartObjectSubsystem"
    - from: "GSDSmartObjectProcessor"
      to: "FSmartObjectClaimHandle"
      via: "Claim/Release"
      pattern: "ClaimHandle"
---

<objective>
Create Smart Object system (fragment, subsystem, processor) for world interaction points like cover, ambush, and wander points.

Purpose: Enable crowd entities to interact with Smart Objects in the world. The fragment stores interaction state, the subsystem wraps USmartObjectSubsystem for queries and claims, and the processor handles the claim/interact/release lifecycle.

Output: FGSDSmartObjectFragment, UGSDSmartObjectSubsystem, UGSDSmartObjectProcessor for Smart Object interactions.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-crowd-ai-navigation/07-RESEARCH.md
@.planning/phases/06-crowd-core-systems/06-02-SUMMARY.md

# Existing subsystem pattern from Phase 6
@Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h

# Research patterns
See RESEARCH.md Pattern 3 for Smart Object implementation
See RESEARCH.md Pitfall 2 for claim race conditions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Smart Object Fragment</name>
  <files>
Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDSmartObjectFragment.h
Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Fragments/GSDSmartObjectFragment.cpp
  </files>
  <action>
Create FGSDSmartObjectFragment following Phase 6 fragment pattern.

Header (Public/Fragments/GSDSmartObjectFragment.h):
```cpp
#pragma once

#include "CoreMinimal.h"
#include "MassEntity/Types/MassEntityTypes.h"
#include "SmartObjectsModule/SmartObjectTypes.h"
#include "GSDSmartObjectFragment.generated.h"

/**
 * Smart Object fragment for interaction state.
 * Stores claim handle and interaction progress.
 */
USTRUCT()
struct GSD_CROWDS_API FGSDSmartObjectFragment : public FMassFragment
{
    GENERATED_BODY()

    //-- Current Interaction --
    UPROPERTY()
    FSmartObjectClaimHandle ClaimedHandle;

    UPROPERTY()
    float InteractionTime = 0.0f;

    UPROPERTY()
    float InteractionDuration = 3.0f;  // Default 3 seconds

    //-- State --
    UPROPERTY()
    uint8 bIsInteracting : 1;

    UPROPERTY()
    uint8 bHasClaimedObject : 1;

    UPROPERTY()
    uint8 bInteractionComplete : 1;

    //-- Search Config --
    UPROPERTY()
    float SearchRadius = 1000.0f;

    UPROPERTY()
    float SearchCooldown = 5.0f;

    UPROPERTY()
    float TimeSinceLastSearch = 0.0f;

    FGSDSmartObjectFragment()
        : bIsInteracting(false)
        , bHasClaimedObject(false)
        , bInteractionComplete(false)
    {}

    bool HasValidClaim() const
    {
        return bHasClaimedObject && ClaimedHandle.IsValid();
    }
};
```

Implementation (Private/Fragments/GSDSmartObjectFragment.cpp):
```cpp
#include "Fragments/GSDSmartObjectFragment.h"
// Header-only struct - no implementation needed
```

Key design:
1. FSmartObjectClaimHandle for thread-safe claiming
2. Interaction duration for timed interactions
3. Search cooldown to prevent constant queries
4. HasValidClaim() helper for safety checks
</action>
  <verify>
test -f Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDSmartObjectFragment.h && \
grep -q "FSmartObjectClaimHandle" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDSmartObjectFragment.h && \
grep -q "HasValidClaim" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDSmartObjectFragment.h && \
echo "Smart Object fragment created"
  </verify>
  <done>FGSDSmartObjectFragment stores claim handle, interaction time, and search config</done>
</task>

<task type="auto">
  <name>Task 2: Create Smart Object Subsystem</name>
  <files>
Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDSmartObjectSubsystem.h
Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp
  </files>
  <action>
Create UGSDSmartObjectSubsystem as a wrapper around USmartObjectSubsystem.

Header (Public/Subsystems/GSDSmartObjectSubsystem.h):
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "SmartObjectsModule/SmartObjectTypes.h"
#include "GSDSmartObjectSubsystem.generated.h"

class USmartObjectSubsystem;

/**
 * World subsystem for Smart Object queries and claiming.
 * Wraps USmartObjectSubsystem for GSD-specific usage.
 */
UCLASS()
class GSD_CROWDS_API UGSDSmartObjectSubsystem : public UWorldSubsystem
{
    GENERATED_BODY()

public:
    virtual bool ShouldCreateSubsystem(UObject* Outer) const override;
    virtual void Initialize(FSubsystemCollectionBase& Collection) override;
    virtual void Deinitialize() override;

    //-- Query Operations --

    /** Find Smart Objects near a location */
    UFUNCTION(BlueprintCallable, Category = "GSD|SmartObjects")
    TArray<FSmartObjectHandle> FindNearbySmartObjects(
        const FVector& Location,
        float Radius,
        const FGameplayTagContainer& FilterTags = FGameplayTagContainer()) const;

    /** Find the nearest available Smart Object */
    FSmartObjectHandle FindNearestAvailableSmartObject(
        const FVector& Location,
        float Radius) const;

    //-- Claim Operations --

    /** Claim a Smart Object (thread-safe) */
    FSmartObjectClaimHandle ClaimSmartObject(FSmartObjectHandle Handle);

    /** Release a claimed Smart Object */
    void ReleaseSmartObject(FSmartObjectClaimHandle& Handle);

    /** Check if a Smart Object is available */
    bool IsSmartObjectAvailable(FSmartObjectHandle Handle) const;

    //-- Location Operations --

    /** Get world location of a Smart Object */
    FVector GetSmartObjectLocation(FSmartObjectHandle Handle) const;

protected:
    //-- Cached Subsystem --
    UPROPERTY()
    TObjectPtr<USmartObjectSubsystem> CachedSmartObjectSubsystem;
};
```

Implementation (Private/Subsystems/GSDSmartObjectSubsystem.cpp):
```cpp
#include "Subsystems/GSDSmartObjectSubsystem.h"
#include "SmartObjectsModule/SmartObjectSubsystem.h"

bool UGSDSmartObjectSubsystem::ShouldCreateSubsystem(UObject* Outer) const
{
    return true;
}

void UGSDSmartObjectSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);
    CachedSmartObjectSubsystem = GetWorld()->GetSubsystem<USmartObjectSubsystem>();
}

void UGSDSmartObjectSubsystem::Deinitialize()
{
    CachedSmartObjectSubsystem = nullptr;
    Super::Deinitialize();
}

TArray<FSmartObjectHandle> UGSDSmartObjectSubsystem::FindNearbySmartObjects(
    const FVector& Location,
    float Radius,
    const FGameplayTagContainer& FilterTags) const
{
    if (!CachedSmartObjectSubsystem)
    {
        return {};
    }

    FSmartObjectRequest Request;
    Request.QueryBox = FBoxCenterAndExtent(Location, FVector(Radius));
    Request.Filter = FSmartObjectRequestFilter(FilterTags);

    TArray<FSmartObjectHandle> Results;
    CachedSmartObjectSubsystem->FindSmartObjects(Request, Results);
    return Results;
}

FSmartObjectHandle UGSDSmartObjectSubsystem::FindNearestAvailableSmartObject(
    const FVector& Location,
    float Radius) const
{
    TArray<FSmartObjectHandle> NearbyObjects = FindNearbySmartObjects(Location, Radius);

    if (NearbyObjects.IsEmpty())
    {
        return FSmartObjectHandle();
    }

    // Find nearest available
    FSmartObjectHandle NearestHandle;
    float NearestDistSq = MAX_FLT;

    for (const FSmartObjectHandle& Handle : NearbyObjects)
    {
        if (!IsSmartObjectAvailable(Handle))
        {
            continue;
        }

        const FVector ObjectLocation = GetSmartObjectLocation(Handle);
        const float DistSq = FVector::DistSquared(Location, ObjectLocation);

        if (DistSq < NearestDistSq)
        {
            NearestDistSq = DistSq;
            NearestHandle = Handle;
        }
    }

    return NearestHandle;
}

FSmartObjectClaimHandle UGSDSmartObjectSubsystem::ClaimSmartObject(FSmartObjectHandle Handle)
{
    if (!CachedSmartObjectSubsystem || !Handle.IsValid())
    {
        return FSmartObjectClaimHandle::Invalid;
    }

    return CachedSmartObjectSubsystem->Claim(Handle);
}

void UGSDSmartObjectSubsystem::ReleaseSmartObject(FSmartObjectClaimHandle& Handle)
{
    if (CachedSmartObjectSubsystem && Handle.IsValid())
    {
        CachedSmartObjectSubsystem->Release(Handle);
        Handle = FSmartObjectClaimHandle::Invalid;
    }
}

bool UGSDSmartObjectSubsystem::IsSmartObjectAvailable(FSmartObjectHandle Handle) const
{
    if (!CachedSmartObjectSubsystem || !Handle.IsValid())
    {
        return false;
    }

    // Check if Smart Object can be claimed
    FSmartObjectClaimHandle TestHandle = CachedSmartObjectSubsystem->Claim(Handle);
    if (TestHandle.IsValid())
    {
        CachedSmartObjectSubsystem->Release(TestHandle);
        return true;
    }

    return false;
}

FVector UGSDSmartObjectSubsystem::GetSmartObjectLocation(FSmartObjectHandle Handle) const
{
    if (!CachedSmartObjectSubsystem || !Handle.IsValid())
    {
        return FVector::ZeroVector;
    }

    // Get transform from Smart Object subsystem
    FTransform SOTransform;
    if (CachedSmartObjectSubsystem->GetSmartObjectTransform(Handle, SOTransform))
    {
        return SOTransform.GetLocation();
    }

    return FVector::ZeroVector;
}
```
</action>
  <verify>
test -f Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDSmartObjectSubsystem.h && \
test -f Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp && \
grep -q "ClaimSmartObject" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDSmartObjectSubsystem.h && \
grep -q "ReleaseSmartObject" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDSmartObjectSubsystem.h && \
echo "Smart Object subsystem created"
  </verify>
  <done>UGSDSmartObjectSubsystem wraps USmartObjectSubsystem with FindNearby, Claim, and Release operations</done>
</task>

<task type="auto">
  <name>Task 3: Create Smart Object Processor</name>
  <files>
Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDSmartObjectProcessor.h
Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDSmartObjectProcessor.cpp
  </files>
  <action>
Create UGSDSmartObjectProcessor for Smart Object interaction lifecycle.

Header (Public/Processors/GSDSmartObjectProcessor.h):
```cpp
#pragma once

#include "CoreMinimal.h"
#include "MassEntity/Processors/MassProcessor.h"
#include "GSDSmartObjectProcessor.generated.h"

struct FGSDSmartObjectFragment;
struct FGSDNavigationFragment;
struct FDataFragment_Transform;
class UGSDSmartObjectSubsystem;

/**
 * Processor for Smart Object interactions.
 * Handles search, claim, interact, release lifecycle.
 */
UCLASS()
class GSD_CROWDS_API UGSDSmartObjectProcessor : public UMassProcessor
{
    GENERATED_BODY()

public:
    UGSDSmartObjectProcessor();

    virtual void ConfigureQueries() override;
    virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

protected:
    //-- Helper Methods --

    /** Search for nearby Smart Objects */
    void SearchForSmartObject(
        FGSDSmartObjectFragment& SOFragment,
        const FDataFragment_Transform& Transform,
        UGSDSmartObjectSubsystem* SOSubsystem,
        float DeltaTime);

    /** Claim a Smart Object */
    void TryClaimSmartObject(
        FGSDSmartObjectFragment& SOFragment,
        const FDataFragment_Transform& Transform,
        UGSDSmartObjectSubsystem* SOSubsystem);

    /** Process interaction progress */
    void ProcessInteraction(
        FGSDSmartObjectFragment& SOFragment,
        FGSDNavigationFragment& NavFragment,
        float DeltaTime);

    /** Release claimed Smart Object */
    void ReleaseSmartObject(
        FGSDSmartObjectFragment& SOFragment,
        UGSDSmartObjectSubsystem* SOSubsystem);

private:
    FMassEntityQuery EntityQuery;

    //-- Configuration --
    UPROPERTY(EditDefaultsOnly, Category = "Configuration")
    float DefaultSearchRadius = 1000.0f;

    UPROPERTY(EditDefaultsOnly, Category = "Configuration")
    float DefaultInteractionDuration = 3.0f;
};
```

Implementation (Private/Processors/GSDSmartObjectProcessor.cpp):
```cpp
#include "Processors/GSDSmartObjectProcessor.h"
#include "Fragments/GSDSmartObjectFragment.h"
#include "Fragments/GSDNavigationFragment.h"
#include "MassEntity/DataFragmentTypes.h"
#include "Subsystems/GSDSmartObjectSubsystem.h"

UGSDSmartObjectProcessor::UGSDSmartObjectProcessor()
{
    // Run after navigation, before behavior
    ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::SyncWorld;
    ExecutionOrder.ExecuteAfter.Add(UE::Mass::ProcessorGroupNames::SyncWorld);
    ProcessingPhase = EMassProcessingPhase::PrePhysics;
}

void UGSDSmartObjectProcessor::ConfigureQueries()
{
    EntityQuery.AddRequirement<FGSDSmartObjectFragment>(EMassFragmentAccess::ReadWrite);
    EntityQuery.AddRequirement<FGSDNavigationFragment>(EMassFragmentAccess::ReadWrite);
    EntityQuery.AddRequirement<FDataFragment_Transform>(EMassFragmentAccess::ReadOnly);
}

void UGSDSmartObjectProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
    UWorld* World = GetWorld();
    if (!World)
    {
        return;
    }

    UGSDSmartObjectSubsystem* SOSubsystem = World->GetSubsystem<UGSDSmartObjectSubsystem>();
    if (!SOSubsystem)
    {
        return;
    }

    const float DeltaTime = Context.GetDeltaTimeSeconds();

    EntityQuery.ForEachEntityChunk(EntityManager, Context,
        [this, SOSubsystem, DeltaTime](FMassExecutionContext& Context)
        {
            auto SOFragments = Context.GetMutableFragmentView<FGSDSmartObjectFragment>();
            auto NavFragments = Context.GetMutableFragmentView<FGSDNavigationFragment>();
            const auto Transforms = Context.GetFragmentView<FDataFragment_Transform>();

            for (int32 i = 0; i < Context.GetNumEntities(); ++i)
            {
                FGSDSmartObjectFragment& SO = SOFragments[i];
                FGSDNavigationFragment& Nav = NavFragments[i];
                const FDataFragment_Transform& Transform = Transforms[i];

                // State machine for Smart Object interaction
                if (SO.bIsInteracting)
                {
                    // Currently interacting - process progress
                    ProcessInteraction(SO, Nav, DeltaTime);
                }
                else if (SO.HasValidClaim())
                {
                    // Has claim but not interacting - start interaction
                    SO.bIsInteracting = true;
                    SO.InteractionTime = 0.0f;
                    SO.InteractionDuration = DefaultInteractionDuration;

                    // Pause navigation during interaction
                    Nav.DesiredSpeed = 0.0f;
                }
                else
                {
                    // No claim - search for Smart Object
                    SearchForSmartObject(SO, Transform, SOSubsystem, DeltaTime);

                    // If found one, try to claim
                    if (!SO.HasValidClaim())
                    {
                        TryClaimSmartObject(SO, Transform, SOSubsystem);
                    }
                }
            }
        });
}

void UGSDSmartObjectProcessor::SearchForSmartObject(
    FGSDSmartObjectFragment& SOFragment,
    const FDataFragment_Transform& Transform,
    UGSDSmartObjectSubsystem* SOSubsystem,
    float DeltaTime)
{
    // Update search cooldown
    SOFragment.TimeSinceLastSearch += DeltaTime;

    if (SOFragment.TimeSinceLastSearch < SOFragment.SearchCooldown)
    {
        return;  // Still on cooldown
    }

    SOFragment.TimeSinceLastSearch = 0.0f;

    const FVector Location = Transform.GetTransform().GetLocation();
    const float SearchRadius = SOFragment.SearchRadius > 0.0f ?
        SOFragment.SearchRadius : DefaultSearchRadius;

    // Find nearest available Smart Object
    FSmartObjectHandle NearestSO = SOSubsystem->FindNearestAvailableSmartObject(
        Location,
        SearchRadius
    );

    if (NearestSO.IsValid())
    {
        // Store for claiming next frame
        SOFragment.ClaimedHandle = FSmartObjectClaimHandle(NearestSO, {});
        SOFragment.bHasClaimedObject = false;  // Will be set true after actual claim
    }
}

void UGSDSmartObjectProcessor::TryClaimSmartObject(
    FGSDSmartObjectFragment& SOFragment,
    const FDataFragment_Transform& Transform,
    UGSDSmartObjectSubsystem* SOSubsystem)
{
    if (!SOFragment.ClaimedHandle.SmartObjectHandle.IsValid())
    {
        return;  // No candidate to claim
    }

    // Actually claim the Smart Object
    FSmartObjectClaimHandle NewHandle = SOSubsystem->ClaimSmartObject(
        SOFragment.ClaimedHandle.SmartObjectHandle
    );

    if (NewHandle.IsValid())
    {
        SOFragment.ClaimedHandle = NewHandle;
        SOFragment.bHasClaimedObject = true;
    }
    else
    {
        // Claim failed - clear candidate
        SOFragment.ClaimedHandle = FSmartObjectClaimHandle();
    }
}

void UGSDSmartObjectProcessor::ProcessInteraction(
    FGSDSmartObjectFragment& SOFragment,
    FGSDNavigationFragment& NavFragment,
    float DeltaTime)
{
    SOFragment.InteractionTime += DeltaTime;

    if (SOFragment.InteractionTime >= SOFragment.InteractionDuration)
    {
        // Interaction complete
        SOFragment.bInteractionComplete = true;
        SOFragment.bIsInteracting = false;
    }
}

void UGSDSmartObjectProcessor::ReleaseSmartObject(
    FGSDSmartObjectFragment& SOFragment,
    UGSDSmartObjectSubsystem* SOSubsystem)
{
    if (SOFragment.HasValidClaim())
    {
        SOSubsystem->ReleaseSmartObject(SOFragment.ClaimedHandle);
        SOFragment.bHasClaimedObject = false;
        SOFragment.bIsInteracting = false;
        SOFragment.bInteractionComplete = false;
    }
}
```
</action>
  <verify>
test -f Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDSmartObjectProcessor.h && \
test -f Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDSmartObjectProcessor.cpp && \
grep -q "SearchForSmartObject" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDSmartObjectProcessor.cpp && \
grep -q "ProcessInteraction" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDSmartObjectProcessor.cpp && \
echo "Smart Object processor created"
  </verify>
  <done>UGSDSmartObjectProcessor handles search, claim, interact, release lifecycle with cooldowns</done>
</task>

</tasks>

<verification>
1. Smart Object fragment stores claim handle and interaction state
2. Subsystem wraps USmartObjectSubsystem for queries and claims
3. Processor handles interaction lifecycle
4. Search cooldown prevents constant queries
5. Claim validation prevents race conditions
</verification>

<success_criteria>
- FGSDSmartObjectFragment with claim handle and interaction fields
- UGSDSmartObjectSubsystem with FindNearby, Claim, Release operations
- UGSDSmartObjectProcessor with search/claim/interact/release lifecycle
- Thread-safe claiming using FSmartObjectClaimHandle
- Search cooldowns prevent constant queries
</success_criteria>

<output>
After completion, create `.planning/phases/07-crowd-ai-navigation/07-03-SUMMARY.md`
</output>
