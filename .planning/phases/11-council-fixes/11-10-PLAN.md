---
phase: 11-council-fixes
plan: 10
type: execute
wave: 6
depends_on: [11-01, 11-02, 11-07]
files_modified:
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDZombieStateFragment.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDZombieBehaviorProcessor.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDZombieBehaviorProcessor.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/GSD_Crowds.Build.cs
  - Plugins/GSD_Vehicles/Source/GSD_Vehicles/GSD_Vehicles.Build.cs
autonomous: true
must_haves:
  truths:
    - "No game-specific 'Zombie' terminology in platform code"
    - "All Build.cs files have PCHUsage configured"
    - "Processor execution order specified where needed"
    - "TODO comments converted to tickets or implemented"
  artifacts:
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDZombieStateFragment.h"
      provides: "Generic entity state (renamed)"
      contains: "FGSDEntityStateFragment|Generic naming"
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/GSD_Crowds.Build.cs"
      provides: "Build configuration"
      contains: "PCHUsage.*UseExplicitOrSharedPCHs"
  key_links:
    - from: "Platform plugins"
      to: "Game-agnostic design"
      via: "Generic naming"
      pattern: "Entity|Crowd|NPC.*not.*Zombie"
---

<objective>
Perform code quality pass to remove game-specific terminology, add PCH configuration, specify processor order, and address TODOs.

Purpose: Clean up platform code to be game-agnostic. Council review identified game-specific "Zombie" terminology in platform code, missing PCH configuration, and unspecified processor execution order as medium-priority technical debt.

Output: Game-agnostic naming, PCHUsage configured, processor execution order specified, TODOs addressed.

Council Issues: #29, #30, #32, #34 - Game-specific code, missing PCH config, processor order, TODOs (Architecture Rick, Prime Rick, Slick Rick, P2)
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-council-fixes/11-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rename Zombie-Specific Code to Generic Names</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Fragments/GSDZombieStateFragment.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDZombieBehaviorProcessor.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDZombieBehaviorProcessor.cpp
  </files>
  <action>
Review and rename zombie-specific classes to generic crowd/entity names.

**Renaming Strategy:**

**Phase 1: Documentation and Comments**
- Update comments to use generic terms
- Add deprecation notes if needed
- Document that "Zombie" is game-specific example

**Phase 2: Class/Struct Names (Breaking Change)**
- FGSDZombieStateFragment -> FGSDEntityStateFragment (or FGSDFlockStateFragment)
- UGSDZombieBehaviorProcessor -> UGSD CrowdBehaviorProcessor (or UGSDMassBehaviorProcessor)

**Implementation Approach:**

**Option A: Full Rename (Recommended for clean platform)**
```cpp
// BEFORE:
UCLASS()
class GSD_CROWDS_API UGSDZombieBehaviorProcessor : public UMassProcessor
{
    // Zombie-specific behavior
};

// AFTER:
UCLASS()
class GSD_CROWDS_API UGSDMassBehaviorProcessor : public UMassProcessor
{
    // Generic crowd/flock behavior
    // Can be extended for game-specific behaviors (zombies, NPCs, animals, etc.)
};
```

**Option B: Deprecation Path (For backward compatibility)**
```cpp
// New generic class
UCLASS()
class GSD_CROWDS_API UGSDMassBehaviorProcessor : public UMassProcessor
{
    // Generic crowd behavior
};

// Deprecated wrapper
UCLASS(Deprecated)
class GSD_CROWDS_API UGSDZombieBehaviorProcessor : public UGSDMassBehaviorProcessor
{
    // Deprecated: Use UGSDMassBehaviorProcessor instead
};
```

**Files to Update:**

1. **GSDZombieStateFragment.h:**
   - Rename FGSDZombieStateFragment -> FGSDEntityStateFragment
   - Update comments: "Entity state for crowd members"
   - Properties: Health -> Health (generic), Speed -> Speed (generic)

2. **GSDZombieBehaviorProcessor.h:**
   - Rename UGSDZombieBehaviorProcessor -> UGSDMassBehaviorProcessor
   - Update comments: "Generic crowd behavior processor"
   - Keep logic the same (it's already generic)

3. **GSDZombieBehaviorProcessor.cpp:**
   - Update class name to match header
   - Update log messages to use generic terms
   - Update UE_LOG categories

**Important:**
- This is a BREAKING CHANGE for game code
- Document migration path
- Update all references to renamed classes
- Test that renaming doesn't break compilation
- Consider creating typedef for backward compatibility if needed

**Decision:** For Phase 11, use Option B (deprecation path) to avoid breaking existing game code. Full removal in future phase.
  </action>
  <verify>
    ```bash
    # Check for zombie-specific terms
    ZOMBIE_COUNT=$(find Plugins/GSD_Crowds -name "*.h" -o -name "*.cpp" | xargs grep -l "Zombie" | wc -l)
    echo "Files with 'Zombie' term: $ZOMBIE_COUNT"

    # Check if generic classes exist
    if grep -q "FGSDEntityStateFragment\\|UGSDMassBehaviorProcessor" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/**/*.h 2>/dev/null; then
      echo "✓ Generic class names present"
    else
      echo "ℹ Generic class names not yet created (deprecation path)"
    fi

    echo "Zombie terminology verification complete"
    ```
  </verify>
  <done>
    - Zombie-specific classes reviewed
    - Generic naming strategy documented
    - Deprecation path chosen (Option B)
    - Comments updated to clarify game-agnostic design
    - Migration path documented
  </done>
</task>

<task type="auto">
  <name>Task 2: Add PCHUsage Configuration to All Build.cs Files</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/GSD_Crowds.Build.cs
    Plugins/GSD_Vehicles/Source/GSD_Vehicles/GSD_Vehicles.Build.cs
    Plugins/GSD_Core/Source/GSD_Core/GSD_Core.Build.cs
    Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/GSD_CityStreaming.Build.cs
    Plugins/GSD_Telemetry/Source/GSD_Telemetry/GSD_Telemetry.Build.cs
    Plugins/GSD_ValidationTools/Source/GSD_ValidationTools/GSD_ValidationTools.Build.cs
    Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/GSD_DailyEvents.Build.cs
    Plugins/GSD_Audio/Source/GSD_Audio/GSD_Audio.Build.cs
  </files>
  <action>
Add PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs to all plugin Build.cs files.

**Pattern to Apply:**
```csharp
using UnrealBuildTool;

public class GSD_Example : ModuleRules
{
    public GSD_Example(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;  // ADD THIS LINE

        PublicDependencyModuleNames.AddRange(new string[] {
            // ... dependencies
        });
    }
}
```

**Files to Update:**

1. **GSD_Crowds.Build.cs:**
   - Should already have it from Phase 6
   - Verify it's present

2. **GSD_Vehicles.Build.cs:**
   - Should already have it from Phase 4
   - Verify it's present

3. **GSD_Core.Build.cs:**
   - Add if missing
   - Foundation plugin, should have explicit PCH

4. **GSD_CityStreaming.Build.cs:**
   - Add if missing

5. **GSD_Telemetry.Build.cs:**
   - Add if missing

6. **GSD_ValidationTools.Build.cs:**
   - Add if missing

7. **GSD_DailyEvents.Build.cs:**
   - Add if missing

8. **GSD_Audio.Build.cs:**
   - Add if missing (created in Plan 05)

**Why PCHUsage Matters:**
- Improves compilation speed
- Explicit PCH usage prevents ambiguous header inclusion
- UseExplicitOrSharedPCHs is recommended for UE5
- Shared PCHs reduce memory usage during compilation

**Important:**
- Place after constructor opening brace
- Before dependency declarations
- Use exact syntax: PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
  </action>
  <verify>
    ```bash
    # Check all Build.cs files for PCHUsage
    for file in Plugins/GSD_*/Source/GSD_*/GSD_*.Build.cs; do
      if [ -f "$file" ]; then
        PLUGIN=$(basename $(dirname $(dirname "$file")))
        if grep -q "PCHUsage.*UseExplicitOrSharedPCHs" "$file"; then
          echo "✓ $PLUGIN has PCHUsage configured"
        else
          echo "✗ $PLUGIN MISSING PCHUsage"
        fi
      fi
    done

    echo "PCHUsage verification complete"
    ```
  </verify>
  <done>
    - All GSD plugin Build.cs files have PCHUsage configured
    - PCHUsageMode.UseExplicitOrSharedPCHs used consistently
    - Compilation performance improved
    - No ambiguous header inclusion
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Processor Execution Order</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDCrowdLODProcessor.cpp
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDZombieBehaviorProcessor.cpp
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDSmartObjectProcessor.cpp
  </files>
  <action>
Specify processor execution order to ensure correct processing sequence.

**Execution Order Requirements:**

1. **GSDNavigationProcessor** - Run FIRST
   - Updates navigation targets
   - Must run before behavior processor

2. **GSDZombieBehaviorProcessor** (or GSDMassBehaviorProcessor) - Run SECOND
   - Updates entity state based on navigation
   - Needs current navigation data

3. **GSDSmartObjectProcessor** - Run THIRD
   - Handles Smart Object interactions
   - Can modify behavior state

4. **GSDCrowdLODProcessor** - Run LAST
   - Updates LOD representation
   - Should see final state from other processors

**Implementation:**

Add to processor constructors:

**GSDNavigationProcessor.cpp:**
```cpp
UGSDNavigationProcessor::UGSDNavigationProcessor()
{
    // Execute early - before behavior processing
    ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Movement;
    ExecutionOrder.ExecuteBefore.Add(UGSDMassBehaviorProcessor::StaticClass());
}
```

**GSDMassBehaviorProcessor.cpp (renamed from GSDZombieBehaviorProcessor):**
```cpp
UGSDMassBehaviorProcessor::UGSDMassBehaviorProcessor()
{
    // Execute after navigation, before LOD
    ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Behavior;
    ExecutionOrder.ExecuteAfter.Add(UGSDNavigationProcessor::StaticClass());
    ExecutionOrder.ExecuteBefore.Add(UGSDCrowdLODProcessor::StaticClass());
}
```

**GSDSmartObjectProcessor.cpp:**
```cpp
UGSDSmartObjectProcessor::UGSDSmartObjectProcessor()
{
    // Execute after behavior, before LOD
    ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::Behavior;
    ExecutionOrder.ExecuteAfter.Add(UGSDMassBehaviorProcessor::StaticClass());
    ExecutionOrder.ExecuteBefore.Add(UGSDCrowdLODProcessor::StaticClass());
}
```

**GSDCrowdLODProcessor.cpp:**
```cpp
UGSDCrowdLODProcessor::UGSDCrowdLODProcessor()
{
    // Execute late - after all behavior updates
    ExecutionOrder.ExecuteInGroup = UE::Mass::ProcessorGroupNames::LOD;
    ExecutionOrder.ExecuteAfter.Add(UGSDMassBehaviorProcessor::StaticClass());
    ExecutionOrder.ExecuteAfter.Add(UGSDSmartObjectProcessor::StaticClass());
}
```

**Processor Groups:**
- Movement - Navigation, pathfinding
- Behavior - AI decisions, state updates
- LOD - Level of detail updates

**Important:**
- ExecutionOrder is set in constructor
- ExecuteBefore/After creates dependency chain
- ExecuteInGroup groups related processors
- Order ensures data consistency
  </action>
  <verify>
    ```bash
    # Check for ExecutionOrder in processors
    for file in Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/*.cpp; do
      PROCESSOR=$(basename "$file" .cpp)
      if grep -q "ExecutionOrder" "$file"; then
        echo "✓ $PROCESSOR has ExecutionOrder configured"
      else
        echo "ℹ $PROCESSOR does not have ExecutionOrder (may not be critical)"
      fi
    done

    echo "Processor execution order verification complete"
    ```
  </verify>
  <done>
    - Processor execution order specified
    - Navigation runs first
    - Behavior runs second
    - Smart Object runs third
    - LOD runs last
    - Dependency chain established
  </done>
</task>

<task type="auto">
  <name>Task 4: Address TODO Comments</name>
  <files>
    Multiple files (search-based)
  </files>
  <action>
Review all TODO comments and either implement or create tickets.

**Search for TODOs:**
```bash
# Find all TODOs in GSD plugins
find Plugins/GSD_* -name "*.cpp" -o -name "*.h" | xargs grep -n "TODO"
```

**TODO Categories:**

1. **Future Features:**
   - Create ticket in issue tracker
   - Add ticket reference to comment
   - Example: "// TODO(#GSDCROWDS-123): Implement async spawning"

2. **Bug Fixes:**
   - Fix immediately if P0/P1
   - Create ticket if P2/P3

3. **Optimizations:**
   - Create ticket with performance impact estimate
   - Add benchmark if needed

4. **Refactoring:**
   - Create ticket for technical debt
   - Schedule for appropriate phase

**Common TODO Patterns:**

```cpp
// BEFORE:
// TODO: Add async spawning support
void SpawnEntities() { ... }

// AFTER (Option A - Implement):
void SpawnEntities() {
    // Async spawning implemented in Phase 11
    // Uses Mass Entity deferred spawning
}

// AFTER (Option B - Create Ticket):
// TODO(#GSDCROWDS-104): Add async spawning support for large crowds
// Currently spawns synchronously which can cause frame hitches
void SpawnEntities() { ... }
```

**Important:**
- No TODO should remain without a ticket
- All tickets should have priority and estimate
- Critical TODOs should be fixed in this phase
- Document decisions in comments

**Expected TODOs from Council Review:**
- Async spawning (already has ticket reference from Phase 6)
- Performance optimizations
- Editor module creation
- Additional test coverage
  </action>
  <verify>
    ```bash
    # Count TODOs without ticket references
    TODO_COUNT=$(find Plugins/GSD_* -name "*.cpp" -o -name "*.h" | xargs grep "TODO" | grep -v "TODO(#" | wc -l)
    echo "TODOs without ticket references: $TODO_COUNT"

    # List all TODOs for review
    echo "=== All TODOs in GSD Plugins ==="
    find Plugins/GSD_* -name "*.cpp" -o -name "*.h" | xargs grep -n "TODO" | head -20

    echo "TODO verification complete"
    ```
  </verify>
  <done>
    - All TODOs reviewed
    - Critical TODOs implemented or have tickets
    - Ticket references added to remaining TODOs
    - No orphaned TODOs without tracking
    - Documentation updated
  </done>
</task>

</tasks>

<verification>
1. Zombie-specific terminology reviewed and documented
2. PCHUsage configured in all Build.cs files
3. Processor execution order specified
4. TODOs addressed or ticketed
5. Code is game-agnostic
</verification>

<success_criteria>
- Zombie-specific classes reviewed with migration strategy documented
- All 8 GSD plugins have PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs
- Processor execution order: Navigation -> Behavior -> Smart Object -> LOD
- All TODOs have ticket references or are implemented
- Platform code is game-agnostic (generic naming, no game-specific logic)
</success_criteria>

<output>
After completion, create `.planning/phases/11-council-fixes/11-10-SUMMARY.md`
</output>
