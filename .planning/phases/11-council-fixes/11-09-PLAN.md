---
phase: 11-council-fixes
plan: 09
type: execute
wave: 5
depends_on: [11-07, 11-08]
files_modified:
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDNavigationProcessor.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDSmartObjectSubsystem.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/DataAssets/GSDNavigationConfig.h
autonomous: true
must_haves:
  truths:
    - "ZoneGraph dependency added to GSD_Crowds Build.cs"
    - "Navigation processor uses ZoneGraph lanes"
    - "Smart Object claiming system functional"
    - "Crowd budget management implemented"
  artifacts:
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp"
      provides: "ZoneGraph navigation"
      contains: "FZoneGraphLaneHandle, QueryLanes"
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp"
      provides: "Smart Object management"
      contains: "ClaimSmartObject, ReleaseSmartObject"
  key_links:
    - from: "GSDNavigationProcessor"
      to: "ZoneGraph"
      via: "Lane queries"
      pattern: "ZoneGraph|LaneHandle"
---

<objective>
Complete navigation integration with ZoneGraph, Smart Objects, and budget management.

Purpose: Finish the crowd navigation system. Council review identified missing ZoneGraph integration, Smart Object system, and budget management as high-priority issues for crowd AI.

Output: Navigation processor using ZoneGraph lanes, Smart Object claiming system, crowd budget management.

Council Issues: #12, #20, #21, #23 - Missing ZoneGraph navigation, Smart Objects, budget management (Swarm Rick, P1)
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-council-fixes/11-RESEARCH.md

# Reference Phase 7 work
@.planning/phases/07-crowd-ai-navigation/07-02-SUMMARY.md
@.planning/phases/07-crowd-ai-navigation/07-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify ZoneGraph Integration in Build.cs</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/GSD_Crowds.Build.cs
  </files>
  <action>
Verify ZoneGraph and MassMovement dependencies are present in GSD_Crowds Build.cs.

**Check for Required Dependencies:**
```csharp
PublicDependencyModuleNames.AddRange(new string[] {
    "Core",
    "CoreUObject",
    "Engine",
    "GSD_Core",
    "GSD_CityStreaming",
    "MassEntity",
    "MassRepresentation",
    "MassSpawner",
    "MassLOD",
    "MassCommon",
    "MassAI",           // Required for ZoneGraph
    "ZoneGraph",        // CRITICAL: Lane-based navigation
    "MassMovement",     // CRITICAL: Movement along lanes
    "StateTreeModule",
    "SmartObjectsModule",
    "AIModule",
    "NavigationSystem",
    "GameplayTags"
});
```

**Verification Steps:**
1. Read current Build.cs
2. Verify "ZoneGraph" is in PublicDependencyModuleNames
3. Verify "MassMovement" is in PublicDependencyModuleNames
4. Add if missing (should already be present from Phase 7)

**Important:**
- ZoneGraph provides lane-based navigation
- MassMovement provides movement along lanes
- These are CRITICAL for crowd navigation
- Must be in Public (not Private) dependencies
  </action>
  <verify>
    ```bash
    # Verify ZoneGraph dependency
    grep -q "ZoneGraph" Plugins/GSD_Crowds/Source/GSD_Crowds/GSD_Crowds.Build.cs && echo "✓ ZoneGraph dependency present" || echo "✗ ZoneGraph dependency MISSING"

    # Verify MassMovement dependency
    grep -q "MassMovement" Plugins/GSD_Crowds/Source/GSD_Crowds/GSD_Crowds.Build.cs && echo "✓ MassMovement dependency present" || echo "✗ MassMovement dependency MISSING"

    echo "ZoneGraph integration verification complete"
    ```
  </verify>
  <done>
    - ZoneGraph dependency verified in Build.cs
    - MassMovement dependency verified in Build.cs
    - All navigation dependencies present
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify Navigation Processor Implementation</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Processors/GSDNavigationProcessor.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp
  </files>
  <action>
Verify GSDNavigationProcessor uses ZoneGraph for navigation (from Phase 7).

**Expected Implementation:**

**GSDNavigationProcessor.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "MassProcessor.h"
#include "ZoneGraph/ZoneGraphTypes.h"
#include "GSDNavigationProcessor.generated.h"

struct FGSDNavigationFragment;
struct FMassMoveTargetFragment;
class UGSDCrowdConfig;

/**
 * Processor for crowd navigation using ZoneGraph lanes.
 * Queries nearby lanes and updates movement targets.
 */
UCLASS()
class GSD_CROWDS_API UGSDNavigationProcessor : public UMassProcessor
{
    GENERATED_BODY()

public:
    UGSDNavigationProcessor();

protected:
    virtual void ConfigureQueries() override;
    virtual void Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context) override;

private:
    // Entity query
    FMassEntityQuery EntityQuery;

    // Config reference
    UPROPERTY()
    UGSDCrowdConfig* Config;

    // Navigation helpers
    bool FindNearestLane(const FVector& Location, FZoneGraphLaneHandle& OutLaneHandle) const;
    FVector GetRandomPointOnLane(const FZoneGraphLaneHandle& LaneHandle) const;
    void UpdateMoveTarget(FMassMoveTargetFragment& MoveTarget, const FVector& TargetLocation);
};
```

**GSDNavigationProcessor.cpp (Key Functions):**
```cpp
#include "Processors/GSDNavigationProcessor.h"
#include "Fragments/GSDNavigationFragment.h"
#include "MassMovement/MassMoveTargetFragment.h"
#include "ZoneGraph/ZoneGraphSubsystem.h"
#include "DataAssets/GSDCrowdConfig.h"

void UGSDNavigationProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
    // Get config
    Config = UGSDCrowdConfig::GetDefaultConfig();
    if (!Config)
    {
        return;
    }

    // Process entities
    EntityQuery.ForEachEntityChunk(Context, [this](FMassExecutionContext& ChunkContext)
    {
        // Get fragments
        auto& NavigationFragments = ChunkContext.GetMutableFragmentView<FGSDNavigationFragment>();
        auto& MoveTargetFragments = ChunkContext.GetMutableFragmentView<FMassMoveTargetFragment>();

        for (int32 i = 0; i < ChunkContext.GetNumEntities(); ++i)
        {
            FGSDNavigationFragment& NavFrag = NavigationFragments[i];
            FMassMoveTargetFragment& MoveTarget = MoveTargetFragments[i];

            // If no lane, find nearest
            if (!NavFrag.CurrentLaneHandle.IsValid())
            {
                FVector EntityLocation = MoveTarget.Center;  // Approximate
                FindNearestLane(EntityLocation, NavFrag.CurrentLaneHandle);
            }

            // If reached target, get new random point on lane
            if (NavFrag.bReachedTarget || !NavFrag.TargetLocation.IsSet())
            {
                FVector NewTarget = GetRandomPointOnLane(NavFrag.CurrentLaneHandle);
                NavFrag.TargetLocation = NewTarget;
                NavFrag.bReachedTarget = false;

                UpdateMoveTarget(MoveTarget, NewTarget);
            }
        }
    });
}

bool UGSDNavigationProcessor::FindNearestLane(const FVector& Location, FZoneGraphLaneHandle& OutLaneHandle) const
{
    UWorld* World = GetWorld();
    if (!World)
    {
        return false;
    }

    UZoneGraphSubsystem* ZoneGraphSubsystem = World->GetSubsystem<UZoneGraphSubsystem>();
    if (!ZoneGraphSubsystem)
    {
        return false;
    }

    // Query lanes within search radius
    TArray<FZoneGraphLaneHandle> NearbyLanes;
    ZoneGraphSubsystem->FindLanesInBounds(
        FBoxCenterAndExtent(Location, FVector(Config->LaneSearchRadius)),
        NearbyLanes
    );

    if (NearbyLanes.Num() > 0)
    {
        // Select random lane (for wandering behavior)
        int32 RandomIndex = FMath::RandHelper(NearbyLanes.Num());
        OutLaneHandle = NearbyLanes[RandomIndex];
        return true;
    }

    return false;
}

FVector UGSDNavigationProcessor::GetRandomPointOnLane(const FZoneGraphLaneHandle& LaneHandle) const
{
    UWorld* World = GetWorld();
    if (!World)
    {
        return FVector::ZeroVector;
    }

    UZoneGraphSubsystem* ZoneGraphSubsystem = World->GetSubsystem<UZoneGraphSubsystem>();
    if (!ZoneGraphSubsystem)
    {
        return FVector::ZeroVector;
    }

    // Get lane data
    const FZoneGraphLaneData* LaneData = ZoneGraphSubsystem->GetLaneData(LaneHandle);
    if (!LaneData)
    {
        return FVector::ZeroVector;
    }

    // Get random point along lane
    float RandomDistance = FMath::FRand() * LaneData->Length;
    FVector PointOnLane;
    LaneData->GetPointAtDistance(RandomDistance, PointOnLane);

    return PointOnLane;
}

void UGSDNavigationProcessor::UpdateMoveTarget(FMassMoveTargetFragment& MoveTarget, const FVector& TargetLocation)
{
    MoveTarget.Center = TargetLocation;
    MoveTarget.Slack = 100.0f;  // Arrival threshold
    MoveTarget.bDeferredMovement = false;
}
```

**Important:**
- Verify ZoneGraphSubsystem is used
- FZoneGraphLaneHandle for lane references
- FindLanesInBounds for lane queries
- Random lane selection for wandering
- GetPointAtDistance for point on lane
- Config->LaneSearchRadius for search radius

**If Implementation Missing:**
Create the full implementation as shown above.
  </action>
  <verify>
    ```bash
    # Verify navigation processor exists
    test -f Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp && echo "✓ Navigation processor exists" || echo "✗ Navigation processor missing"

    # Check for ZoneGraph usage
    grep -q "ZoneGraphSubsystem" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp && echo "✓ ZoneGraphSubsystem used" || echo "✗ ZoneGraphSubsystem missing"
    grep -q "FZoneGraphLaneHandle" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp && echo "✓ FZoneGraphLaneHandle used" || echo "✗ FZoneGraphLaneHandle missing"
    grep -q "FindLanesInBounds\\|GetLaneData" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDNavigationProcessor.cpp && echo "✓ Lane queries implemented" || echo "✗ Lane queries missing"

    echo "Navigation processor verification complete"
    ```
  </verify>
  <done>
    - GSDNavigationProcessor verified/implemented
    - ZoneGraph integration confirmed
    - Lane queries functional
    - Random lane selection for wandering
    - Config-driven search radius
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify Smart Object Subsystem</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDSmartObjectSubsystem.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp
  </files>
  <action>
Verify UGSDSmartObjectSubsystem implementation for Smart Object claiming (from Phase 7).

**Expected Implementation:**

**GSDSmartObjectSubsystem.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "SmartObjectClaimHandle.h"
#include "GSDSmartObjectSubsystem.generated.h"

/**
 * Subsystem for managing Smart Object claims for crowd entities.
 * Provides thread-safe claiming and releasing of Smart Objects.
 */
UCLASS()
class GSD_CROWDS_API UGSDSmartObjectSubsystem : public UWorldSubsystem
{
    GENERATED_BODY()

public:
    // USubsystem interface
    virtual void Initialize(FSubsystemCollectionBase& Collection) override;
    virtual void Deinitialize() override;

    // Smart Object claiming
    UFUNCTION(BlueprintCallable, Category = "GSD|SmartObjects")
    FSmartObjectClaimHandle ClaimSmartObject(AActor* SmartObject, int32 SlotIndex);

    UFUNCTION(BlueprintCallable, Category = "GSD|SmartObjects")
    void ReleaseSmartObject(const FSmartObjectClaimHandle& Handle);

    UFUNCTION(BlueprintPure, Category = "GSD|SmartObjects")
    bool IsSmartObjectClaimed(AActor* SmartObject, int32 SlotIndex) const;

    UFUNCTION(BlueprintPure, Category = "GSD|SmartObjects")
    bool IsValidClaim(const FSmartObjectClaimHandle& Handle) const;

    // Search
    UFUNCTION(BlueprintCallable, Category = "GSD|SmartObjects")
    TArray<AActor*> FindNearbySmartObjects(const FVector& Location, float Radius) const;

private:
    // Active claims
    UPROPERTY()
    TMap<FGuid, FSmartObjectClaimHandle> ActiveClaims;

    // Smart Object registry
    UPROPERTY()
    TArray<AActor*> RegisteredSmartObjects;

    // Thread-safe claim ID generation
    FGuid GenerateClaimId();
};
```

**GSDSmartObjectSubsystem.cpp (Key Functions):**
```cpp
#include "Subsystems/GSDSmartObjectSubsystem.h"

void UGSDSmartObjectSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);

    UE_LOG(LogTemp, Log, TEXT("GSDSmartObjectSubsystem initialized"));
}

void UGSDSmartObjectSubsystem::Deinitialize()
{
    // Release all active claims
    ActiveClaims.Empty();
    RegisteredSmartObjects.Empty();

    Super::Deinitialize();
}

FSmartObjectClaimHandle UGSDSmartObjectSubsystem::ClaimSmartObject(AActor* SmartObject, int32 SlotIndex)
{
    if (!SmartObject)
    {
        return FSmartObjectClaimHandle();
    }

    // Check if already claimed
    if (IsSmartObjectClaimed(SmartObject, SlotIndex))
    {
        UE_LOG(LogTemp, Warning, TEXT("Smart Object %s slot %d already claimed"), *SmartObject->GetName(), SlotIndex);
        return FSmartObjectClaimHandle();
    }

    // Create claim handle
    FSmartObjectClaimHandle Handle;
    Handle.ClaimId = GenerateClaimId();
    Handle.SmartObject = SmartObject;
    Handle.SlotIndex = SlotIndex;

    // Register claim
    ActiveClaims.Add(Handle.ClaimId, Handle);

    UE_LOG(LogTemp, Log, TEXT("Claimed Smart Object %s slot %d"), *SmartObject->GetName(), SlotIndex);

    return Handle;
}

void UGSDSmartObjectSubsystem::ReleaseSmartObject(const FSmartObjectClaimHandle& Handle)
{
    if (!Handle.IsValid())
    {
        return;
    }

    // Remove from active claims
    if (ActiveClaims.Remove(Handle.ClaimId))
    {
        UE_LOG(LogTemp, Log, TEXT("Released Smart Object claim %s"), *Handle.ClaimId.ToString());
    }
}

bool UGSDSmartObjectSubsystem::IsSmartObjectClaimed(AActor* SmartObject, int32 SlotIndex) const
{
    for (const auto& Pair : ActiveClaims)
    {
        if (Pair.Value.SmartObject == SmartObject && Pair.Value.SlotIndex == SlotIndex)
        {
            return true;
        }
    }
    return false;
}

bool UGSDSmartObjectSubsystem::IsValidClaim(const FSmartObjectClaimHandle& Handle) const
{
    return ActiveClaims.Contains(Handle.ClaimId);
}

TArray<AActor*> UGSDSmartObjectSubsystem::FindNearbySmartObjects(const FVector& Location, float Radius) const
{
    TArray<AActor*> NearbyObjects;

    for (AActor* SmartObject : RegisteredSmartObjects)
    {
        if (SmartObject)
        {
            float Distance = FVector::Dist(Location, SmartObject->GetActorLocation());
            if (Distance <= Radius)
            {
                NearbyObjects.Add(SmartObject);
            }
        }
    }

    return NearbyObjects;
}

FGuid UGSDSmartObjectSubsystem::GenerateClaimId()
{
    return FGuid::NewGuid();
}
```

**Important:**
- FSmartObjectClaimHandle for thread-safe claims
- Claim/Release/IsValid/IsClaimed methods
- FindNearbySmartObjects for searching
- Active claims map for tracking
- GUid for unique claim IDs
  </action>
  <verify>
    ```bash
    # Verify Smart Object subsystem exists
    test -f Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp && echo "✓ Smart Object subsystem exists" || echo "✗ Smart Object subsystem missing"

    # Check for claiming functionality
    grep -q "ClaimSmartObject" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp && echo "✓ ClaimSmartObject implemented" || echo "✗ ClaimSmartObject missing"
    grep -q "ReleaseSmartObject" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp && echo "✓ ReleaseSmartObject implemented" || echo "✗ ReleaseSmartObject missing"
    grep -q "FSmartObjectClaimHandle" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDSmartObjectSubsystem.cpp && echo "✓ FSmartObjectClaimHandle used" || echo "✗ FSmartObjectClaimHandle missing"

    echo "Smart Object subsystem verification complete"
    ```
  </verify>
  <done>
    - UGSDSmartObjectSubsystem verified/implemented
    - Claim/Release functionality working
    - Thread-safe claim handles
    - Nearby search functionality
    - Active claims tracking
  </done>
</task>

</tasks>

<verification>
1. ZoneGraph dependency in Build.cs
2. GSDNavigationProcessor uses ZoneGraph for lane navigation
3. UGSDSmartObjectSubsystem with claim/release functionality
4. Smart Object claiming is thread-safe
5. Navigation uses config-driven parameters
</verification>

<success_criteria>
- ZoneGraph and MassMovement dependencies in Build.cs
- GSDNavigationProcessor queries lanes via ZoneGraphSubsystem
- FZoneGraphLaneHandle for lane references
- UGSDSmartObjectSubsystem with ClaimSmartObject, ReleaseSmartObject
- FSmartObjectClaimHandle for thread-safe claiming
- FindNearbySmartObjects for searching
- Crowd budget management (via config MaxEntityCount)
</success_criteria>

<output>
After completion, create `.planning/phases/11-council-fixes/11-09-SUMMARY.md`
</output>
