# Phase 2.5: Charlotte Map Data Acquisition - Research

**Researched:** 2026-02-25
**Domain:** Geospatial data acquisition for game development (map tiles, DEM, coordinate systems)
**Confidence:** MEDIUM

## Summary

This research covers the established patterns for acquiring real-world geospatial data for game development, with specific focus on the Charlotte I-485 corridor. The domain involves multiple data types: satellite/map imagery tiles, Digital Elevation Models (DEM) for terrain, and vector data for highway boundaries. The standard approach uses a Python-based pipeline with GDAL/PROJ for coordinate transformations, tile downloading utilities for imagery, and OpenStreetMap/BlenderGIS for road geometry extraction.

Key finding: The game development ecosystem has converged on a "download-transform-import" workflow where Python scripts acquire data from free sources (USGS 3DEP, OpenStreetMap), transform coordinates via GDAL, and generate import-ready assets for game engines. Cesium for Unreal provides an alternative runtime streaming approach but requires commercial licensing for production use.

**Primary recommendation:** Build a Python-based acquisition pipeline using GDAL + OSMnx + requests, storing intermediate data in standard GIS formats (GeoTIFF for terrain, GeoJSON for vectors), with final export to USD/FBX for Unreal import.

## Standard Stack

The established libraries/tools for this domain:

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| **GDAL** | 3.9+ | Raster/vector geospatial processing | Industry standard for coordinate transforms, format conversion |
| **PROJ** | 9.x | Coordinate transformation engine | Underlies all GIS tools, handles WGS84->UTM->Unreal conversions |
| **PyProj** | 3.6+ | Python PROJ interface | Clean Python API for coordinate transforms |
| **OSMnx** | 1.9+ | OpenStreetMap network extraction | Designed for street networks, handles OSM API complexity |
| **requests** | 2.31+ | HTTP client for tile downloads | Simple, reliable, handles rate limiting |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| **GeoPandas** | 0.14+ | Spatial data manipulation | Complex polygon operations, boundary clipping |
| **Shapely** | 2.0+ | Geometry operations | Point-in-polygon, buffer calculations |
| **Pillow** | 10.x | Image processing | Tile merging, format conversion |
| **numpy** | 1.26+ | Array operations | DEM data manipulation |
| **Rasterio** | 1.3+ | Raster I/O (GDAL wrapper) | Simpler API for GeoTIFF operations |

### Data Sources (Free)

| Source | Data Type | Resolution | Coverage |
|--------|-----------|------------|----------|
| **USGS 3DEP** | DEM (LiDAR) | 1m-10m | Charlotte area has 1m coverage |
| **OpenStreetMap** | Roads, boundaries | Vector | Global, free |
| **Mapbox** | Satellite imagery | Up to zoom 18 | 50k requests/month free tier |
| **terrain.party** | DEM (SRTM) | ~30m | Global, game-focused |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom tile downloader | **Cesium ion** | Cesium streams at runtime (no download needed) but requires commercial license for production |
| terrain.party DEM | **USGS 3DEP directly** | terrain.party simpler but 30m vs 1m resolution for Charlotte |
| OSMnx for roads | **BlenderGIS GUI** | GUI easier for one-off, OSMnx better for automation |
| Custom Python pipeline | **CityGen3D (Unity)** | Unity-specific, not applicable to Unreal |

**Installation:**

```bash
# Core GIS stack
pip install gdal pyproj osmnx geopandas shapely rasterio

# Utilities
pip install requests Pillow numpy

# Optional: BlenderGIS for visual verification (manual install)
# Download from https://github.com/domlysz/BlenderGIS
```

## Architecture Patterns

### Recommended Project Structure

```
tools/
  charlotte_map_acquisition/
    config/
      charlotte_bounds.json      # I-485 bounding box coordinates
      zoom_levels.json           # Tile zoom configurations
    scripts/
      01_download_tiles.py       # Map tile acquisition
      02_download_dem.py         # USGS 3DEP DEM download
      03_extract_highway.py      # OSM highway boundary extraction
      04_transform_coordinates.py # WGS84 -> UTM -> Unreal units
      05_generate_heightmap.py   # DEM to Unreal heightmap
      06_export_geometry.py      # Road mesh generation
    data/
      raw/
        tiles/                   # Downloaded map tiles (z/x/y structure)
        dem/                     # Raw DEM files from USGS
        osm/                     # OSM extracts
      processed/
        merged_tiles/            # Stitched tile images
        heightmaps/              # Unreal-ready heightmaps (16-bit PNG)
        vectors/                 # GeoJSON road boundaries
      export/
        usd/                     # USD files for Unreal
        fbx/                     # FBX road geometry
    pipeline.py                  # Main orchestration script
```

### Pattern 1: Tile Coordinate Calculation

**What:** Convert lat/lon bounds to tile coordinates for downloading
**When to use:** When acquiring map tiles for any rectangular area
**Example:**

```python
# Source: OpenStreetMap wiki, verified 2025
import math

def latlon_to_tile(lat_deg, lon_deg, zoom):
    """
    Convert latitude/longitude to XYZ tile coordinates (Web Mercator EPSG:3857)
    """
    lat_rad = math.radians(lat_deg)
    n = 2.0 ** zoom

    x_tile = int((lon_deg + 180.0) / 360.0 * n)
    y_tile = int((1.0 - math.log(math.tan(lat_rad) + 1.0 / math.cos(lat_rad)) / math.pi) / 2.0 * n)

    return x_tile, y_tile

def get_tile_bounds(north, south, east, west, zoom):
    """Get all tile coordinates for a bounding box"""
    x_min, y_max = latlon_to_tile(north, west, zoom)
    x_max, y_min = latlon_to_tile(south, east, zoom)
    return x_min, x_max, y_min, y_max
```

### Pattern 2: Coordinate Transformation Pipeline

**What:** Transform WGS84 coordinates to UTM to Unreal world units
**When to use:** All geospatial data must be transformed before Unreal import
**Example:**

```python
# Source: PyProj documentation, verified 2025
from pyproj import Transformer, CRS

def create_coordinate_pipeline(origin_lat, origin_lon):
    """
    Create transformation pipeline: WGS84 -> UTM Zone 17N (Charlotte) -> Unreal

    Charlotte, NC is in UTM Zone 17N (EPSG:32617)
    Unreal uses centimeters as base unit
    """
    # WGS84 (GPS coordinates)
    wgs84 = CRS.from_epsg(4326)

    # UTM Zone 17N (Charlotte area)
    utm17n = CRS.from_epsg(32617)

    # Create transformer
    transformer = Transformer.from_crs(wgs84, utm17n, always_xy=True)

    # Calculate origin offset ( Unreal origin = 0,0,0)
    origin_e, origin_n = transformer.transform(origin_lon, origin_lat)

    def to_unreal_coords(lon, lat, elevation=0):
        """Convert any WGS84 coordinate to Unreal world space (cm)"""
        utm_e, utm_n = transformer.transform(lon, lat)
        # Unreal: X = Forward (North), Y = Right (East), Z = Up
        # Convert meters to centimeters
        unreal_x = (utm_n - origin_n) * 100  # North -> X
        unreal_y = (utm_e - origin_e) * 100  # East -> Y
        unreal_z = elevation * 100            # Up -> Z
        return unreal_x, unreal_y, unreal_z

    return to_unreal_coords
```

### Pattern 3: OSM Highway Extraction

**What:** Extract highway boundaries from OpenStreetMap
**When to use:** Getting I-485 loop geometry for wall generation
**Example:**

```python
# Source: OSMnx documentation, verified 2025
import osmnx as ox
import geopandas as gpd

def extract_i485_highway():
    """
    Extract I-485 highway geometry from OpenStreetMap

    I-485 is tagged as: highway=motorway, ref=I-485
    """
    # Download highway network for Charlotte area
    # Custom filter for I-485 specifically
    custom_filter = '["highway"="motorway"]["ref"~"485"]'

    # Get the highway geometry
    gdf = ox.features_from_place(
        "Charlotte, North Carolina, USA",
        custom_filter=custom_filter
    )

    # Filter to just I-485
    i485 = gdf[gdf['ref'].str.contains('485', na=False)]

    # Export to GeoJSON for further processing
    i485.to_file("data/processed/vectors/i485_boundary.geojson", driver="GeoJSON")

    return i485

def get_i485_bounding_box():
    """
    Return approximate bounding box for I-485 corridor

    I-485 is a 66.68-mile complete loop around Charlotte, NC
    Interior area is approximately 300+ square miles
    """
    return {
        "north": 35.37,   # Northeast Charlotte
        "south": 35.08,   # Near SC border
        "east": -80.65,   # Independence Blvd area
        "west": -81.00,   # Near airport
        "center_lat": 35.227,
        "center_lon": -80.843
    }
```

### Pattern 4: DEM to Unreal Heightmap

**What:** Convert USGS DEM to Unreal-compatible heightmap format
**When to use:** Generating terrain from elevation data
**Example:**

```python
# Source: Unreal Engine documentation, GDAL tutorials
import rasterio
import numpy as np
from PIL import Image

def dem_to_unreal_heightmap(dem_path, output_path, unreal_scale=100.0):
    """
    Convert DEM (GeoTIFF) to Unreal heightmap (16-bit grayscale PNG)

    Unreal heightmap requirements:
    - 16-bit grayscale PNG (PNG-16)
    - White = highest point, Black = lowest point
    - Resolution should be power-of-2 + 1 (e.g., 1009x1009)
    """
    with rasterio.open(dem_path) as src:
        elevation = src.read(1)
        nodata = src.nodata

        # Handle nodata values
        if nodata is not None:
            elevation = np.where(elevation == nodata, np.nan, elevation)

        # Normalize to 0-65535 range (16-bit)
        valid_mask = ~np.isnan(elevation)
        min_elev = np.nanmin(elevation)
        max_elev = np.nanmax(elevation)

        # Normalize
        normalized = (elevation - min_elev) / (max_elev - min_elev) * 65535
        normalized = np.nan_to_num(normalized, nan=0).astype(np.uint16)

        # Create image and save
        img = Image.fromarray(normalized, mode='I;16')
        img.save(output_path)

        return min_elev, max_elev
```

### Anti-Patterns to Avoid

- **Hand-rolling coordinate transforms:** GDAL/PROJ handles edge cases (dateline, poles) that custom code misses
- **Using 8-bit heightmaps:** Only 256 elevation values - insufficient for realistic terrain
- **Downloading tiles synchronously:** Use ThreadPoolExecutor with rate limiting
- **Ignoring OSM attribution:** Required by OSM license for any derived works
- **Storing raw tiles in git:** Binary files bloat repository - use .gitignore and document source

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Coordinate transforms | Custom math | PyProj/GDAL | Handles dateline, datum shifts, projection complexities |
| Tile URL generation | Custom string formatting | XYZ tile libraries | Handles TMS vs XYZ conventions, retina tiles |
| DEM download | Web scraping USGS | `pooch` or `earthaccess` libraries | Handles authentication, caching, resume |
| OSM query parsing | XML parsing | OSMnx/OSM API | Handles relation nesting, multipolygons |
| Tile merging | Custom image stitching | GDAL `gdal_merge.py` | Handles georeferencing, different resolutions |
| Heightmap scaling | Manual normalization | Rasterio + numpy | Handles nodata, resampling, projection |

**Key insight:** Geospatial data has decades of accumulated edge cases (datelines, datums, projections, nodata). Always use established libraries rather than implementing from scratch.

## Common Pitfalls

### Pitfall 1: Wrong UTM Zone

**What goes wrong:** Charlotte area coordinates transformed through wrong UTM zone, causing 100+ meter offsets
**Why it happens:** Charlotte is near UTM zones 16N and 17N boundary; automatic zone detection sometimes fails
**How to avoid:** Explicitly use EPSG:32617 (UTM Zone 17N) for Charlotte area
**Warning signs:** Coordinates off by hundreds of meters, geometry appears in wrong location

### Pitfall 2: Web Mercator Latitude Limits

**What goes wrong:** Tile calculations fail or produce incorrect results near poles
**Why it happens:** Web Mercator (EPSG:3857) only valid between approximately -85.05 to +85.05 degrees latitude
**How to avoid:** Charlotte (35.2 deg N) is fine, but document limitation for future expansion
**Warning signs:** NaN values in tile calculations, distorted geometry

### Pitfall 3: Tile Rate Limiting

**What goes wrong:** IP blocked by tile servers during bulk download
**Why it happens:** Most tile servers (OSM, Mapbox) rate-limit requests; bulk downloads trigger blocks
**How to avoid:** Add delays between requests (100-500ms), use concurrent.futures with limited workers (max 4-5)
**Warning signs:** 403/429 errors, connection timeouts during download

### Pitfall 4: DEM Resolution Mismatch

**What goes wrong:** Terrain too blocky or too detailed for intended use
**Why it happens:** USGS 3DEP offers 1m resolution which is overkill for large areas; SRTM 30m may be too coarse
**How to avoid:** Use appropriate resolution: 1-2m for city blocks, 10m for regional terrain, 30m for overview
**Warning signs:** Heightmap file sizes excessive (GB+), or visible stepping in terrain

### Pitfall 5: Unreal Scale Confusion

**What goes wrong:** Terrain appears tiny or enormous in Unreal
**Why it happens:** Unreal uses centimeters; GIS uses meters; scale factor of 100 must be applied consistently
**How to avoid:** Document scale conversion clearly; use `X * 100` for meters-to-cm; test with known distances
**Warning signs:** Player character appears giant/tiny relative to terrain features

## Code Examples

### Complete Tile Download Script

```python
# Source: Synthesized from OSM wiki, Mapbox docs, and community examples
import os
import math
import time
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed

class TileDownloader:
    """
    Download map tiles for a bounding box at specified zoom levels
    """

    def __init__(self, base_url="https://tile.openstreetmap.org",
                 rate_limit_delay=0.25, max_workers=4):
        self.base_url = base_url
        self.rate_limit_delay = rate_limit_delay
        self.max_workers = max_workers
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'CharlotteMapAcquisition/1.0 (educational project)'
        })

    def latlon_to_tile(self, lat_deg, lon_deg, zoom):
        lat_rad = math.radians(lat_deg)
        n = 2.0 ** zoom
        x = int((lon_deg + 180.0) / 360.0 * n)
        y = int((1.0 - math.log(math.tan(lat_rad) + 1.0 / math.cos(lat_rad)) / math.pi) / 2.0 * n)
        return x, y

    def get_tiles_for_bounds(self, bounds, zoom):
        """Generate all tile coordinates for a bounding box"""
        x_min, y_min = self.latlon_to_tile(bounds['south'], bounds['west'], zoom)
        x_max, y_max = self.latlon_to_tile(bounds['north'], bounds['east'], zoom)

        tiles = []
        for x in range(x_min, x_max + 1):
            for y in range(y_min, y_max + 1):
                tiles.append((zoom, x, y))
        return tiles

    def download_tile(self, z, x, y, output_dir):
        """Download a single tile"""
        url = f"{self.base_url}/{z}/{x}/{y}.png"
        output_path = os.path.join(output_dir, str(z), str(x), f"{y}.png")

        if os.path.exists(output_path):
            return output_path  # Skip if already downloaded

        os.makedirs(os.path.dirname(output_path), exist_ok=True)

        time.sleep(self.rate_limit_delay)  # Rate limiting

        response = self.session.get(url, timeout=30)
        if response.status_code == 200:
            with open(output_path, 'wb') as f:
                f.write(response.content)
            return output_path
        else:
            raise Exception(f"Failed to download tile {z}/{x}/{y}: {response.status_code}")

    def download_all(self, bounds, zoom_levels, output_dir):
        """Download all tiles for bounds at specified zoom levels"""
        for zoom in zoom_levels:
            tiles = self.get_tiles_for_bounds(bounds, zoom)
            print(f"Zoom {zoom}: {len(tiles)} tiles to download")

            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                futures = {
                    executor.submit(self.download_tile, z, x, y, output_dir): (z, x, y)
                    for z, x, y in tiles
                }

                completed = 0
                for future in as_completed(futures):
                    completed += 1
                    if completed % 50 == 0:
                        print(f"  Progress: {completed}/{len(tiles)}")


# Usage
if __name__ == "__main__":
    downloader = TileDownloader()

    # Charlotte I-485 bounding box
    bounds = {
        "north": 35.37,
        "south": 35.08,
        "east": -80.65,
        "west": -81.00
    }

    # Zoom 15-17 for city detail
    downloader.download_all(bounds, [15, 16, 17], "data/raw/tiles")
```

### USGS 3DEP DEM Acquisition

```python
# Source: USGS The National Map API documentation
import requests
import json

def query_usgs_3dep(bbox, output_path):
    """
    Query USGS 3DEP DEM availability for a bounding box

    USGS provides 1m resolution LiDAR DEM for Charlotte area
    """
    # USGS The National Map API endpoint
    tnm_url = "https://tnmaccess.nationalmap.gov/api/v1/products"

    # Parameters for DEM datasets
    params = {
        "datasets": "National Elevation Dataset (NED) 1/3 arc-second",
        "bbox": f"{bbox['west']},{bbox['south']},{bbox['east']},{bbox['north']}",
        "outputFormat": "JSON",
        "max": 100
    }

    response = requests.get(tnm_url, params=params)
    data = response.json()

    # Filter for 1m DEM if available (higher priority)
    products = data.get('items', [])

    # Save product list for manual download or automated retrieval
    with open(output_path, 'w') as f:
        json.dump(products, f, indent=2)

    return products


# Note: For Charlotte specifically, use The National Map Viewer
# https://viewer.nationalmap.gov/basic/
# Search for "Charlotte NC" and select "Elevation Products (3DEP)"
# 1-meter DEM is available for Mecklenburg County
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual tile download | Automated Python pipelines | ~2018 | Scale from 100s to 10000s of tiles |
| SRTM 90m global DEM | USGS 3DEP 1m LiDAR | ~2020 | 90x resolution improvement for US |
| Custom coordinate math | PyProj/GDAL libraries | ~2015 | Eliminates transform bugs |
| Unity-only tools | Cross-engine workflows | ~2022 | Blender as intermediate for any engine |
| Runtime streaming unavailable | Cesium for Unreal | 2021 | Real-world terrain without preprocessing |

**Deprecated/outdated:**
- **terrain.party:** Service unreliable; prefer direct USGS/Mapbox sources
- **Google Earth elevation export:** Against ToS; use free alternatives
- **World Composition (UE4):** Replaced by World Partition in UE5

## Open Questions

1. **I-485 Precise Boundary Geometry**
   - What we know: I-485 is a 66.68-mile loop; approximate bounding box identified
   - What's unclear: Exact OSM relation ID for the complete loop; some segments may be split
   - Recommendation: Query OSM Overpass API for `relation["ref"="I 485"]` to get complete geometry

2. **USGS 3DEP vs Cesium Runtime Tradeoff**
   - What we know: Cesium provides runtime streaming; USGS requires preprocessing
   - What's unclear: Whether Cesium free tier (15GB/month streaming) sufficient for development
   - Recommendation: Start with USGS for offline development; evaluate Cesium for production

3. **Highway Wall Height Determination**
   - What we know: I-485 geometry available; wall needs height parameter
   - What's unclear: Appropriate wall height for gameplay (realistic vs stylized)
   - Recommendation: Configurable height parameter; start with 10m as placeholder

4. **Tile Stitching Strategy**
   - What we know: Individual tiles easy to download; merging into single image needed
   - What's unclear: Memory limits for very large merged images (zoom 17 = ~4000+ tiles)
   - Recommendation: Use GDAL VRT for virtual merging; only materialize needed regions

## Sources

### Primary (HIGH confidence)

- GDAL Documentation (gdal.org) - Raster/vector processing, coordinate systems
- PyProj Documentation (pyproj4.github.io) - Coordinate transformations
- OSMnx Documentation (osmnx.readthedocs.io) - Street network extraction
- USGS 3D Elevation Program (usgs.gov/3d-elevation-program) - DEM data source
- OpenStreetMap Wiki (wiki.openstreetmap.org) - Tile coordinate system

### Secondary (MEDIUM confidence)

- Cesium for Unreal Documentation (cesium.com/learn/unreal) - Runtime terrain streaming
- BlenderGIS GitHub (github.com/domlysz/BlenderGIS) - Visual GIS import workflow
- Epic Games World Partition Documentation (dev.epicgames.com) - UE5 streaming system
- terrain.party (historical reference) - Game-focused heightmap source

### Tertiary (LOW confidence)

- Various CSDN/blog posts on tile downloading - Code examples verified against official docs
- Community discussions on OSM export workflows - Patterns validated against OSM wiki

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - GDAL, PyProj, OSMnx are industry standards with active maintenance
- Architecture: MEDIUM - Pipeline structure based on established patterns but untested at this scale
- Pitfalls: HIGH - Coordinate and scaling issues are well-documented in GIS/game dev communities
- Data sources: MEDIUM - USGS 3DEP confirmed for Charlotte; exact coverage/quality needs verification
- Charlotte specifics: LOW-MEDIUM - Approximate bounding box identified; precise I-485 geometry needs OSM query

**Research date:** 2026-02-25
**Valid until:** 6 months (stable GIS libraries; data sources may update coverage)

---

## Quick Reference: Charlotte I-485 Coordinates

```
Bounding Box (approximate):
  North: 35.37 N
  South: 35.08 N
  East:  -80.65 W
  West:  -81.00 W

Center Point:
  Latitude:  35.227 N
  Longitude: -80.843 W

UTM Zone: 17N (EPSG:32617)

Loop Length: 66.68 miles (107.31 km)
Interior Area: ~300+ square miles

Key Locations:
  - Charlotte Douglas Airport: 35.2139 N, -80.9486 W
  - Uptown Charlotte: 35.227 N, -80.843 W
  - I-77/I-485 South interchange: Near SC border
```

## Tile Count Estimates

For Charlotte I-485 bounding box at various zoom levels:

| Zoom | Tile Size (m) | Tiles Needed | Storage (est.) |
|------|---------------|--------------|----------------|
| 14 | ~9,700 | ~100 | ~5 MB |
| 15 | ~4,800 | ~400 | ~20 MB |
| 16 | ~2,400 | ~1,600 | ~80 MB |
| 17 | ~1,200 | ~6,400 | ~320 MB |
| 18 | ~600 | ~25,600 | ~1.3 GB |

**Recommendation:** Use zoom 15-16 for development, zoom 17-18 for final quality.
