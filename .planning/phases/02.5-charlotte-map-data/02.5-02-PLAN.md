---
phase: 02.5-charlotte-map-data
plan: 02
type: execute
wave: 2
depends_on: ["02.5-01"]
files_modified:
  - tools/charlotte_map_acquisition/scripts/__init__.py
  - tools/charlotte_map_acquisition/scripts/download_tiles.py
  - tools/charlotte_map_acquisition/scripts/download_dem.py
  - tools/charlotte_map_acquisition/scripts/extract_highway.py
autonomous: true

must_haves:
  truths:
    - "Tile downloader retrieves map tiles for I-485 bounds at configurable zoom levels"
    - "DEM acquisition script queries USGS 3DEP for elevation data availability"
    - "Highway extraction script pulls I-485 geometry from OpenStreetMap"
    - "All scripts use rate limiting to avoid server blocks"
    - "Downloaded data is organized in data/raw/ subdirectories"
  artifacts:
    - path: "tools/charlotte_map_acquisition/scripts/download_tiles.py"
      provides: "Map tile acquisition"
      contains: "class TileDownloader"
      min_lines: 100
    - path: "tools/charlotte_map_acquisition/scripts/download_dem.py"
      provides: "DEM query and download"
      contains: "def query_usgs_3dep"
    - path: "tools/charlotte_map_acquisition/scripts/extract_highway.py"
      provides: "OSM highway boundary extraction"
      contains: "def extract_i485_highway"
  key_links:
    - from: "scripts/download_tiles.py"
      to: "config/charlotte_bounds.json"
      via: "load bounds"
      pattern: "charlotte_bounds"
    - from: "scripts/extract_highway.py"
      to: "OSMnx library"
      via: "ox.features_from_place"
      pattern: "osmnx"
---

<objective>
Create the three data acquisition scripts for map tiles, DEM elevation data, and highway boundary geometry. All scripts run in parallel and store raw data for further processing.

Purpose: Acquire the three core data types needed for Charlotte map generation - satellite/map imagery, elevation data, and road boundaries.
Output: Three Python scripts that download tiles from OSM/Mapbox, query USGS 3DEP for DEM, and extract I-485 geometry from OpenStreetMap.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.5-charlotte-map-data/02.5-RESEARCH.md
@.planning/phases/02.5-charlotte-map-data/02.5-01-PLAN.md

# Research provides:
# - TileDownloader class pattern with rate limiting and concurrent downloads
# - USGS 3DEP API endpoint and query parameters
# - OSMnx pattern for extracting highway networks
# - Charlotte bounds from config created in Plan 01
# - Pitfall: Rate limiting is critical (100-500ms delay, max 4-5 workers)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Map Tile Downloader Script</name>
  <files>
    tools/charlotte_map_acquisition/scripts/__init__.py
    tools/charlotte_map_acquisition/scripts/download_tiles.py
  </files>
  <action>
Create the map tile download script at tools/charlotte_map_acquisition/scripts/download_tiles.py.

Based on the TileDownloader pattern from research:

1. Create scripts/__init__.py (can be empty)

2. Create download_tiles.py with:
   - TileDownloader class with:
     - __init__(base_url, rate_limit_delay=0.25, max_workers=4)
     - latlon_to_tile(lat, lon, zoom) method
     - get_tiles_for_bounds(bounds, zoom) method
     - download_tile(z, x, y, output_dir) method with rate limiting
     - download_all(bounds, zoom_levels, output_dir) method with ThreadPoolExecutor

   - Configuration loading:
     - Load bounds from ../config/charlotte_bounds.json
     - Load zoom levels from ../config/zoom_levels.json

   - Output structure:
     - Save tiles to ../data/raw/tiles/{z}/{x}/{y}.png
     - Create directories as needed
     - Skip existing tiles (resume capability)

   - Rate limiting (CRITICAL per research pitfalls):
     - 250ms delay between requests
     - Max 4 concurrent workers
     - Proper User-Agent header

   - Progress reporting:
     - Print progress every 50 tiles
     - Report total tiles per zoom level

3. Include __main__ block for standalone execution:
   - Load config
   - Create downloader
   - Download tiles for development zoom levels (15, 16)
   - Print summary

4. Add proper error handling:
   - Handle network timeouts (30 second timeout)
   - Handle 403/429 rate limit errors
   - Log failures without crashing
  </action>
  <verify>
python3 -c "from tools.charlotte_map_acquisition.scripts.download_tiles import TileDownloader; print('TileDownloader OK')"
python3 -c "from tools.charlotte_map_acquisition.scripts.download_tiles import TileDownloader; t = TileDownloader(); print(t.latlon_to_tile(35.227, -80.843, 15))"
  </verify>
  <done>
TileDownloader class imports successfully and can convert coordinates to tile numbers. Script is ready to download tiles when executed.
</done>
</task>

<task type="auto">
  <name>Task 2: Create DEM Acquisition Script</name>
  <files>
    tools/charlotte_map_acquisition/scripts/download_dem.py
  </files>
  <action>
Create the DEM (Digital Elevation Model) acquisition script at tools/charlotte_map_acquisition/scripts/download_dem.py.

Based on the USGS 3DEP pattern from research:

1. Create functions for DEM acquisition:
   - query_usgs_3dep(bbox, output_path) - queries USGS API for available DEM products
   - get_dem_download_urls(products) - extracts download URLs from API response
   - download_dem_files(urls, output_dir) - downloads DEM files with progress

2. USGS API details:
   - Endpoint: https://tnmaccess.nationalmap.gov/api/v1/products
   - Dataset: "National Elevation Dataset (NED) 1/3 arc-second" or 1m DEM if available
   - BBOX format: "{west},{south},{east},{north}"
   - Output format: JSON

3. Charlotte-specific notes (from research):
   - Charlotte area has 1m resolution LiDAR DEM available
   - May need to use The National Map Viewer for direct download
   - Document manual steps if API doesn't provide direct downloads

4. Output structure:
   - Save query results to ../data/raw/dem/usgs_products.json
   - Download DEM files to ../data/raw/dem/
   - Log available products and their resolutions

5. Include __main__ block:
   - Load bounds from config
   - Query USGS API
   - Save product list
   - Print available DEM products with resolutions

6. Add fallback documentation:
   - If API doesn't support direct download, document manual process
   - Link to The National Map Viewer: https://viewer.nationalmap.gov/basic/
   - Note: Search "Charlotte NC", select "Elevation Products (3DEP)"
  </action>
  <verify>
python3 -c "from tools.charlotte_map_acquisition.scripts.download_dem import query_usgs_3dep; print('DEM functions OK')"
cat tools/charlotte_map_acquisition/scripts/download_dem.py | grep -c "tnmaccess.nationalmap.gov"
  </verify>
  <done>
DEM acquisition script imports successfully and contains USGS API endpoint. Script queries available elevation products for Charlotte area.
</done>
</task>

<task type="auto">
  <name>Task 3: Create Highway Boundary Extraction Script</name>
  <files>
    tools/charlotte_map_acquisition/scripts/extract_highway.py
  </files>
  <action>
Create the highway boundary extraction script at tools/charlotte_map_acquisition/scripts/extract_highway.py.

Based on the OSMnx pattern from research:

1. Create functions for OSM extraction:
   - extract_i485_highway() - downloads I-485 geometry from OpenStreetMap
   - get_i485_bounding_box() - returns the I-485 bounding box (can load from config)
   - export_to_geojson(gdf, output_path) - saves geometry to GeoJSON

2. OSMnx usage:
   - Use ox.features_from_place() with custom filter
   - Custom filter: '["highway"="motorway"]["ref"~"485"]'
   - Place: "Charlotte, North Carolina, USA"
   - Filter results to only include I-485 segments

3. I-485 specifics (from research):
   - I-485 is a 66.68-mile complete loop around Charlotte
   - Tagged in OSM as: highway=motorway, ref=I-485
   - Some segments may be split (handle with dissolve)

4. Output structure:
   - Save raw OSM data to ../data/raw/osm/i485_raw.geojson
   - Save processed boundary to ../data/processed/vectors/i485_boundary.geojson
   - Include both LineString (road centerline) and polygon (buffered area)

5. Processing steps:
   - Download highway network
   - Filter to I-485 only
   - Dissolve multi-part geometries
   - Optionally create buffer polygon (configurable width)
   - Export to GeoJSON

6. Include __main__ block:
   - Extract I-485 geometry
   - Print statistics (total length, number of segments)
   - Export to GeoJSON
   - Print output path

7. Add proper error handling:
   - Handle OSM API rate limits
   - Handle missing data gracefully
   - Log extraction statistics
  </action>
  <verify>
python3 -c "from tools.charlotte_map_acquisition.scripts.extract_highway import extract_i485_highway, get_i485_bounding_box; print('Highway extraction OK')"
python3 -c "from tools.charlotte_map_acquisition.scripts.extract_highway import get_i485_bounding_box; b = get_i485_bounding_box(); print(b['north'])"
  </verify>
  <done>
Highway extraction script imports successfully and returns correct bounding box. Script is ready to extract I-485 geometry from OpenStreetMap.
</done>
</task>

</tasks>

<verification>
1. Scripts directory exists with __init__.py
2. TileDownloader class imports and converts coordinates to tile numbers
3. DEM script contains USGS API endpoint and query functions
4. Highway extraction script imports and returns correct bounds
5. All scripts have __main__ blocks for standalone execution
6. All scripts load configuration from ../config/
7. Rate limiting implemented in tile downloader
</verification>

<success_criteria>
- Three acquisition scripts created in scripts/ directory
- Tile downloader with rate limiting (250ms delay, 4 workers)
- DEM script queries USGS 3DEP API
- Highway script uses OSMnx for I-485 extraction
- All scripts reference shared configuration
- All scripts can run standalone via python -m
</success_criteria>

<output>
After completion, create `.planning/phases/02.5-charlotte-map-data/02.5-02-SUMMARY.md`
</output>
