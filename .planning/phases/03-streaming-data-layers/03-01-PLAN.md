---
phase: 03-streaming-data-layers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Subsystems/GSDDataLayerManager.h
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Subsystems/GSDDataLayerManager.cpp
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Types/GSDDataLayerTypes.h
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Config/GSDDataLayerConfig.h
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/GSD_CityStreaming.Build.cs
autonomous: true

council_review:
  date: 2026-02-25
  status: CONDITIONAL APPROVE
  addressed_issues:
    - "CRITICAL: Added frame-budget-aware staged activation"
    - "MEDIUM: Added UGSDDataLayerConfig DataAsset for data-driven layer config"
    - "MEDIUM: Added async activation API with latent Blueprint support"
    - "MEDIUM: Stubbed Phase 8/9 event layer API methods"
    - "LOW: Added IGSDDataLayerProvider interface for testability"

must_haves:
  truths:
    - "User can toggle Data Layers at runtime via Blueprint or C++"
    - "Code can query which Data Layers are currently activated"
    - "System exposes all available runtime Data Layer names"
    - "Layer activation respects frame budget to prevent hitches"
    - "Layer configuration is data-driven via DataAsset (not hardcoded)"
  artifacts:
    - path: "Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Subsystems/GSDDataLayerManager.h"
      provides: "Data Layer management API with staged activation"
      min_lines: 80
    - path: "Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Subsystems/GSDDataLayerManager.cpp"
      provides: "Data Layer management implementation with frame budget guards"
      min_lines: 120
    - path: "Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Types/GSDDataLayerTypes.h"
      provides: "Shared types for Data Layer system"
      min_lines: 40
    - path: "Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Config/GSDDataLayerConfig.h"
      provides: "DataAsset for data-driven layer configuration"
      min_lines: 50
  key_links:
    - from: "GSDDataLayerManager"
      to: "UDataLayerSubsystem"
      via: "GetWorld()->GetSubsystem<UDataLayerSubsystem>()"
      pattern: "GetSubsystem<UDataLayerSubsystem>"
    - from: "GSDDataLayerManager"
      to: "GSDDataLayerConfig"
      via: "LayerConfig property (data-driven)"
      pattern: "UGSDDataLayerConfig*"
---

<objective>
Create UGSDDataLayerManager world subsystem for runtime Data Layer control.

Purpose: Provides Blueprint-callable API for toggling and querying Data Layer states at runtime, enabling dynamic event content loading.

Output: GSDDataLayerManager subsystem with SetDataLayerState, IsDataLayerActivated, and GetRuntimeDataLayerNames functions.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming-data-layers/03-RESEARCH.md

# Reference existing patterns
@Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Components/GSDStreamingSourceComponent.h
@Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Tests/GSDStreamingSourceTest.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GSDDataLayerTypes Header</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Types/GSDDataLayerTypes.h</files>
  <action>
Create shared types header for Data Layer system (follows GSDHLODTypes.h pattern from Phase 2).

Requirements:
1. Define FGSDDataLayerState struct for state tracking
2. Define EDataLayerActivationPriority enum for staged activation
3. Define delegate types for state changes

```cpp
#pragma once

#include "CoreMinimal.h"
#include "GSDDataLayerTypes.generated.h"

/** Priority for staged Data Layer activation */
UENUM(BlueprintType)
enum class EGSDDataLayerPriority : uint8
{
    Low = 0,       // Background content
    Normal = 1,    // Standard content
    High = 2,      // Player-critical content
    Critical = 3   // Must load immediately
};

/** State change event for Data Layers */
USTRUCT(BlueprintType)
struct FGSDDataLayerStateEvent
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadOnly)
    FName LayerName;

    UPROPERTY(BlueprintReadOnly)
    bool bIsActive = false;

    UPROPERTY(BlueprintReadOnly)
    float ActivationTimeMs = 0.0f;
};

/** Delegate for Data Layer state changes */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnGSDDataLayerStateChanged, const FGSDDataLayerStateEvent&, Event);

/** Delegate for staged activation progress */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnGSDStagedActivationProgress, int32, LayersActivated, int32, TotalLayers);
```
  </action>
  <verify>File exists at Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Types/GSDDataLayerTypes.h</verify>
  <done>GSDDataLayerTypes.h created with enums, structs, and delegates</done>
</task>

<task type="auto">
  <name>Task 2: Create GSDDataLayerConfig DataAsset</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Config/GSDDataLayerConfig.h</files>
  <action>
Create DataAsset for data-driven Data Layer configuration (addresses Council issue: hardcoded layer names).

This replaces hardcoded layer names with a data-driven approach.

```cpp
#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "Engine/DataLayer.h"
#include "GSDDataLayerConfig.generated.h"

/**
 * Data-driven configuration for GSD Data Layers.
 * Create instances in Editor and assign to GSDDataLayerManager.
 *
 * This replaces hardcoded layer names - create assets per-map or per-game-mode.
 */
UCLASS(BlueprintType)
class GSD_CITYSTREAMING_API UGSDDataLayerConfig : public UDataAsset
{
    GENERATED_BODY()

public:
    /// Base city layer - always loaded (usually DL_BaseCity)
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Core Layers")
    TObjectPtr<UDataLayerAsset> BaseCityLayer;

    /// Dynamic event content layer
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Event Layers")
    TObjectPtr<UDataLayerAsset> EventsLayer;

    /// Construction zones layer
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Event Layers")
    TObjectPtr<UDataLayerAsset> ConstructionLayer;

    /// Party/celebration content layer
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Event Layers")
    TObjectPtr<UDataLayerAsset> PartiesLayer;

    /// All runtime Data Layers for iteration
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "All Layers")
    TArray<TObjectPtr<UDataLayerAsset>> AllRuntimeLayers;

    /// Frame budget for staged activation (ms) - CRITICAL for preventing hitches
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Performance",
        meta = (ClampMin = "1.0", ClampMax = "16.0", Units = "ms"))
    float MaxActivationTimePerFrameMs = 5.0f;

    /// Delay between staged layer activations (seconds)
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Performance",
        meta = (ClampMin = "0.0", ClampMax = "1.0"))
    float StagedActivationDelay = 0.1f;

    /// Whether to use staged activation (recommended for 3+ layers)
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Performance")
    bool bUseStagedActivation = true;
};
```
  </action>
  <verify>File exists at Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Config/GSDDataLayerConfig.h</verify>
  <done>GSDDataLayerConfig.h created with data-driven layer configuration</done>
</task>

<task type="auto">
  <name>Task 3: Create GSDDataLayerManager Header</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Subsystems/GSDDataLayerManager.h</files>
  <action>
Create the GSDDataLayerManager header file as a UWorldSubsystem.

CRITICAL REQUIREMENTS (from Council review):
1. Frame-budget-aware staged activation to prevent hitches
2. Data-driven configuration via DataAsset
3. Async activation API with latent Blueprint support
4. Stub Phase 8/9 event layer API methods
5. Interface for testability

```cpp
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "Engine/DataLayer.h"
#include "Types/GSDDataLayerTypes.h"
#include "GSDDataLayerManager.generated.h"

class UGSDDataLayerConfig;
class UDataLayerAsset;

// Interface for testability (addresses Council issue: no interface abstraction)
class IGSDDataLayerProvider
{
public:
    virtual ~IGSDDataLayerProvider() = default;
    virtual void SetLayerState(FName LayerName, bool bActivated) = 0;
    virtual bool IsLayerActivated(FName LayerName) const = 0;
    virtual TArray<FName> GetRuntimeDataLayerNames() const = 0;
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnGSDLayerActivationComplete, FName, LayerName, bool, bSuccess);

/**
 * Manages Data Layer state for GSD City Streaming.
 * Provides runtime-configurable streaming behavior with frame-budget awareness.
 */
UCLASS()
class GSD_CITYSTREAMING_API UGSDDataLayerManager : public UWorldSubsystem, public IGSDDataLayerProvider
{
    GENERATED_BODY()

public:
    // UWorldSubsystem interface
    virtual void Initialize(FSubsystemCollectionBase& Collection) override;
    virtual void Deinitialize() override;

    // === Core API (Phase 3) ===

    /** Toggle a runtime data layer by name */
    UFUNCTION(BlueprintCallable, Category = "GSD|DataLayers")
    void SetDataLayerState(FName LayerName, bool bActivated);

    /** Check if a layer is currently activated */
    UFUNCTION(BlueprintPure, Category = "GSD|DataLayers")
    bool IsDataLayerActivated(FName LayerName) const override;

    /** Get all runtime data layer names */
    UFUNCTION(BlueprintPure, Category = "GSD|DataLayers")
    TArray<FName> GetRuntimeDataLayerNames() const override;

    // === Staged Activation API (CRITICAL for performance) ===

    /**
     * Activate multiple layers with frame budget awareness.
     * Prevents massive hitches by spreading activation across frames.
     * CRITICAL: Use this instead of activating all layers at once.
     */
    UFUNCTION(BlueprintCallable, Category = "GSD|DataLayers",
        meta = (AdvancedDisplay = "MaxTimePerFrameMs"))
    void ActivateLayersStaged(const TArray<FName>& LayerNames, float MaxTimePerFrameMs = 5.0f);

    /** Cancel any pending staged activation */
    UFUNCTION(BlueprintCallable, Category = "GSD|DataLayers")
    void CancelStagedActivation();

    // === Async Activation API (Blueprint Latent) ===

    /** Async layer activation with callback - non-blocking */
    UFUNCTION(BlueprintCallable, Category = "GSD|DataLayers",
        meta = (Latent, LatentInfo = "LatentInfo", WorldContext = "WorldContextObject"))
    void SetDataLayerStateAsync(UObject* WorldContextObject, FName LayerName, bool bActivated,
        FLatentActionInfo LatentInfo);

    // === Event Layer API (Phase 8/9 Stubs) ===

    /** Convenience: Activate event layer by config */
    UFUNCTION(BlueprintCallable, Category = "GSD|DataLayers|Events")
    void ActivateEventLayer(FName EventLayerName) { SetDataLayerState(EventLayerName, true); }

    /** Convenience: Deactivate event layer by config */
    UFUNCTION(BlueprintCallable, Category = "GSD|DataLayers|Events")
    void DeactivateEventLayer(FName EventLayerName) { SetDataLayerState(EventLayerName, false); }

    /** Check if event layer is active */
    UFUNCTION(BlueprintPure, Category = "GSD|DataLayers|Events")
    bool IsEventLayerActive(FName EventLayerName) const { return IsDataLayerActivated(EventLayerName); }

    // === Configuration ===

    /** Set the data-driven layer configuration */
    UFUNCTION(BlueprintCallable, Category = "GSD|DataLayers|Config")
    void SetLayerConfig(UGSDDataLayerConfig* InConfig);

    /** Get current layer configuration */
    UFUNCTION(BlueprintPure, Category = "GSD|DataLayers|Config")
    UGSDDataLayerConfig* GetLayerConfig() const { return LayerConfig; }

    // === Events ===

    /** Broadcast when a layer state changes */
    UPROPERTY(BlueprintAssignable, Category = "GSD|DataLayers")
    FOnGSDDataLayerStateChanged OnLayerStateChanged;

    /** Broadcast when staged activation completes all layers */
    UPROPERTY(BlueprintAssignable, Category = "GSD|DataLayers")
    FOnGSDStagedActivationProgress OnStagedActivationProgress;

protected:
    /** Data-driven configuration asset */
    UPROPERTY(EditDefaultsOnly, Category = "Config")
    TObjectPtr<UGSDDataLayerConfig> LayerConfig;

    /** Pending layers for staged activation */
    TArray<FName> PendingActivationLayers;
    int32 CurrentActivationIndex = 0;
    float FrameBudgetMs = 5.0f;
    FTimerHandle StagedActivationTimer;

private:
    UDataLayerSubsystem* GetDataLayerSubsystem() const;
    void ProcessNextStagedActivation();
    void OnStagedActivationTimer();
};
```
  </action>
  <verify>File exists with staged activation, async API, event stubs, and interface</verify>
  <done>Header created with all Council-mandated features</done>
</task>

<task type="auto">
  <name>Task 4: Implement GSDDataLayerManager</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Subsystems/GSDDataLayerManager.cpp</files>
  <action>
Create the GSDDataLayerManager implementation file with frame-budget-aware activation.

CRITICAL IMPLEMENTATION DETAILS:

```cpp
#include "Subsystems/GSDDataLayerManager.h"
#include "Config/GSDDataLayerConfig.h"
#include "Subsystems/DataLayerSubsystem.h"
#include "Engine/World.h"
#include "TimerManager.h"

void UGSDDataLayerManager::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);

    // Load default config if assigned
    if (LayerConfig)
    {
        FrameBudgetMs = LayerConfig->MaxActivationTimePerFrameMs;
    }
}

void UGSDDataLayerManager::Deinitialize()
{
    CancelStagedActivation();
    Super::Deinitialize();
}

void UGSDDataLayerManager::SetDataLayerState(FName LayerName, bool bActivated)
{
    if (UDataLayerSubsystem* DLSubsystem = GetDataLayerSubsystem())
    {
        if (UDataLayer* DataLayer = DLSubsystem->GetDataLayerInstanceFromName(LayerName))
        {
            EDataLayerRuntimeState NewState = bActivated
                ? EDataLayerRuntimeState::Activated
                : EDataLayerRuntimeState::Unloaded;

            double StartTime = FPlatformTime::Seconds();
            DLSubsystem->SetDataLayerInstanceRuntimeState(DataLayer, NewState);
            double ElapsedMs = (FPlatformTime::Seconds() - StartTime) * 1000.0;

            // Broadcast state change
            FGSDDataLayerStateEvent Event;
            Event.LayerName = LayerName;
            Event.bIsActive = bActivated;
            Event.ActivationTimeMs = ElapsedMs;
            OnLayerStateChanged.Broadcast(Event);
        }
    }
}

bool UGSDDataLayerManager::IsDataLayerActivated(FName LayerName) const
{
    if (UDataLayerSubsystem* DLSubsystem = GetDataLayerSubsystem())
    {
        if (UDataLayer* DataLayer = DLSubsystem->GetDataLayerInstanceFromName(LayerName))
        {
            return DLSubsystem->GetDataLayerInstanceRuntimeState(DataLayer) == EDataLayerRuntimeState::Activated;
        }
    }
    return false;
}

TArray<FName> UGSDDataLayerManager::GetRuntimeDataLayerNames() const
{
    TArray<FName> Names;
    if (UDataLayerSubsystem* DLSubsystem = GetDataLayerSubsystem())
    {
        for (const UDataLayer* Layer : DLSubsystem->GetDataLayerInstances())
        {
            if (Layer->IsRuntime())
            {
                Names.Add(Layer->GetFName());
            }
        }
    }
    return Names;
}

// CRITICAL: Frame-budget-aware staged activation
void UGSDDataLayerManager::ActivateLayersStaged(const TArray<FName>& LayerNames, float MaxTimePerFrameMs)
{
    if (LayerNames.Num() == 0) return;

    // Cancel any existing staged activation
    CancelStagedActivation();

    PendingActivationLayers = LayerNames;
    CurrentActivationIndex = 0;
    FrameBudgetMs = MaxTimePerFrameMs;

    // Use config delay if available
    float Delay = LayerConfig ? LayerConfig->StagedActivationDelay : 0.1f;

    if (Delay > 0.0f)
    {
        GetWorld()->GetTimerManager().SetTimer(
            StagedActivationTimer,
            this,
            &UGSDDataLayerManager::OnStagedActivationTimer,
            Delay,
            true);  // Looping timer
    }
    else
    {
        // Process immediately if no delay
        ProcessNextStagedActivation();
    }
}

void UGSDDataLayerManager::CancelStagedActivation()
{
    if (UWorld* World = GetWorld())
    {
        World->GetTimerManager().ClearTimer(StagedActivationTimer);
    }
    PendingActivationLayers.Empty();
    CurrentActivationIndex = 0;
}

void UGSDDataLayerManager::OnStagedActivationTimer()
{
    ProcessNextStagedActivation();
}

void UGSDDataLayerManager::ProcessNextStagedActivation()
{
    if (PendingActivationLayers.Num() == 0 || CurrentActivationIndex >= PendingActivationLayers.Num())
    {
        CancelStagedActivation();
        return;
    }

    double FrameStart = FPlatformTime::Seconds();

    // Process layers within frame budget
    while (CurrentActivationIndex < PendingActivationLayers.Num())
    {
        FName LayerName = PendingActivationLayers[CurrentActivationIndex];
        SetDataLayerState(LayerName, true);
        CurrentActivationIndex++;

        // Check frame budget - CRITICAL for preventing hitches
        double ElapsedMs = (FPlatformTime::Seconds() - FrameStart) * 1000.0;
        if (ElapsedMs >= FrameBudgetMs)
        {
            // Defer remaining to next frame
            break;
        }
    }

    // Broadcast progress
    OnStagedActivationProgress.Broadcast(CurrentActivationIndex, PendingActivationLayers.Num());

    // If complete, stop timer
    if (CurrentActivationIndex >= PendingActivationLayers.Num())
    {
        CancelStagedActivation();
    }
}

void UGSDDataLayerManager::SetLayerConfig(UGSDDataLayerConfig* InConfig)
{
    LayerConfig = InConfig;
    if (LayerConfig)
    {
        FrameBudgetMs = LayerConfig->MaxActivationTimePerFrameMs;
    }
}

UDataLayerSubsystem* UGSDDataLayerManager::GetDataLayerSubsystem() const
{
    UWorld* World = GetWorld();
    return World ? World->GetSubsystem<UDataLayerSubsystem>() : nullptr;
}
```

IMPORTANT: The staged activation is CRITICAL. Single layer activation can take 5-50ms.
Multiple layers at once can cause 200-500ms hitches (exceeds 33.33ms frame budget).
  </action>
  <verify>File exists and compiles. Staged activation respects frame budget.</verify>
  <done>Implementation complete with frame-budget guards and staged activation</done>
</task>

<task type="auto">
  <name>Task 5: Update Build.cs Dependencies</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/GSD_CityStreaming.Build.cs</files>
  <action>
Update the Build.cs to ensure all dependencies are available.

The DataLayerSubsystem is in the Engine module. Verify PrivateDependencyModuleNames includes "Engine".
  </action>
  <verify>Build.cs compiles and plugin builds successfully</verify>
  <done>Build.cs updated with correct module dependencies</done>
</task>

</tasks>

<verification>
1. Plugin compiles without errors or warnings
2. GSDDataLayerTypes.h exists with enums, structs, and delegates
3. GSDDataLayerConfig.h exists as DataAsset with data-driven configuration
4. GSDDataLayerManager.h exists with:
   - Staged activation API (ActivateLayersStaged)
   - Async activation API (SetDataLayerStateAsync)
   - Event layer stubs (Phase 8/9)
   - IGSDDataLayerProvider interface
5. GSDDataLayerManager.cpp implements frame-budget-aware staged activation
6. All functions are Blueprint-callable
7. Frame budget is enforced (test with 4+ layers)
</verification>

<success_criteria>
- [x] GSDDataLayerManager subsystem compiles and loads
- [x] SetDataLayerState toggles layers via UDataLayerSubsystem
- [x] IsDataLayerActivated queries layer state
- [x] GetRuntimeDataLayerNames returns available layers
- [x] All functions are Blueprint-accessible
- [x] CRITICAL: ActivateLayersStaged respects frame budget
- [x] Data-driven configuration via GSDDataLayerConfig
- [x] IGSDDataLayerProvider interface for testability
- [x] Event layer stubs for Phase 8/9
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-data-layers/03-01-SUMMARY.md`
</output>
