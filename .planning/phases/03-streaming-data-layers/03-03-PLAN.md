---
phase: 03-streaming-data-layers
plan: 03
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Subsystems/GSDStreamingTelemetry.h
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Subsystems/GSDStreamingTelemetry.cpp
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Types/GSDStreamingTelemetryTypes.h
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/GSD_CityStreaming.Build.cs
autonomous: true

council_review:
  date: 2026-02-25
  status: CONDITIONAL PASS
  addressed_issues:
    - "CRITICAL: Added broadcast throttling to prevent frame budget overruns"
    - "HIGH: Made MaxRecentEvents configurable per-platform"
    - "HIGH: Added FGSDStreamingTelemetryData struct for Phase 10 integration"
    - "MEDIUM: Added TArray pre-allocation with Reserve()"
    - "MEDIUM: Added scalability settings for telemetry"
    - "MEDIUM: Added batched event broadcasting option"

must_haves:
  truths:
    - "Streaming cell load times are tracked in telemetry"
    - "Telemetry events include player position context"
    - "Average load time can be queried for performance monitoring"
    - "Broadcast throttling prevents frame budget overruns"
    - "Telemetry is configurable per-platform via scalability"
  artifacts:
    - path: "Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Types/GSDStreamingTelemetryTypes.h"
      provides: "Telemetry data structures for Phase 10 integration"
      min_lines: 50
    - path: "Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Subsystems/GSDStreamingTelemetry.h"
      provides: "Streaming telemetry API with throttled broadcasting"
      min_lines: 80
    - path: "Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Subsystems/GSDStreamingTelemetry.cpp"
      provides: "Telemetry implementation with performance safeguards"
      min_lines: 120
  key_links:
    - from: "GSDStreamingTelemetry"
      to: "UWorldPartitionSubsystem"
      via: "OnWorldPartitionStreamingProgressUpdated delegate"
      pattern: "OnWorldPartitionStreamingProgressUpdated"
    - from: "FGSDStreamingTelemetryData"
      to: "Phase 10 Telemetry"
      via: "Shared struct definition"
      pattern: "FGSDStreamingTelemetryData"
---

<objective>
Create UGSDStreamingTelemetry game instance subsystem to track streaming cell load times.

Purpose: Enables performance monitoring by capturing streaming events with context (player position, active layers). Data feeds into Phase 10 telemetry system.

Output: GSDStreamingTelemetry subsystem with event logging, delegate broadcasting, and average load time calculation.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming-data-layers/03-RESEARCH.md

# Reference existing patterns
@Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Components/GSDStreamingSourceComponent.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GSDStreamingTelemetryTypes Header</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Types/GSDStreamingTelemetryTypes.h</files>
  <action>
Create shared telemetry types for Phase 10 integration (addresses Council issue: telemetry data format).

```cpp
#pragma once

#include "CoreMinimal.h"
#include "GSDStreamingTelemetryTypes.generated.h"

/**
 * Individual streaming event for tracking cell load performance.
 */
USTRUCT(BlueprintType)
struct FGSDStreamingEvent
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadOnly)
    FString CellName;

    UPROPERTY(BlueprintReadOnly)
    float LoadTimeMs = 0.0f;

    UPROPERTY(BlueprintReadOnly)
    FVector PlayerPosition = FVector::ZeroVector;

    UPROPERTY(BlueprintReadOnly)
    float PlayerSpeed = 0.0f;

    UPROPERTY(BlueprintReadOnly)
    float Timestamp = 0.0f;

    UPROPERTY(BlueprintReadOnly)
    TArray<FString> ActiveLayers;
};

/**
 * Aggregated telemetry data for performance monitoring.
 * Designed for consumption by GSD backend monitoring system (Phase 10).
 */
USTRUCT(BlueprintType)
struct FGSDStreamingTelemetryData
{
    GENERATED_BODY()

    // Cell counts
    UPROPERTY(BlueprintReadOnly, Category = "Telemetry")
    int32 TotalCells = 0;

    UPROPERTY(BlueprintReadOnly, Category = "Telemetry")
    int32 LoadedCells = 0;

    UPROPERTY(BlueprintReadOnly, Category = "Telemetry")
    int32 StreamingCells = 0;

    // Performance metrics
    UPROPERTY(BlueprintReadOnly, Category = "Telemetry")
    int32 StreamingOperationsThisFrame = 0;

    UPROPERTY(BlueprintReadOnly, Category = "Telemetry")
    float AverageLoadTimeMs = 0.0f;

    UPROPERTY(BlueprintReadOnly, Category = "Telemetry")
    float PeakLoadTimeMs = 0.0f;

    // Memory (for Phase 10 integration)
    UPROPERTY(BlueprintReadOnly, Category = "Telemetry")
    int64 EstimatedMemoryBytes = 0;

    // Bottleneck tracking
    UPROPERTY(BlueprintReadOnly, Category = "Telemetry")
    FString BottleneckCell;
};

// Delegate for individual event logging (throttled)
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnStreamingEventLogged, const FGSDStreamingEvent&, Event);

// Delegate for batched telemetry updates
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnStreamingTelemetryUpdated, const FGSDStreamingTelemetryData&, Data);
```
  </action>
  <verify>File exists at Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Types/GSDStreamingTelemetryTypes.h</verify>
  <done>GSDStreamingTelemetryTypes.h created with FGSDStreamingEvent, FGSDStreamingTelemetryData, and delegates</done>
</task>

<task type="auto">
  <name>Task 2: Create GSDStreamingTelemetry Header</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Subsystems/GSDStreamingTelemetry.h</files>
  <action>
Create the GSDStreamingTelemetry header with broadcast throttling (CRITICAL from Council review).

CRITICAL REQUIREMENTS:
1. Broadcast throttling to prevent frame budget overruns
2. Configurable MaxRecentEvents per-platform
3. TArray pre-allocation with Reserve()
4. Batched event broadcasting option
5. Scalability settings

```cpp
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "Types/GSDStreamingTelemetryTypes.h"
#include "GSDStreamingTelemetry.generated.h"

/**
 * Streaming telemetry subsystem for tracking cell load performance.
 *
 * PERFORMANCE NOTES (from Council review):
 * - Broadcasting on every streaming event is expensive
 * - Use MinBroadcastInterval to throttle broadcasts
 * - Use batched mode for aggregated updates
 * - MaxRecentEvents is configurable per-platform
 */
UCLASS(Config=Game, DefaultConfig)
class GSD_CITYSTREAMING_API UGSDStreamingTelemetry : public UGameInstanceSubsystem
{
    GENERATED_BODY()

public:
    virtual void Initialize(FSubsystemCollectionBase& Collection) override;
    virtual void Deinitialize() override;

    // === Event Logging ===

    /** Log a streaming event (internal or via test) */
    UFUNCTION(BlueprintCallable, Category = "GSD|Telemetry", meta = (DevelopmentOnly))
    void LogStreamingEvent(const FString& CellName, float LoadTimeMs, const FVector& PlayerPosition, float PlayerSpeed);

    // === Data Access ===

    /** Get recent streaming events */
    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry")
    const TArray<FGSDStreamingEvent>& GetRecentEvents() const { return RecentEvents; }

    /** Get average load time from recent events */
    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry")
    float GetAverageLoadTimeMs() const;

    /** Get aggregated telemetry data for Phase 10 */
    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry")
    FGSDStreamingTelemetryData GetAggregatedData() const;

    /** Get peak load time from recent events */
    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry")
    float GetPeakLoadTimeMs() const { return PeakLoadTimeMs; }

    /** Get bottleneck cell name (slowest loading) */
    UFUNCTION(BlueprintPure, Category = "GSD|Telemetry")
    FString GetBottleneckCell() const { return BottleneckCell; }

    // === Configuration ===

    /** Reset all telemetry data */
    UFUNCTION(BlueprintCallable, Category = "GSD|Telemetry")
    void ResetTelemetry();

    // === Delegates ===

    /** Broadcast when a streaming event is logged (throttled) */
    UPROPERTY(BlueprintAssignable, Category = "GSD|Telemetry")
    FOnStreamingEventLogged OnStreamingEventLogged;

    /** Broadcast batched telemetry updates (controlled by BroadcastInterval) */
    UPROPERTY(BlueprintAssignable, Category = "GSD|Telemetry")
    FOnStreamingTelemetryUpdated OnTelemetryUpdated;

    // === Scalability Settings (Config) ===

    /** Maximum recent events to store - configurable per-platform */
    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Performance",
        meta = (ClampMin = "10", ClampMax = "500"))
    int32 MaxRecentEvents = 100;

    /** Minimum interval between broadcasts (seconds) - prevents frame budget overrun */
    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Performance",
        meta = (ClampMin = "0.01", ClampMax = "1.0"))
    float MinBroadcastInterval = 0.1f;

    /** Enable/disable telemetry broadcasting (for low-end platforms) */
    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Performance")
    bool bEnableBroadcasting = true;

    /** Use batched mode instead of per-event broadcasting */
    UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Performance")
    bool bUseBatchedMode = false;

protected:
    void OnStreamingProgressUpdated(UWorld* World);
    void TryBroadcastEvent(const FGSDStreamingEvent& Event);
    void UpdateBottleneckTracking(const FGSDStreamingEvent& Event);

    FDelegateHandle ProgressDelegateHandle;
    TArray<FGSDStreamingEvent> RecentEvents;

    // Performance tracking
    float LastBroadcastTime = 0.0f;
    float PeakLoadTimeMs = 0.0f;
    FString BottleneckCell;

private:
    void BindToWorldPartition();
    void UnbindFromWorldPartition();
};
```
  </action>
  <verify>File exists with throttled broadcasting, configurable settings, and Phase 10 integration struct</verify>
  <done>Header created with all Council-mandated performance safeguards</done>
</task>

<task type="auto">
  <name>Task 3: Implement GSDStreamingTelemetry</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Subsystems/GSDStreamingTelemetry.cpp</files>
  <action>
Create the GSDStreamingTelemetry implementation with performance safeguards.

CRITICAL IMPLEMENTATION DETAILS:

```cpp
#include "Subsystems/GSDStreamingTelemetry.h"
#include "Engine/World.h"
#include "GameFramework/PlayerController.h"
#include "GameFramework/Pawn.h"
#include "WorldPartition/WorldPartitionSubsystem.h"

void UGSDStreamingTelemetry::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);

    // CRITICAL: Pre-allocate array to avoid runtime reallocations
    RecentEvents.Reserve(MaxRecentEvents);

    // Bind to world partition (version-dependent, see notes)
    BindToWorldPartition();

    UE_LOG(LogTemp, Log, TEXT("GSDStreamingTelemetry: Initialized (MaxEvents=%d, BroadcastInterval=%.2f)"),
        MaxRecentEvents, MinBroadcastInterval);
}

void UGSDStreamingTelemetry::Deinitialize()
{
    UnbindFromWorldPartition();
    RecentEvents.Empty();
    Super::Deinitialize();
}

void UGSDStreamingTelemetry::LogStreamingEvent(const FString& CellName, float LoadTimeMs,
    const FVector& PlayerPosition, float PlayerSpeed)
{
    FGSDStreamingEvent Event;
    Event.CellName = CellName;
    Event.LoadTimeMs = LoadTimeMs;
    Event.PlayerPosition = PlayerPosition;
    Event.PlayerSpeed = PlayerSpeed;
    Event.Timestamp = FPlatformTime::Seconds();

    // Add event
    RecentEvents.Add(Event);

    // Trim if over max (remove oldest)
    if (RecentEvents.Num() > MaxRecentEvents)
    {
        RecentEvents.RemoveAt(0, RecentEvents.Num() - MaxRecentEvents);
    }

    // Update bottleneck tracking
    UpdateBottleneckTracking(Event);

    // CRITICAL: Throttled broadcasting to prevent frame budget overrun
    TryBroadcastEvent(Event);
}

void UGSDStreamingTelemetry::TryBroadcastEvent(const FGSDStreamingEvent& Event)
{
    if (!bEnableBroadcasting)
    {
        return;
    }

    float CurrentTime = FPlatformTime::Seconds();
    float TimeSinceLastBroadcast = CurrentTime - LastBroadcastTime;

    // CRITICAL: Enforce minimum broadcast interval
    if (TimeSinceLastBroadcast < MinBroadcastInterval)
    {
        // Skip broadcast to protect frame budget
        return;
    }

    LastBroadcastTime = CurrentTime;

    if (bUseBatchedMode)
    {
        // Broadcast aggregated data instead of individual events
        FGSDStreamingTelemetryData Data = GetAggregatedData();
        OnTelemetryUpdated.Broadcast(Data);
    }
    else
    {
        // Broadcast individual event
        OnStreamingEventLogged.Broadcast(Event);
    }
}

void UGSDStreamingTelemetry::UpdateBottleneckTracking(const FGSDStreamingEvent& Event)
{
    if (Event.LoadTimeMs > PeakLoadTimeMs)
    {
        PeakLoadTimeMs = Event.LoadTimeMs;
        BottleneckCell = Event.CellName;
    }
}

float UGSDStreamingTelemetry::GetAverageLoadTimeMs() const
{
    if (RecentEvents.Num() == 0)
    {
        return 0.0f;
    }

    float Total = 0.0f;
    for (const auto& Event : RecentEvents)
    {
        Total += Event.LoadTimeMs;
    }
    return Total / RecentEvents.Num();
}

FGSDStreamingTelemetryData UGSDStreamingTelemetry::GetAggregatedData() const
{
    FGSDStreamingTelemetryData Data;
    Data.LoadedCells = RecentEvents.Num();
    Data.AverageLoadTimeMs = GetAverageLoadTimeMs();
    Data.PeakLoadTimeMs = PeakLoadTimeMs;
    Data.BottleneckCell = BottleneckCell;
    return Data;
}

void UGSDStreamingTelemetry::ResetTelemetry()
{
    RecentEvents.Empty();
    RecentEvents.Reserve(MaxRecentEvents);
    PeakLoadTimeMs = 0.0f;
    BottleneckCell.Empty();
    LastBroadcastTime = 0.0f;
}

void UGSDStreamingTelemetry::BindToWorldPartition()
{
    // Note: Actual World Partition delegate binding varies by UE5 version
    // This is a placeholder - full integration in Phase 10
    // For now, telemetry is logged via LogStreamingEvent() calls
}

void UGSDStreamingTelemetry::UnbindFromWorldPartition()
{
    // Cleanup delegate binding
}
```

PERFORMANCE SAFEGUARDS:
1. TArray::Reserve() pre-allocates to avoid runtime reallocations
2. MinBroadcastInterval prevents >10 broadcasts/second (default)
3. bEnableBroadcasting allows disabling on low-end platforms
4. bUseBatchedMode aggregates events for efficiency
5. MaxRecentEvents configurable per-platform via config
  </action>
  <verify>File exists and compiles. GetAverageLoadTimeMs returns correct values. Throttling enforced.</verify>
  <done>Implementation complete with all performance safeguards</done>
</task>

<task type="auto">
  <name>Task 4: Update Build.cs for Telemetry Dependencies</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/GSD_CityStreaming.Build.cs</files>
  <action>
Verify the Build.cs has all required dependencies for the telemetry subsystem.

Required modules:
- Engine (for World, PlayerController, Pawn)
- Core (for basic types)

Read current Build.cs and ensure PrivateDependencyModuleNames includes "Engine".
  </action>
  <verify>Plugin compiles without missing dependency errors</verify>
  <done>Build.cs verified with correct dependencies</done>
</task>

</tasks>

<verification>
1. Plugin compiles without errors
2. GSDStreamingTelemetryTypes.h exists with FGSDStreamingEvent and FGSDStreamingTelemetryData
3. GSDStreamingTelemetry.h exists with throttled broadcasting
4. GSDStreamingTelemetry.cpp implements all required methods
5. GetAverageLoadTimeMs() returns correct values
6. LogStreamingEvent() works with throttling
7. MinBroadcastInterval is enforced (test with rapid events)
8. MaxRecentEvents is configurable
9. TArray pre-allocation with Reserve() is implemented
</verification>

<success_criteria>
- [x] GSDStreamingTelemetry subsystem compiles and loads
- [x] FGSDStreamingEvent struct contains all required fields
- [x] FGSDStreamingTelemetryData ready for Phase 10 integration
- [x] Events can be logged and retrieved
- [x] Average load time calculated correctly
- [x] CRITICAL: Broadcast throttling prevents frame budget overruns
- [x] MaxRecentEvents configurable per-platform
- [x] TArray pre-allocation implemented
- [x] Batched mode available for efficiency
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-data-layers/03-03-SUMMARY.md`
</output>
