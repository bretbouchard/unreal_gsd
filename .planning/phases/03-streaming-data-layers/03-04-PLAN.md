---
phase: 03-streaming-data-layers
plan: 04
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Components/GSDStreamingSourceComponent.h
  - Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Components/GSDStreamingSourceComponent.cpp
  - Plugins/GSD_CityStreaming/Docs/VehicleStreamingIntegration.md
autonomous: true

council_review:
  date: 2026-02-25
  status: CONDITIONAL PASS
  addressed_issues:
    - "CRITICAL: Changed from tick-based polling to event-driven pattern"
    - "HIGH: Added hysteresis delay before disabling streaming for parked vehicles"
    - "HIGH: Added configurable thresholds via data asset"
    - "MEDIUM: Added streaming source priority for player vehicles"
    - "MEDIUM: Added hibernation system for long-parked vehicles"

must_haves:
  truths:
    - "Vehicles can enable/disable streaming based on state (EVENT-DRIVEN, not polling)"
    - "Fast vehicles get extended loading range for predictive loading"
    - "Parked vehicles disable streaming after hysteresis delay (not immediately)"
    - "Hibernation system for long-parked vehicles"
  artifacts:
    - path: "Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Components/GSDStreamingSourceComponent.h"
      provides: "Enhanced streaming source with vehicle-specific features"
      min_lines: 100
    - path: "Plugins/GSD_CityStreaming/Docs/VehicleStreamingIntegration.md"
      provides: "Vehicle integration guide with event-driven patterns"
      min_lines: 80
  key_links:
    - from: "Vehicle Pawn"
      to: "GSDStreamingSourceComponent"
      via: "Event-driven: OnMovementModeChanged, OnVehicleStateChanged"
      pattern: "OnVehicleStateChanged|ConfigureForVehicle"
---

<objective>
Enhance GSDStreamingSourceComponent with vehicle-specific features and create integration documentation.

Purpose: Enables vehicles to use predictive streaming with state-based enable/disable. Fast vehicles get extended loading range; parked vehicles disable streaming to avoid performance overhead.

Output: Enhanced GSDStreamingSourceComponent with vehicle integration pattern documented.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming-data-layers/03-RESEARCH.md

# Reference existing implementation
@Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Components/GSDStreamingSourceComponent.h
@Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Components/GSDStreamingSourceComponent.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance GSDStreamingSourceComponent Header</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Public/Components/GSDStreamingSourceComponent.h</files>
  <action>
Enhance the existing GSDStreamingSourceComponent with vehicle-specific features.

CRITICAL REQUIREMENTS (from Council review):
1. EVENT-DRIVEN pattern - NO tick-based polling of velocity
2. Hysteresis delay before disabling streaming for parked vehicles
3. Configurable thresholds via properties
4. Streaming source priority for player vehicles
5. Hibernation system for long-parked vehicles

Add these to the existing header:

```cpp
// === Vehicle Configuration ===

/**
 * Configure this streaming source for vehicle use.
 * Sets up predictive loading and range multipliers.
 */
UFUNCTION(BlueprintCallable, Category = "GSD|Streaming|Vehicle")
void ConfigureForVehicle(bool bIsFastVehicle, float VelocityThreshold = 1000.0f);

/**
 * Called when vehicle state changes (EVENT-DRIVEN).
 * CRITICAL: Call this from OnVehicleStateChanged delegate, NOT from Tick.
 */
UFUNCTION(BlueprintCallable, Category = "GSD|Streaming|Vehicle")
void OnVehicleStateChanged(bool bIsDriving, float CurrentVelocity);

/**
 * Enable hibernation mode - completely disable streaming after delay.
 * Use for vehicles parked for extended periods.
 */
UFUNCTION(BlueprintCallable, Category = "GSD|Streaming|Vehicle")
void EnableHibernationMode(float DelaySeconds);

/** Cancel pending hibernation */
UFUNCTION(BlueprintCallable, Category = "GSD|Streaming|Vehicle")
void CancelHibernation();

// === Property Getters ===

UFUNCTION(BlueprintPure, Category = "GSD|Streaming")
float GetLoadingRangeMultiplier() const { return LoadingRangeMultiplier; }

UFUNCTION(BlueprintPure, Category = "GSD|Streaming")
bool IsPredictiveLoadingEnabled() const { return bPredictiveLoading; }

UFUNCTION(BlueprintPure, Category = "GSD|Streaming")
float GetPredictiveLoadingThreshold() const { return PredictiveLoadingVelocityThreshold; }

UFUNCTION(BlueprintPure, Category = "GSD|Streaming|Vehicle")
bool IsStreamingEnabledForVehicle() const { return bStreamingEnabled; }

UFUNCTION(BlueprintPure, Category = "GSD|Streaming|Vehicle")
bool IsHibernating() const { return bIsHibernating; }

// === Vehicle-Specific Properties ===

/** Hysteresis delay before disabling streaming for parked vehicles (seconds) */
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GSD|Streaming|Vehicle",
    meta = (ClampMin = "0.0", ClampMax = "60.0"))
float ParkingHysteresisDelay = 5.0f;

/** Velocity threshold to consider vehicle "fast" (cm/s) */
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GSD|Streaming|Vehicle")
float FastVehicleThreshold = 2000.0f;

/** Loading range multiplier for fast vehicles */
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GSD|Streaming|Vehicle",
    meta = (ClampMin = "1.0", ClampMax = "5.0"))
float FastVehicleRangeMultiplier = 2.0f;

/** Hibernation delay for long-parked vehicles (seconds) */
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GSD|Streaming|Vehicle",
    meta = (ClampMin = "10.0", ClampMax = "300.0"))
float HibernationDelay = 30.0f;

protected:
    // Hysteresis timer handle
    FTimerHandle ParkingHysteresisTimer;

    // Hibernation timer handle
    FTimerHandle HibernationTimer;

    // State tracking
    bool bIsHibernating = false;
    bool bPendingDisable = false;
```

IMPORTANT: The OnVehicleStateChanged function replaces any tick-based velocity checking.
Vehicles MUST call this function from their state change delegate, NOT from Tick.
  </action>
  <verify>Header updated with event-driven vehicle API, hysteresis, and hibernation</verify>
  <done>GSDStreamingSourceComponent enhanced with Council-mandated vehicle features</done>
</task>

<task type="auto">
  <name>Task 2: Implement Vehicle Configuration</name>
  <files>Plugins/GSD_CityStreaming/Source/GSD_CityStreaming/Private/Components/GSDStreamingSourceComponent.cpp</files>
  <action>
Add the vehicle configuration implementation to the existing cpp file.

CRITICAL: Use EVENT-DRIVEN pattern, NOT tick-based polling.

```cpp
void UGSDStreamingSourceComponent::ConfigureForVehicle(bool bIsFastVehicle, float VelocityThreshold)
{
    bPredictiveLoading = true;
    PredictiveLoadingVelocityThreshold = VelocityThreshold;

    if (bIsFastVehicle)
    {
        LoadingRangeMultiplier = FastVehicleRangeMultiplier;
    }
    else
    {
        LoadingRangeMultiplier = 1.0f;
    }

    UpdateStreamingSourceState();
}

// CRITICAL: Event-driven state change - call from vehicle delegate, NOT from Tick
void UGSDStreamingSourceComponent::OnVehicleStateChanged(bool bIsDriving, float CurrentVelocity)
{
    // Cancel any pending hysteresis or hibernation timers
    if (GetWorld())
    {
        GetWorld()->GetTimerManager().ClearTimer(ParkingHysteresisTimer);
        GetWorld()->GetTimerManager().ClearTimer(HibernationTimer);
    }

    if (bIsDriving)
    {
        // Wake from hibernation if needed
        if (bIsHibernating)
        {
            bIsHibernating = false;
            SetStreamingEnabled(true);
        }

        // Adjust range based on velocity
        if (CurrentVelocity > FastVehicleThreshold)
        {
            LoadingRangeMultiplier = FastVehicleRangeMultiplier;
        }
        else
        {
            LoadingRangeMultiplier = 1.0f;
        }

        SetStreamingEnabled(true);
        bPendingDisable = false;
    }
    else
    {
        // Parked - use hysteresis before disabling
        bPendingDisable = true;

        if (ParkingHysteresisDelay > 0.0f && GetWorld())
        {
            // CRITICAL: Delay before disabling to prevent rapid toggling
            GetWorld()->GetTimerManager().SetTimer(
                ParkingHysteresisTimer,
                [this]()
                {
                    if (bPendingDisable)
                    {
                        SetStreamingEnabled(false);
                        bPendingDisable = false;

                        // Start hibernation timer for long-term parking
                        EnableHibernationMode(HibernationDelay);
                    }
                },
                ParkingHysteresisDelay,
                false
            );
        }
        else
        {
            // No hysteresis - disable immediately
            SetStreamingEnabled(false);
        }
    }

    UpdateStreamingSourceState();
}

void UGSDStreamingSourceComponent::EnableHibernationMode(float DelaySeconds)
{
    if (DelaySeconds <= 0.0f || !GetWorld())
    {
        return;
    }

    GetWorld()->GetTimerManager().SetTimer(
        HibernationTimer,
        [this]()
        {
            bIsHibernating = true;
            SetStreamingEnabled(false);
            // Additional cleanup for hibernation
        },
        DelaySeconds,
        false
    );
}

void UGSDStreamingSourceComponent::CancelHibernation()
{
    if (GetWorld())
    {
        GetWorld()->GetTimerManager().ClearTimer(HibernationTimer);
    }
    bIsHibernating = false;
}
```

PERFORMANCE NOTES:
1. NO tick-based velocity polling - uses event-driven pattern
2. Hysteresis prevents rapid enable/disable cycling
3. Hibernation reduces overhead for long-parked vehicles
4. 100+ parked vehicles = 0 streaming sources after hibernation
  </action>
  <verify>Plugin compiles. Event-driven pattern works. Hysteresis prevents rapid toggling.</verify>
  <done>Vehicle configuration implemented with event-driven pattern and hysteresis</done>
</task>

<task type="auto">
  <name>Task 3: Create Vehicle Streaming Integration Documentation</name>
  <files>Plugins/GSD_CityStreaming/Docs/VehicleStreamingIntegration.md</files>
  <action>
Create markdown documentation explaining how to integrate streaming with vehicles.

CRITICAL: Document the EVENT-DRIVEN pattern (NOT tick-based).

Document must include:

1. **Overview**
   - Why vehicles need streaming sources
   - Performance considerations (parked vs driving)
   - CRITICAL: Use event-driven pattern, NOT tick polling

2. **Adding Component to Vehicle**
   - Add GSDStreamingSourceComponent in vehicle Blueprint or C++ constructor
   - Call ConfigureForVehicle() based on vehicle type

3. **EVENT-DRIVEN State Changes (CRITICAL)**
   ```cpp
   // CORRECT: Event-driven from vehicle state delegate
   void AVehicleBase::OnVehicleStateChanged(EVehicleState NewState)
   {
       if (StreamingSource)
       {
           bool bIsDriving = (NewState == EVehicleState::Driving);
           float Velocity = GetVelocity().Size();
           StreamingSource->OnVehicleStateChanged(bIsDriving, Velocity);
       }
   }

   // WRONG: Never poll velocity in Tick
   void AVehicleBase::Tick(float DeltaTime)
   {
       // DON'T DO THIS - polling 100+ vehicles per frame
       float Speed = GetVelocity().Size();
       if (Speed < Threshold) { ... }  // BAD
   }
   ```

4. **Hysteresis System**
   - 5 second delay before disabling streaming for parked vehicles
   - Prevents rapid toggling in stop-and-go traffic
   - Configurable via ParkingHysteresisDelay

5. **Hibernation System**
   - After 30 seconds parked, vehicle enters hibernation
   - Streaming source completely disabled
   - Wakes automatically when vehicle starts driving

6. **Fast Vehicle Configuration**
   - Call ConfigureForVehicle(true) for sports cars, etc.
   - LoadingRangeMultiplier = 2.0 for extended range
   - Predictive loading activates above velocity threshold

7. **Performance Notes**
   - 100+ parked vehicles with streaming enabled = BAD (0.5-1.0ms per frame)
   - With event-driven + hibernation = 0ms overhead for parked vehicles
   - Predictive loading only matters above threshold speed

8. **Blueprint Integration**
   - All functions are Blueprint-callable
   - Can configure entirely in vehicle Blueprint
   - Use event dispatchers for state changes
</action>
  <verify>Documentation exists with event-driven pattern clearly documented</verify>
  <done>Vehicle streaming integration guide created with event-driven patterns and performance notes</done>
</task>

</tasks>

<verification>
1. Plugin compiles without errors
2. GSDStreamingSourceComponent has ConfigureForVehicle function
3. OnVehicleStateChanged uses event-driven pattern (NO tick polling)
4. Hysteresis delay prevents rapid toggling
5. Hibernation system for long-parked vehicles
6. Getter functions expose all relevant properties
7. Documentation clearly shows event-driven pattern
</verification>

<success_criteria>
- [x] ConfigureForVehicle helper function implemented
- [x] CRITICAL: Event-driven OnVehicleStateChanged (not tick-based)
- [x] Hysteresis delay before disabling streaming
- [x] Hibernation system for long-parked vehicles
- [x] Property getters added
- [x] Vehicle integration documentation with event-driven pattern
- [x] Existing functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-data-layers/03-04-SUMMARY.md`
</output>
