---
phase: 09-event-implementations
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/DataAssets/Events/GSDEventConstructionConfig.h
  - Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/DataAssets/Events/GSDEventConstructionConfig.cpp
  - Plugins/GSD_DailyEvents/Content/DataAssets/Events/DA_ConstructionEvent.uasset
autonomous: true

must_haves:
  truths:
    - "Construction event spawns barricades at specified location"
    - "Barricades are tracked for cleanup when event ends"
    - "Navigation lanes are blocked during construction"
    - "Event activates construction Data Layer for visual changes"
    - "Event data asset file exists and is configurable in editor"
  artifacts:
    - path: "Plugins/GSD_DailyEvents/.../Events/GSDEventConstructionConfig.h"
      provides: "Construction event definition (EVT-05)"
      exports: ["UGSDEventConstructionConfig"]
      contains: "OnEventStart_Implementation"
    - path: "Plugins/GSD_DailyEvents/.../Events/GSDEventConstructionConfig.cpp"
      provides: "Construction event implementation"
      contains: "SpawnActor"
    - path: "Plugins/GSD_DailyEvents/Content/DataAssets/Events/DA_ConstructionEvent.uasset"
      provides: "Configurable event instance for designers"
      contains: "UGSDEventConstructionConfig"
  key_links:
    - from: "GSDEventConstructionConfig::OnEventStart"
      to: "World->SpawnActor"
      via: "Barricade spawning"
      pattern: "SpawnActor.*Barricade"
    - from: "GSDEventConstructionConfig::OnEventStart"
      to: "GSDNavigationBlockModifier::ApplyModifier"
      via: "Lane blocking"
      pattern: "ApplyModifier"
    - from: "GSDEventConstructionConfig::OnEventEnd"
      to: "Actor::Destroy"
      via: "Barricade cleanup"
      pattern: "->Destroy\\(\\)"
---

<objective>
Implement Construction event (EVT-05) that spawns barricades and closes navigation lanes.

Purpose: Construction events create dynamic obstacles that change navigation patterns and require players to find alternate routes.
Output: UGSDEventConstructionConfig that spawns barricades, blocks lanes, and manages cleanup. Plus data asset instance for editor configuration.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Phase 8 Context (Event Infrastructure)

@.planning/phases/08-event-system-core/08-04-SUMMARY.md

**UGSDDailyEventConfig Interface:**
```cpp
virtual void OnEventStart_Implementation(UObject* WorldContext, FVector Location, float Intensity);
virtual void OnEventEnd_Implementation(UObject* WorldContext);
```

## Phase 9 Context (Modifiers)

@.planning/phases/09-event-implementations/09-01-PLAN.md

**NavigationBlockModifier available** for lane blocking.

## Research Context

@.planning/phases/09-event-implementations/09-RESEARCH.md

**Pitfall 1 - Actor Cleanup Memory Leak:**
- Always store spawned actors in TArray member variable
- Call Destroy() on actors in OnEventEnd
- Warning signs: Actors persist after event ends

**Actor Spawning Pattern:**
```cpp
FActorSpawnParameters SpawnParams;
SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;
AActor* Actor = World->SpawnActor<AActor>(Class, Location, Rotation, SpawnParams);
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Construction Event Config</name>
  <files>
    Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/DataAssets/Events/GSDEventConstructionConfig.h
    Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/DataAssets/Events/GSDEventConstructionConfig.cpp
  </files>
  <action>
Create UGSDEventConstructionConfig that implements EVT-05: Construction event spawns barricades and closes lanes.

**Directory Setup:**
```bash
mkdir -p Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/DataAssets/Events
mkdir -p Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/DataAssets/Events
```

**Header (GSDEventConstructionConfig.h):**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "DataAssets/GSDDailyEventConfig.h"
#include "GSDEventConstructionConfig.generated.h"

class UGSDNavigationBlockModifier;
class AActor;

/**
 * Construction event configuration.
 * Spawns barricades and closes navigation lanes.
 *
 * EVT-05: Construction event spawns barricades and closes lanes
 */
UCLASS(BlueprintType, Category = "GSD|Events")
class GSD_DAILYEVENTS_API UGSDEventConstructionConfig : public UGSDDailyEventConfig
{
    GENERATED_BODY()

public:
    UGSDEventConstructionConfig();

    //-- Construction Settings --
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Construction")
    TArray<TSubclassOf<AActor>> BarricadeClasses;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Construction")
    float BarricadeSpacing = 300.0f;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Construction")
    int32 MinBarricades = 3;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Construction")
    int32 MaxBarricades = 8;

    //-- Warning Settings --
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Construction")
    TArray<TSubclassOf<AActor>> WarningSignClasses;

    //-- Navigation Blocking --
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Construction")
    TObjectPtr<UGSDNavigationBlockModifier> NavigationBlocker;

    //-- UGSDDailyEventConfig Interface --
    virtual bool ValidateConfig(FString& OutError) const override;
    virtual void OnEventStart_Implementation(UObject* WorldContext, FVector Location, float Intensity) override;
    virtual void OnEventEnd_Implementation(UObject* WorldContext) override;

protected:
    /** Track spawned barricades for cleanup */
    UPROPERTY()
    TArray<TObjectPtr<AActor>> SpawnedBarricades;

    /** Track spawned warning signs for cleanup */
    UPROPERTY()
    TArray<TObjectPtr<AActor>> SpawnedWarnings;

    /** Event center location for navigation blocking */
    FVector EventCenter;

    /** Helper: Spawn barricade line at location */
    void SpawnBarricadeLine(UWorld* World, const FVector& Center, int32 Count);
};
```

**Implementation (GSDEventConstructionConfig.cpp):**
```cpp
#include "DataAssets/Events/GSDEventConstructionConfig.h"
#include "Modifiers/GSDNavigationBlockModifier.h"
#include "Kismet/KismetMathLibrary.h"

UGSDEventConstructionConfig::UGSDEventConstructionConfig()
{
    EventTag = FGameplayTag::RequestGameplayTag(FName("Event.Daily.Construction"));
    DurationMinutes = 60.0f;  // Construction lasts 1 hour by default
}

bool UGSDEventConstructionConfig::ValidateConfig(FString& OutError) const
{
    if (!Super::ValidateConfig(OutError))
    {
        return false;
    }

    // Specific validation for Construction event
    if (BarricadeClasses.Num() == 0)
    {
        OutError = TEXT("Construction event requires at least one BarricadeClass");
        return false;
    }

    if (!NavigationBlocker)
    {
        OutError = TEXT("Construction event requires NavigationBlocker to be set");
        return false;
    }

    // Validate each barricade class is valid
    for (int32 i = 0; i < BarricadeClasses.Num(); ++i)
    {
        if (!BarricadeClasses[i])
        {
            OutError = FString::Printf(TEXT("BarricadeClasses[%d] is null"), i);
            return false;
        }
    }

    // Validate warning signs if specified
    for (int32 i = 0; i < WarningSignClasses.Num(); ++i)
    {
        if (!WarningSignClasses[i])
        {
            OutError = FString::Printf(TEXT("WarningSignClasses[%d] is null"), i);
            return false;
        }
    }

    return true;
}

void UGSDEventConstructionConfig::OnEventStart_Implementation(UObject* WorldContext, FVector Location, float Intensity)
{
    UWorld* World = WorldContext ? WorldContext->GetWorld() : nullptr;
    if (!World || BarricadeClasses.Num() == 0)
    {
        GSDEVENT_WARN(TEXT("Construction event: Invalid world or no barricade classes"));
        return;
    }

    EventCenter = Location;

    // Calculate number of barricades based on intensity
    int32 NumBarricades = FMath::RoundToInt(FMath::Lerp(float(MinBarricades), float(MaxBarricades), Intensity));
    NumBarricades = FMath::Clamp(NumBarricades, MinBarricades, MaxBarricades);

    // Spawn barricades
    SpawnBarricadeLine(World, Location, NumBarricades);

    // Spawn warning signs at each end
    if (WarningSignClasses.Num() > 0)
    {
        FActorSpawnParameters SpawnParams;
        SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;

        FVector StartWarningLoc = Location + FVector(-BarricadeSpacing * (NumBarricades / 2 + 1), 0.0f, 0.0f);
        FVector EndWarningLoc = Location + FVector(BarricadeSpacing * (NumBarricades / 2 + 1), 0.0f, 0.0f);

        TSubclassOf<AActor> WarningClass = WarningSignClasses[0];
        AActor* StartWarning = World->SpawnActor<AActor>(WarningClass, StartWarningLoc, FRotator::ZeroRotator, SpawnParams);
        AActor* EndWarning = World->SpawnActor<AActor>(WarningClass, EndWarningLoc, FRotator(0.0f, 180.0f, 0.0f), SpawnParams);

        if (StartWarning) SpawnedWarnings.Add(StartWarning);
        if (EndWarning) SpawnedWarnings.Add(EndWarning);
    }

    // Apply navigation blocker
    if (NavigationBlocker)
    {
        NavigationBlocker->ApplyModifier(WorldContext, Location, Intensity);
    }

    GSDEVENT_LOG(TEXT("Construction event started: %d barricades, %d warnings at %s"),
        SpawnedBarricades.Num(), SpawnedWarnings.Num(), *Location.ToString());
}

void UGSDEventConstructionConfig::SpawnBarricadeLine(UWorld* World, const FVector& Center, int32 Count)
{
    if (!World || BarricadeClasses.Num() == 0) return;

    FActorSpawnParameters SpawnParams;
    SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;

    float StartOffset = -BarricadeSpacing * (Count - 1) / 2.0f;

    for (int32 i = 0; i < Count; ++i)
    {
        FVector SpawnLocation = Center + FVector(StartOffset + i * BarricadeSpacing, 0.0f, 0.0f);
        TSubclassOf<AActor> BarricadeClass = BarricadeClasses[i % BarricadeClasses.Num()];

        AActor* Barricade = World->SpawnActor<AActor>(BarricadeClass, SpawnLocation, FRotator::ZeroRotator, SpawnParams);
        if (Barricade)
        {
            SpawnedBarricades.Add(Barricade);
        }
    }
}

void UGSDEventConstructionConfig::OnEventEnd_Implementation(UObject* WorldContext)
{
    // Destroy all spawned barricades
    for (AActor* Barricade : SpawnedBarricades)
    {
        if (Barricade)
        {
            Barricade->Destroy();
        }
    }
    SpawnedBarricades.Empty();

    // Destroy all warning signs
    for (AActor* Warning : SpawnedWarnings)
    {
        if (Warning)
        {
            Warning->Destroy();
        }
    }
    SpawnedWarnings.Empty();

    // Remove navigation blocker
    if (NavigationBlocker)
    {
        NavigationBlocker->RemoveModifier(WorldContext);
    }

    GSDEVENT_LOG(TEXT("Construction event ended: %d barricades destroyed"), SpawnedBarricades.Num());
}
```

**Key Design Decisions:**
- Intensity controls barricade count (MinBarricades to MaxBarricades range)
- Barricades spawn in a line perpendicular to event center
- Warning signs spawn at line ends for visibility
- NavigationBlockModifier blocks AI navigation
- All actors tracked in TArray<TObjectPtr<AActor>> for cleanup (Pitfall 1 prevention)
- ValidateConfig checks BarricadeClasses.Num() > 0 and validates each class pointer
- Always cleanup in OnEventEnd regardless of context validity
</action>
  <verify>
    # Verify directory exists
    test -d Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/DataAssets/Events

    # Verify header exists with correct class
    grep -q "class GSD_DAILYEVENTS_API UGSDEventConstructionConfig" \
      Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/DataAssets/Events/GSDEventConstructionConfig.h

    # Verify TObjectPtr usage for barricades
    grep -q "TArray<TObjectPtr<AActor>> SpawnedBarricades" \
      Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Public/DataAssets/Events/GSDEventConstructionConfig.h

    # Verify OnEventStart spawns actors
    grep -q "SpawnActor" \
      Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/DataAssets/Events/GSDEventConstructionConfig.cpp

    # Verify OnEventEnd destroys actors
    grep -q "->Destroy()" \
      Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/DataAssets/Events/GSDEventConstructionConfig.cpp

    # Verify specific validation
    grep -q "BarricadeClasses.Num() == 0" \
      Plugins/GSD_DailyEvents/Source/GSD_DailyEvents/Private/DataAssets/Events/GSDEventConstructionConfig.cpp

    echo "Construction event verified"
  </verify>
  <done>Construction event spawns barricades, blocks navigation, and cleans up all spawned actors on event end. Uses TObjectPtr for proper UPROPERTY tracking.</done>
</task>

<task type="auto">
  <name>Task 2: Create Construction Event Data Asset</name>
  <files>
    Plugins/GSD_DailyEvents/Content/DataAssets/Events/DA_ConstructionEvent.uasset
  </files>
  <action>
Create the event data asset file that designers can configure in the Unreal Editor.

**Note:** Data assets (.uasset files) are created through the Unreal Editor UI, not programmatically. This task documents the required steps.

**Editor Steps:**
1. Open Unreal Editor
2. Navigate to Content Browser > Plugins > GSD_DailyEvents Content > DataAssets > Events
3. Right-click > Blueprints > Data Asset > UGSDEventConstructionConfig
4. Name: DA_ConstructionEvent
5. Configure properties:
   - EventTag: Event.Daily.Construction
   - DurationMinutes: 60.0
   - BarricadeClasses: (Add barricade blueprint classes)
   - BarricadeSpacing: 300.0
   - MinBarricades: 3
   - MaxBarricades: 8
   - WarningSignClasses: (Add warning sign blueprint classes)
   - NavigationBlocker: (Create and assign UGSDNavigationBlockModifier)

**Alternative Programmatic Creation (for testing):**
If this is a test environment without editor access, create a CDO (Class Default Object) in code:
```cpp
// In a test or initialization function
UGSDEventConstructionConfig* DefaultConfig = NewObject<UGSDEventConstructionConfig>();
DefaultConfig->BarricadeClasses.Add(ABarricadeActor::StaticClass());
// ... configure other properties
```

**Verification in Editor:**
- Asset appears in Content Browser at specified path
- Double-clicking opens property editor
- All configurable properties visible and editable
</action>
  <verify>
    # Note: .uasset files are binary and created in editor
    # Verify the directory structure exists for data assets
    test -d Plugins/GSD_DailyEvents/Content/DataAssets/Events || mkdir -p Plugins/GSD_DailyEvents/Content/DataAssets/Events

    # Log reminder for editor-based creation
    echo "Note: DA_ConstructionEvent.uasset must be created in Unreal Editor"
    echo "Path: Plugins/GSD_DailyEvents/Content/DataAssets/Events/DA_ConstructionEvent.uasset"
  </verify>
  <done>Construction event data asset directory prepared. Actual .uasset file created in Unreal Editor.</done>
</task>

</tasks>

<verification>
## Compilation Check
```bash
# Compile GSD_DailyEvents plugin
# UnrealBuildTool should succeed without errors
```

## Pattern Verification
- [ ] UGSDEventConstructionConfig extends UGSDDailyEventConfig
- [ ] OnEventStart_Implementation spawns barricades
- [ ] OnEventEnd_Implementation destroys all spawned actors
- [ ] NavigationBlockModifier integrated for lane blocking
- [ ] All spawned actors tracked in TArray<TObjectPtr<AActor>>
- [ ] Intensity affects barricade count
- [ ] ValidateConfig checks BarricadeClasses.Num() > 0 and validates each class
- [ ] ValidateConfig checks NavigationBlocker is valid
</verification>

<success_criteria>
- Construction event spawns barricades in a line based on intensity
- Warning signs appear at barricade line ends
- Navigation lanes blocked during construction
- All barricades and warnings destroyed when event ends
- Navigation blocking removed when event ends
- No memory leaks from spawned actors
- Event data asset exists for designer configuration
- ValidateConfig provides specific error messages for missing/invalid properties
</success_criteria>

<output>
After completion, create `.planning/phases/09-event-implementations/09-02-SUMMARY.md`
</output>
