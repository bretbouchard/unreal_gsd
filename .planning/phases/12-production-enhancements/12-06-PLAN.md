---
phase: 12-production-enhancements
plan: 6
type: execute
wave: 3
depends_on: [12-01]
files_modified:
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/UI/GSDCrowdDebugWidget.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/UI/GSDCrowdDebugWidget.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp
autonomous: true
must_haves:
  truths:
    - "Debug dashboard shows live crowd metrics"
    - "Metrics update via delegates, not tick"
    - "Developer can monitor crowd state"
  artifacts:
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/UI/GSDCrowdDebugWidget.h"
      provides: "Debug dashboard"
      contains: "OnCrowdMetricsUpdated|ActiveCrowdCount|PerformanceBar"
---

<objective>
Create UMG debug dashboard widget for crowd monitoring.

Purpose: Council review (unreal-interface-rick) identified lack of visual debugging tools for crowd system. This plan creates a dashboard widget showing live metrics.

Output: Debug dashboard widget displays crowd count, LOD distribution, and performance metrics.

Council Issues: unreal-interface-rick HIGH #3 - No debug widgets
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-production-enhancements/12-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Crowd Metrics Structure and Delegate</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp
  </files>
  <action>
Add metrics structure and broadcast delegate to crowd manager.

**Header additions:**
```cpp
// Metrics structure for UI binding
USTRUCT(BlueprintType)
struct FGSDCrowdMetrics
{
    GENERATED_BODY();

    // Active crowd counts
    UPROPERTY(BlueprintReadOnly)
    int32 TotalEntities = 0;

    UPROPERTY(BlueprintReadOnly)
    int32 ActiveCrowds = 0;

    // LOD distribution
    UPROPERTY(BlueprintReadOnly)
    int32 LOD0Count = 0;  // Actor

    UPROPERTY(BlueprintReadOnly)
    int32 LOD1Count = 0;  // Simplified

    UPROPERTY(BlueprintReadOnly)
    int32 LOD2Count = 0;  // ISM

    UPROPERTY(BlueprintReadOnly)
    int32 LOD3Count = 0;  // Culled

    // Performance metrics
    UPROPERTY(BlueprintReadOnly)
    float LastFrameTime = 0.0f;

    UPROPERTY(BlueprintReadOnly)
    float AverageFrameTime = 0.0f;

    UPROPERTY(BlueprintReadOnly)
    int32 DrawCalls = 0;

    // Memory usage
    UPROPERTY(BlueprintReadOnly)
    int64 MemoryUsedMB = 0;
};

// Delegate for UI updates
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCrowdMetricsUpdated, const FGSDCrowdMetrics&, Metrics);

// In class declaration:
public:
    // Delegate for metrics updates
    UPROPERTY(BlueprintAssignable, Category = "Crowd|Events")
    FOnCrowdMetricsUpdated OnCrowdMetricsUpdated;

    // Get current metrics
    UFUNCTION(BlueprintPure, Category = "Crowd")
    FGSDCrowdMetrics GetCurrentMetrics() const { return CurrentMetrics; }

    // Update metrics (called by processor)
    void UpdateMetrics(const FGSDCrowdMetrics& NewMetrics);

protected:
    // Current metrics
    FGSDCrowdMetrics CurrentMetrics;

    // Update interval
    UPROPERTY(Config)
    float MetricsUpdateInterval = 0.1f;  // 10 Hz

    float LastMetricsUpdate = 0.0f;
```

**Implementation:**
```cpp
void UGSDCrowdManagerSubsystem::UpdateMetrics(const FGSDCrowdMetrics& NewMetrics)
{
    CurrentMetrics = NewMetrics;

    // Broadcast to UI
    OnCrowdMetricsUpdated.Broadcast(CurrentMetrics);
}

void UGSDCrowdManagerSubsystem::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);

    // Update metrics periodically
    float Now = GetWorld()->GetTimeSeconds();
    if (Now - LastMetricsUpdate >= MetricsUpdateInterval)
    {
        CollectMetrics();
        LastMetricsUpdate = Now;
    }
}

void UGSDCrowdManagerSubsystem::CollectMetrics()
{
    FGSDCrowdMetrics Metrics;

    // Count entities by LOD
    // ... query from Mass Entity

    // Get performance stats
    // ... from telemetry subsystem

    UpdateMetrics(Metrics);
}
```
  </action>
  <verify>
    ```bash
    grep -q "FGSDCrowdMetrics" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h && echo "✓ Metrics structure added"
    grep -q "OnCrowdMetricsUpdated" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h && echo "✓ Delegate added"
    ```
  </verify>
  <done>
    - Metrics structure defined
    - Update delegate added
    - GetCurrentMetrics function added
    - Periodic metrics collection
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GSDCrowdDebugWidget UMG Widget</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/UI/GSDCrowdDebugWidget.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/UI/GSDCrowdDebugWidget.cpp
  </files>
  <action>
Create debug dashboard widget with live metrics.

**GSDCrowdDebugWidget.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "Subsystems/GSDCrowdManagerSubsystem.h"
#include "GSDCrowdDebugWidget.generated.h"

class UTextBlock;
class UProgressBar;
class UListView;
class UVerticalBox;

/**
 * Debug dashboard widget for crowd monitoring.
 * Updates via delegate binding, NOT tick.
 */
UCLASS()
class GSD_CROWDS_API UGSDCrowdDebugWidget : public UUserWidget
{
    GENERATED_BODY()

public:
    virtual void NativeConstruct() override;
    virtual void NativeDestruct() override;

    // Bind to crowd manager
    UFUNCTION(BlueprintCallable, Category = "Crowd")
    void BindToCrowdManager();

    // Unbind from crowd manager
    UFUNCTION(BlueprintCallable, Category = "Crowd")
    void UnbindFromCrowdManager();

protected:
    // Bound widgets (must match UMG names)
    UPROPERTY(meta = (BindWidget))
    UTextBlock* TotalEntitiesText;

    UPROPERTY(meta = (BindWidget))
    UTextBlock* ActiveCrowdsText;

    UPROPERTY(meta = (BindWidget))
    UProgressBar* LOD0Bar;

    UPROPERTY(meta = (BindWidget))
    UProgressBar* LOD1Bar;

    UPROPERTY(meta = (BindWidget))
    UProgressBar* LOD2Bar;

    UPROPERTY(meta = (BindWidget))
    UProgressBar* LOD3Bar;

    UPROPERTY(meta = (BindWidget))
    UTextBlock* FrameTimeText;

    UPROPERTY(meta = (BindWidget))
    UProgressBar* PerformanceBar;

    UPROPERTY(meta = (BindWidget))
    UTextBlock* MemoryText;

    UPROPERTY(meta = (BindWidget))
    UVerticalBox* WarningsBox;

    // Handle metrics update
    UFUNCTION()
    void OnCrowdMetricsUpdated(const FGSDCrowdMetrics& Metrics);

    // Update UI from metrics
    void UpdateUI(const FGSDCrowdMetrics& Metrics);

    // Format number with K/M suffix
    FText FormatNumber(int32 Value) const;

    // Format time in ms
    FText FormatTime(float Value) const;

private:
    // Delegate handle for cleanup
    FDelegateHandle MetricsDelegateHandle;
};
```

**GSDCrowdDebugWidget.cpp:**
```cpp
#include "UI/GSDCrowdDebugWidget.h"
#include "Components/TextBlock.h"
#include "Components/ProgressBar.h"
#include "Components/VerticalBox.h"
#include "Subsystems/GSDCrowdManagerSubsystem.h"

void UGSDCrowdDebugWidget::NativeConstruct()
{
    Super::NativeConstruct();
    BindToCrowdManager();
}

void UGSDCrowdDebugWidget::NativeDestruct()
{
    UnbindFromCrowdManager();
    Super::NativeDestruct();
}

void UGSDCrowdDebugWidget::BindToCrowdManager()
{
    if (UWorld* World = GetWorld())
    {
        if (UGameInstance* GI = World->GetGameInstance())
        {
            if (UGSDCrowdManagerSubsystem* CrowdManager = GI->GetSubsystem<UGSDCrowdManagerSubsystem>())
            {
                CrowdManager->OnCrowdMetricsUpdated.AddDynamic(this, &UGSDCrowdDebugWidget::OnCrowdMetricsUpdated);
            }
        }
    }
}

void UGSDCrowdDebugWidget::UnbindFromCrowdManager()
{
    if (UWorld* World = GetWorld())
    {
        if (UGameInstance* GI = World->GetGameInstance())
        {
            if (UGSDCrowdManagerSubsystem* CrowdManager = GI->GetSubsystem<UGSDCrowdManagerSubsystem>())
            {
                CrowdManager->OnCrowdMetricsUpdated.RemoveDynamic(this, &UGSDCrowdDebugWidget::OnCrowdMetricsUpdated);
            }
        }
    }
}

void UGSDCrowdDebugWidget::OnCrowdMetricsUpdated(const FGSDCrowdMetrics& Metrics)
{
    UpdateUI(Metrics);
}

void UGSDCrowdDebugWidget::UpdateUI(const FGSDCrowdMetrics& Metrics)
{
    // Update entity count
    if (TotalEntitiesText)
    {
        TotalEntitiesText->SetText(FormatNumber(Metrics.TotalEntities));
    }

    // Update active crowds
    if (ActiveCrowdsText)
    {
        ActiveCrowdsText->SetText(FText::FromString(FString::FromInt(Metrics.ActiveCrowds)));
    }

    // Update LOD bars
    int32 Total = Metrics.LOD0Count + Metrics.LOD1Count + Metrics.LOD2Count + Metrics.LOD3Count;
    if (Total > 0)
    {
        if (LOD0Bar) LOD0Bar->SetPercent(static_cast<float>(Metrics.LOD0Count) / Total);
        if (LOD1Bar) LOD1Bar->SetPercent(static_cast<float>(Metrics.LOD1Count) / Total);
        if (LOD2Bar) LOD2Bar->SetPercent(static_cast<float>(Metrics.LOD2Count) / Total);
        if (LOD3Bar) LOD3Bar->SetPercent(static_cast<float>(Metrics.LOD3Count) / Total);
    }

    // Update frame time
    if (FrameTimeText)
    {
        FrameTimeText->SetText(FormatTime(Metrics.LastFrameTime));
    }

    // Update performance bar (16.67ms = 60fps target)
    if (PerformanceBar)
    {
        float TargetFrameTime = 16.67f;
        float Percent = FMath::Clamp(Metrics.LastFrameTime / TargetFrameTime, 0.0f, 1.0f);
        PerformanceBar->SetPercent(Percent);

        // Color based on performance
        if (Percent < 0.8f)
        {
            PerformanceBar->SetFillColorAndOpacity(FLinearColor::Green);
        }
        else if (Percent < 1.0f)
        {
            PerformanceBar->SetFillColorAndOpacity(FLinearColor::Yellow);
        }
        else
        {
            PerformanceBar->SetFillColorAndOpacity(FLinearColor::Red);
        }
    }

    // Update memory
    if (MemoryText)
    {
        MemoryText->SetText(FText::FromString(FString::Printf(TEXT("%lld MB"), Metrics.MemoryUsedMB)));
    }
}

FText UGSDCrowdDebugWidget::FormatNumber(int32 Value) const
{
    if (Value >= 1000000)
    {
        return FText::FromString(FString::Printf(TEXT("%.1fM"), Value / 1000000.0f));
    }
    else if (Value >= 1000)
    {
        return FText::FromString(FString::Printf(TEXT("%.1fK"), Value / 1000.0f));
    }
    return FText::FromString(FString::FromInt(Value));
}

FText UGSDCrowdDebugWidget::FormatTime(float Value) const
{
    return FText::FromString(FString::Printf(TEXT("%.2f ms"), Value));
}
```
  </action>
  <verify>
    ```bash
    [ -f "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/UI/GSDCrowdDebugWidget.h" ] && echo "✓ GSDCrowdDebugWidget.h created"
    [ -f "Plugins/GSD_Crowds/Source/GSD_Crowds/Private/UI/GSDCrowdDebugWidget.cpp" ] && echo "✓ GSDCrowdDebugWidget.cpp created"
    ```
  </verify>
  <done>
    - Debug widget class created
    - Delegate binding implemented
    - UI update from metrics
    - Performance visualization
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Build.cs Dependencies for UMG</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/GSD_Crowds.Build.cs
  </files>
  <action>
Add UMG and Slate dependencies to Build.cs.

**Changes:**
```cpp
PublicDependencyModuleNames.AddRange(new string[] {
    "Core",
    "CoreUObject",
    "Engine",
    "InputCore",
    "MassEntity",
    "MassCommon",
    // ... existing dependencies

    // UI dependencies
    "UMG",
    "Slate",
    "SlateCore"
});

// Editor-only for widget design
if (Target.bBuildEditor)
{
    PrivateDependencyModuleNames.AddRange(new string[] {
        "UnrealEd",
        "EditorScriptingUtilities"
    });
}
```
  </action>
  <verify>
    ```bash
    grep -q "UMG" Plugins/GSD_Crowds/Source/GSD_Crowds/GSD_Crowds.Build.cs && echo "✓ UMG dependency added"
    ```
  </verify>
  <done>
    - UMG dependency added
    - Slate dependencies added
    - Editor dependencies added
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Widget Blueprint Documentation</name>
  <files>
    Plugins/GSD_Crowds/Docs/CrowdDebugDashboard.md
  </files>
  <action>
Create documentation for using the debug dashboard.

**Content:**
```markdown
# Crowd Debug Dashboard

## Overview
The GSDCrowdDebugWidget provides real-time monitoring of crowd system performance.

## Usage

### Spawning the Widget
```cpp
// In player controller or HUD
UGSDCrowdDebugWidget* DebugWidget = CreateWidget<UGSDCrowdDebugWidget>(this, DebugWidgetClass);
DebugWidget->AddToViewport();
```

### Blueprint Setup
1. Create a new Widget Blueprint based on GSDCrowdDebugWidget
2. Add the following named widgets:
   - `TotalEntitiesText` (TextBlock)
   - `ActiveCrowdsText` (TextBlock)
   - `LOD0Bar`, `LOD1Bar`, `LOD2Bar`, `LOD3Bar` (ProgressBar)
   - `FrameTimeText` (TextBlock)
   - `PerformanceBar` (ProgressBar)
   - `MemoryText` (TextBlock)

### Metrics Displayed
| Metric | Description |
|--------|-------------|
| Total Entities | Count of all crowd entities |
| Active Crowds | Number of active crowd groups |
| LOD Distribution | Visual breakdown by LOD level |
| Frame Time | Last frame processing time |
| Performance Bar | Visual indicator (green/yellow/red) |
| Memory Used | Estimated memory consumption |

## Performance Notes
- Widget updates via delegate (NOT tick)
- Update interval configurable via MetricsUpdateInterval
- No performance impact when widget is hidden
```
  </action>
  <verify>
    ```bash
    [ -f "Plugins/GSD_Crowds/Docs/CrowdDebugDashboard.md" ] && echo "✓ Documentation created"
    ```
  </verify>
  <done>
    - Usage documentation created
    - Blueprint setup guide
    - Metrics reference
  </done>
</task>

</tasks>

<verification>
1. Metrics structure defined
2. Update delegate broadcasting
3. Debug widget class created
4. Widget binds to delegate
5. UMG dependencies added
6. Documentation created
</verification>

<success_criteria>
- Debug dashboard shows live crowd metrics
- Metrics update via delegates (not tick)
- LOD distribution visualized
- Performance indicator (color-coded)
- Memory usage displayed
- Developer can toggle dashboard at runtime
</success_criteria>

<output>
After completion, create `.planning/phases/12-production-enhancements/12-06-SUMMARY.md`
</output>
