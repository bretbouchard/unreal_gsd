---
phase: 12-production-enhancements
plan: 4
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDCrowdLODProcessor.cpp
autonomous: true
must_haves:
  truths:
    - "Crowds only spawn in loaded streaming cells"
    - "Crowds despawn when cells unload"
    - "Cell state affects entity visibility"
  artifacts:
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h"
      provides: "Streaming-aware spawning"
      contains: "OnCellLoaded|OnCellUnloaded|IsPositionInLoadedCell"
---

<objective>
Integrate crowd system with World Partition streaming for cell-aware spawning.

Purpose: Council review (unreal-worlds-rick) identified that crowds spawn without awareness of streaming cells, causing performance issues and visual artifacts. This plan adds World Partition integration.

Output: Crowds spawn/despawn based on streaming cell state, improving performance and memory usage.

Council Issues: unreal-worlds-rick HIGH #4-5 - Crowd/World Partition integration
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-production-enhancements/12-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Streaming Cell Tracking to CrowdManager</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp
  </files>
  <action>
Add World Partition cell tracking to crowd manager subsystem.

**Header additions:**
```cpp
#include "WorldPartition/WorldPartition.h"
#include "WorldPartition/WorldPartitionSubsystem.h"

// In class declaration:
protected:
    // Streaming cell tracking
    TSet<FName> LoadedCellNames;
    TMap<FName, TArray<int32>> CellToCrowdMapping;

    // Pending spawns for unloaded cells
    TMap<FName, TArray<FCrowdSpawnParams>> PendingSpawns;

    // Cell callbacks
    void OnCellLoaded(const FName& CellName);
    void OnCellUnloaded(const FName& CellName);

    // Check if position is in loaded cell
    bool IsPositionInLoadedCell(const FVector& Position) const;

    // Get cell name for position
    FName GetCellNameForPosition(const FVector& Position) const;

public:
    // Bind to streaming events
    void BindToStreamingEvents();
    void UnbindFromStreamingEvents();
```

**Implementation:**
```cpp
void UGSDCrowdManagerSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);

    // Bind to streaming events
    BindToStreamingEvents();
}

void UGSDCrowdManagerSubsystem::Deinitialize()
{
    UnbindFromStreamingEvents();
    Super::Deinitialize();
}

void UGSDCrowdManagerSubsystem::BindToStreamingEvents()
{
    if (UWorld* World = GetWorld())
    {
        if (UWorldPartitionSubsystem* WPSubsystem = World->GetSubsystem<UWorldPartitionSubsystem>())
        {
            // Store reference for querying
            WorldPartitionSubsystem = WPSubsystem;

            // Note: Actual binding depends on UE5 version
            // In UE5.3+, use OnCellLoaded/OnCellUnloaded delegates
        }
    }
}

bool UGSDCrowdManagerSubsystem::IsPositionInLoadedCell(const FVector& Position) const
{
    if (!WorldPartitionSubsystem.IsValid())
    {
        return true;  // No streaming, always allow
    }

    FName CellName = GetCellNameForPosition(Position);
    return LoadedCellNames.Contains(CellName);
}

FName UGSDCrowdManagerSubsystem::GetCellNameForPosition(const FVector& Position) const
{
    // Calculate cell name from position using grid cell size
    static constexpr float CellSize = 12800.0f;  // 128m cells

    int32 CellX = FMath::FloorToInt(Position.X / CellSize);
    int32 CellY = FMath::FloorToInt(Position.Y / CellSize);

    return FName(*FString::Printf(TEXT("Cell_%d_%d"), CellX, CellY));
}
```
  </action>
  <verify>
    ```bash
    grep -q "IsPositionInLoadedCell" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h && echo "✓ IsPositionInLoadedCell added"
    grep -q "OnCellLoaded\|OnCellUnloaded" Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdManagerSubsystem.h && echo "✓ Cell callbacks added"
    ```
  </verify>
  <done>
    - Cell tracking structures added
    - Cell position calculation implemented
    - Streaming event binding setup
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SpawnCrowd for Cell Awareness</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp
  </files>
  <action>
Update SpawnCrowd to check cell state before spawning.

**Changes:**
```cpp
void UGSDCrowdManagerSubsystem::SpawnCrowd(const FCrowdSpawnParams& Params, int32 OptionalSeed)
{
    // Check if spawn location is in loaded cell
    if (!IsPositionInLoadedCell(Params.Center))
    {
        // Queue for when cell loads
        FName CellName = GetCellNameForPosition(Params.Center);
        PendingSpawns.FindOrAdd(CellName).Add(Params);

        UE_LOG(LogGSDCrowds, Verbose,
            TEXT("Queueing spawn for unloaded cell: %s"), *CellName.ToString());
        return;
    }

    // Proceed with spawn
    SpawnCrowdInternal(Params, OptionalSeed);

    // Track which cell this crowd belongs to
    FName CellName = GetCellNameForPosition(Params.Center);
    CellToCrowdMapping.FindOrAdd(CellName).Add(LastSpawnedCrowdId);
}

void UGSDCrowdManagerSubsystem::OnCellLoaded(const FName& CellName)
{
    UE_LOG(LogGSDCrowds, Log, TEXT("Cell loaded: %s"), *CellName.ToString());

    // Track loaded cell
    LoadedCellNames.Add(CellName);

    // Process pending spawns for this cell
    if (TArray<FCrowdSpawnParams>* Pending = PendingSpawns.Find(CellName))
    {
        for (const FCrowdSpawnParams& Params : *Pending)
        {
            SpawnCrowdInternal(Params, 0);
        }
        PendingSpawns.Remove(CellName);
    }
}

void UGSDCrowdManagerSubsystem::OnCellUnloaded(const FName& CellName)
{
    UE_LOG(LogGSDCrowds, Log, TEXT("Cell unloaded: %s"), *CellName.ToString());

    // Remove from loaded set
    LoadedCellNames.Remove(CellName);

    // Despawn crowds in this cell
    if (TArray<int32>* CrowdIds = CellToCrowdMapping.Find(CellName))
    {
        for (int32 CrowdId : *CrowdIds)
        {
            DespawnCrowdInternal(CrowdId);
        }
        CellToCrowdMapping.Remove(CellName);
    }

    // Move active spawns to pending
    // (handled by the spawn logic checking cell state)
}
```
  </action>
  <verify>
    ```bash
    grep -q "PendingSpawns" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp && echo "✓ Pending spawn queue implemented"
    grep -q "CellToCrowdMapping" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdManagerSubsystem.cpp && echo "✓ Cell-to-crowd mapping implemented"
    ```
  </verify>
  <done>
    - SpawnCrowd checks cell state
    - Pending spawns queued for unloaded cells
    - Crowds despawned when cells unload
  </done>
</task>

<task type="auto">
  <name>Task 3: Update LOD Processor for Cell Awareness</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDCrowdLODProcessor.cpp
  </files>
  <action>
Update LOD processor to skip entities in unloaded cells.

**Changes:**
```cpp
void UGSDCrowdLODProcessor::Execute(FMassEntityManager& EntityManager, FMassExecutionContext& Context)
{
    // Get crowd manager for cell checking
    UGSDCrowdManagerSubsystem* CrowdManager = GetCrowdManager();

    for (FMassEntityHandle Entity : Context.GetEntities())
    {
        // Get entity position
        FVector EntityPosition = GetEntityPosition(Entity);

        // Skip if in unloaded cell
        if (CrowdManager && !CrowdManager->IsPositionInLoadedCell(EntityPosition))
        {
            // Mark for culling or skip processing
            SetEntityLOD(Entity, ECrowdLODLevel::Culled);
            continue;
        }

        // Normal LOD processing
        float DistanceToPlayer = ComputeDistanceToPlayer(EntityPosition);
        ECrowdLODLevel LODLevel = ComputeLODFromDistance(DistanceToPlayer);
        SetEntityLOD(Entity, LODLevel);
    }
}
```
  </action>
  <verify>
    ```bash
    grep -q "IsPositionInLoadedCell" Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Processors/GSDCrowdLODProcessor.cpp && echo "✓ LOD processor checks cell state"
    ```
  </verify>
  <done>
    - LOD processor checks cell state
    - Entities in unloaded cells are culled
    - Processing skipped for unloaded cells
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Streaming Integration Test</name>
  <files>
    Plugins/GSD_Tests/Source/GSD_Tests/Private/Tests/GSDStreamingIntegrationTests.cpp
  </files>
  <action>
Create tests for streaming cell integration.

**Test Cases:**
```cpp
IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGSDStreamingCellAwarenessTest,
    "GSD.Streaming.CellAwareness",
    EAutomationTestFlags::ProductFilter | EAutomationTestFlags::ContextMask)

bool FGSDStreamingCellAwarenessTest::RunTest(const FString& Parameters)
{
    UGSDCrowdManagerSubsystem* Subsystem = GetCrowdSubsystem();

    // Test cell name calculation
    FVector TestPos(12800.0f, 25600.0f, 0.0f);
    FName CellName = Subsystem->GetCellNameForPosition(TestPos);
    TestEqual("Cell name calculated", CellName, FName("Cell_1_2"));

    // Test position in cell check
    // (Assumes cell is not loaded in test environment)
    bool InLoadedCell = Subsystem->IsPositionInLoadedCell(TestPos);
    TestFalse("Position not in loaded cell", InLoadedCell);

    return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGSDStreamingPendingSpawnTest,
    "GSD.Streaming.PendingSpawn",
    EAutomationTestFlags::ProductFilter | EAutomationTestFlags::ContextMask)

bool FGSDStreamingPendingSpawnTest::RunTest(const FString& Parameters)
{
    UGSDCrowdManagerSubsystem* Subsystem = GetCrowdSubsystem();

    // Attempt spawn in unloaded cell
    FCrowdSpawnParams Params;
    Params.Center = FVector(100000.0f, 100000.0f, 0.0f);  // Far away
    Params.Count = 10;
    Params.Radius = 500.0f;

    int32 BeforeCount = Subsystem->GetActiveCrowdCount();
    Subsystem->SpawnCrowd(Params);
    int32 AfterCount = Subsystem->GetActiveCrowdCount();

    // Should not have spawned immediately
    TestEqual("Crowd not spawned immediately", BeforeCount, AfterCount);

    // Should be in pending
    // (Would verify pending count if exposed)

    return true;
}
```
  </action>
  <verify>
    ```bash
    [ -f "Plugins/GSD_Tests/Source/GSD_Tests/Private/Tests/GSDStreamingIntegrationTests.cpp" ] && echo "✓ Streaming integration tests created"
    ```
  </verify>
  <done>
    - Cell awareness tests created
    - Pending spawn tests created
    - Tests pass
  </done>
</task>

</tasks>

<verification>
1. Cell tracking structures in place
2. SpawnCrowd checks cell state
3. Pending spawns queued correctly
4. Crowds despawned on cell unload
5. LOD processor respects cell state
6. Tests pass
</verification>

<success_criteria>
- Crowds only spawn in loaded streaming cells
- Pending spawns queued for unloaded cells
- Crowds despawned when cells unload
- LOD processor skips unloaded cells
- Cell-to-crowd mapping maintained
</success_criteria>

<output>
After completion, create `.planning/phases/12-production-enhancements/12-04-SUMMARY.md`
</output>
