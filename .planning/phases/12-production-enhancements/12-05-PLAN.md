---
phase: 12-production-enhancements
plan: 5
type: execute
wave: 2
depends_on: [12-04]
files_modified:
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/HLOD/GSDCrowdHLODProxy.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/HLOD/GSDCrowdHLODProxy.cpp
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdHLODManager.h
  - Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdHLODManager.cpp
autonomous: true
must_haves:
  truths:
    - "Distant crowds rendered as HLOD proxies"
    - "Proxies reduce draw calls at distance"
    - "Proxies transition smoothly to entities"
  artifacts:
    - path: "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/HLOD/GSDCrowdHLODProxy.h"
      provides: "HLOD proxy actor"
      contains: "ImpostorMesh|EntityCount|ClusterCenter"
---

<objective>
Create HLOD proxy system for distant crowd rendering.

Purpose: Council review (unreal-worlds-rick) recommended HLOD proxies for crowds at extreme distances, reducing draw calls and improving performance for city-scale environments.

Output: HLOD proxy actors represent distant crowds as simplified meshes/impostors.

Council Issues: unreal-worlds-rick MEDIUM #3 - HLOD tier control
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-production-enhancements/12-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GSDCrowdHLODProxy Actor</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/HLOD/GSDCrowdHLODProxy.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/HLOD/GSDCrowdHLODProxy.cpp
  </files>
  <action>
Create HLOD proxy actor for distant crowd representation.

**GSDCrowdHLODProxy.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "GSDCrowdHLODProxy.generated.h"

class UStaticMeshComponent;
class UInstancedStaticMeshComponent;

/**
 * HLOD proxy actor representing a cluster of distant crowd entities.
 * Replaces individual entity rendering with simplified impostor/billboard.
 */
UCLASS()
class GSD_CROWDS_API AGSDCrowdHLODProxy : public AActor
{
    GENERATED_BODY()

public:
    AGSDCrowdHLODProxy();

    // Initialize proxy with cluster data
    void InitializeCluster(const FVector& InCenter, int32 InEntityCount, float InRadius);

    // Update visibility based on distance to player
    void UpdateVisibility(const FVector& PlayerLocation, float HLODThreshold);

    // Get cluster data
    const FVector& GetClusterCenter() const { return ClusterCenter; }
    int32 GetEntityCount() const { return EntityCount; }
    float GetClusterRadius() const { return ClusterRadius; }

    // Set the proxy mesh
    void SetProxyMesh(UStaticMesh* InMesh);

protected:
    virtual void BeginPlay() override;

    // Impostor/billboard mesh component
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    UStaticMeshComponent* ImpostorMesh;

    // Cluster data
    UPROPERTY()
    FVector ClusterCenter = FVector::ZeroVector;

    UPROPERTY()
    int32 EntityCount = 0;

    UPROPERTY()
    float ClusterRadius = 100.0f;

    // Whether currently visible
    bool bIsVisible = true;

    // Distance at which this proxy should be shown
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    float ShowDistance = 3000.0f;
};
```

**GSDCrowdHLODProxy.cpp:**
```cpp
#include "HLOD/GSDCrowdHLODProxy.h"
#include "Components/StaticMeshComponent.h"

AGSDCrowdHLODProxy::AGSDCrowdHLODProxy()
{
    PrimaryActorTick.bCanEverTick = false;

    // Create impostor mesh component
    ImpostorMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("ImpostorMesh"));
    RootComponent = ImpostorMesh;

    // Configure for HLOD
    ImpostorMesh->SetCastShadow(false);
    ImpostorMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    ImpostorMesh->SetCanEverAffectNavigation(false);
}

void AGSDCrowdHLODProxy::BeginPlay()
{
    Super::BeginPlay();
}

void AGSDCrowdHLODProxy::InitializeCluster(const FVector& InCenter, int32 InEntityCount, float InRadius)
{
    ClusterCenter = InCenter;
    EntityCount = InEntityCount;
    ClusterRadius = InRadius;

    // Position proxy at cluster center
    SetActorLocation(ClusterCenter);

    // Scale based on entity count
    float Scale = FMath::Sqrt(static_cast<float>(EntityCount)) * 0.5f;
    SetActorScale3D(FVector(Scale, Scale, 1.0f));
}

void AGSDCrowdHLODProxy::UpdateVisibility(const FVector& PlayerLocation, float HLODThreshold)
{
    float Distance = FVector::Dist(PlayerLocation, ClusterCenter);
    bool bShouldBeVisible = Distance >= HLODThreshold;

    if (bShouldBeVisible != bIsVisible)
    {
        bIsVisible = bShouldBeVisible;
        ImpostorMesh->SetVisibility(bIsVisible);
    }
}

void AGSDCrowdHLODProxy::SetProxyMesh(UStaticMesh* InMesh)
{
    if (ImpostorMesh && InMesh)
    {
        ImpostorMesh->SetStaticMesh(InMesh);
    }
}
```
  </action>
  <verify>
    ```bash
    [ -f "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/HLOD/GSDCrowdHLODProxy.h" ] && echo "✓ GSDCrowdHLODProxy.h created"
    [ -f "Plugins/GSD_Crowds/Source/GSD_Crowds/Private/HLOD/GSDCrowdHLODProxy.cpp" ] && echo "✓ GSDCrowdHLODProxy.cpp created"
    ```
  </verify>
  <done>
    - HLOD proxy actor created
    - Impostor mesh component added
    - Cluster initialization implemented
    - Visibility update implemented
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GSDCrowdHLODManager Subsystem</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdHLODManager.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdHLODManager.cpp
  </files>
  <action>
Create subsystem to manage HLOD proxy lifecycle and visibility.

**GSDCrowdHLODManager.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/EngineSubsystem.h"
#include "HLOD/GSDCrowdHLODProxy.h"
#include "GSDCrowdHLODManager.generated.h"

USTRUCT()
struct FGSDCrowdCluster
{
    GENERATED_BODY()

    UPROPERTY()
    FVector Center = FVector::ZeroVector;

    UPROPERTY()
    int32 EntityCount = 0;

    UPROPERTY()
    float Radius = 100.0f;

    UPROPERTY()
    TArray<FMassEntityHandle> Entities;
};

/**
 * Manages HLOD proxy creation, updates, and lifecycle.
 */
UCLASS()
class GSD_CROWDS_API UGSDCrowdHLODManager : public UEngineSubsystem
{
    GENERATED_BODY()

public:
    virtual void Initialize(FSubsystemCollectionBase& Collection) override;
    virtual void Deinitialize() override;

    // Create HLOD proxy for a cluster
    AGSDCrowdHLODProxy* CreateHLODProxy(const FGSDCrowdCluster& Cluster);

    // Update all proxy visibilities
    void UpdateProxyVisibilities(const FVector& PlayerLocation);

    // Set HLOD threshold distance
    void SetHLODThreshold(float InThreshold) { HLODThreshold = InThreshold; }

    // Get HLOD threshold
    float GetHLODThreshold() const { return HLODThreshold; }

    // Remove all proxies for a streaming cell
    void RemoveProxiesForCell(FName CellName);

    // Cluster entities for HLOD
    void ClusterEntitiesForHLOD(const TArray<FMassEntityHandle>& Entities);

protected:
    // All active HLOD proxies
    UPROPERTY()
    TArray<AGSDCrowdHLODProxy*> ActiveProxies;

    // Proxy mesh to use
    UPROPERTY()
    UStaticMesh* ProxyMesh = nullptr;

    // Distance at which to show HLOD proxies
    UPROPERTY(Config)
    float HLODThreshold = 5000.0f;

    // Cluster size for HLOD
    UPROPERTY(Config)
    float ClusterSize = 1000.0f;

    // Maximum proxies to create
    UPROPERTY(Config)
    int32 MaxProxies = 100;
};
```

**Key Implementation:**
```cpp
void UGSDCrowdHLODManager::ClusterEntitiesForHLOD(const TArray<FMassEntityHandle>& Entities)
{
    // Simple grid-based clustering
    TMap<FIntVector, FGSDCrowdCluster> Clusters;

    for (const FMassEntityHandle& Entity : Entities)
    {
        FVector Pos = GetEntityPosition(Entity);
        FIntVector ClusterKey(
            FMath::FloorToInt(Pos.X / ClusterSize),
            FMath::FloorToInt(Pos.Y / ClusterSize),
            0
        );

        FGSDCrowdCluster& Cluster = Clusters.FindOrAdd(ClusterKey);
        Cluster.Entities.Add(Entity);
        Cluster.EntityCount++;
    }

    // Create proxies for clusters
    for (auto& Pair : Clusters)
    {
        FGSDCrowdCluster& Cluster = Pair.Value;

        // Calculate cluster center
        FVector Sum = FVector::ZeroVector;
        for (const FMassEntityHandle& Entity : Cluster.Entities)
        {
            Sum += GetEntityPosition(Entity);
        }
        Cluster.Center = Sum / Cluster.EntityCount;

        // Calculate radius
        float MaxDist = 0.0f;
        for (const FMassEntityHandle& Entity : Cluster.Entities)
        {
            float Dist = FVector::Dist(Cluster.Center, GetEntityPosition(Entity));
            MaxDist = FMath::Max(MaxDist, Dist);
        }
        Cluster.Radius = MaxDist;

        // Create proxy
        CreateHLODProxy(Cluster);
    }
}

AGSDCrowdHLODProxy* UGSDCrowdHLODManager::CreateHLODProxy(const FGSDCrowdCluster& Cluster)
{
    if (ActiveProxies.Num() >= MaxProxies)
    {
        return nullptr;
    }

    FActorSpawnParams SpawnParams;
    SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

    AGSDCrowdHLODProxy* Proxy = GetWorld()->SpawnActor<AGSDCrowdHLODProxy>(
        AGSDCrowdHLODProxy::StaticClass(),
        Cluster.Center,
        FRotator::ZeroRotator,
        SpawnParams
    );

    if (Proxy)
    {
        Proxy->InitializeCluster(Cluster.Center, Cluster.EntityCount, Cluster.Radius);
        Proxy->SetProxyMesh(ProxyMesh);
        ActiveProxies.Add(Proxy);
    }

    return Proxy;
}
```
  </action>
  <verify>
    ```bash
    [ -f "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/Subsystems/GSDCrowdHLODManager.h" ] && echo "✓ GSDCrowdHLODManager.h created"
    [ -f "Plugins/GSD_Crowds/Source/GSD_Crowds/Private/Subsystems/GSDCrowdHLODManager.cpp" ] && echo "✓ GSDCrowdHLODManager.cpp created"
    ```
  </verify>
  <done>
    - HLOD manager subsystem created
    - Clustering algorithm implemented
    - Proxy creation implemented
    - Visibility updates implemented
  </done>
</task>

<task type="auto">
  <name>Task 3: Create HLOD Configuration DataAsset</name>
  <files>
    Plugins/GSD_Crowds/Source/GSD_Crowds/Public/DataAssets/GSDCrowdHLODConfig.h
    Plugins/GSD_Crowds/Source/GSD_Crowds/Private/DataAssets/GSDCrowdHLODConfig.cpp
  </files>
  <action>
Create configuration data asset for HLOD settings.

**GSDCrowdHLODConfig.h:**
```cpp
#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "GSDCrowdHLODConfig.generated.h"

/**
 * Configuration for crowd HLOD system.
 */
UCLASS(BlueprintType)
class GSD_CROWDS_API UGSDCrowdHLODConfig : public UDataAsset
{
    GENERATED_BODY()

public:
    // Distance at which to start showing HLOD proxies
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Distances")
    float HLODStartDistance = 3000.0f;

    // Distance at which only HLOD proxies are shown
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Distances")
    float HLODOnlyDistance = 5000.0f;

    // Size of HLOD clusters
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Clustering")
    float ClusterSize = 1000.0f;

    // Maximum number of HLOD proxies
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Clustering")
    int32 MaxProxies = 100;

    // Minimum entities per cluster
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Clustering")
    int32 MinEntitiesPerCluster = 5;

    // Proxy mesh to use for impostors
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Visuals")
    UStaticMesh* ProxyMesh = nullptr;

    // Proxy material override
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Visuals")
    UMaterialInterface* ProxyMaterial = nullptr;

    // Whether to fade between LOD and HLOD
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Transitions")
    bool bUseFadeTransitions = true;

    // Fade duration in seconds
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Transitions")
    float FadeDuration = 0.5f;
};
```
  </action>
  <verify>
    ```bash
    [ -f "Plugins/GSD_Crowds/Source/GSD_Crowds/Public/DataAssets/GSDCrowdHLODConfig.h" ] && echo "✓ GSDCrowdHLODConfig.h created"
    ```
  </verify>
  <done>
    - HLOD configuration DataAsset created
    - Distance settings configurable
    - Cluster settings configurable
    - Visual settings configurable
  </done>
</task>

<task type="auto">
  <name>Task 4: Create HLOD Integration Test</name>
  <files>
    Plugins/GSD_Tests/Source/GSD_Tests/Private/Tests/GSDCrowdHLODTests.cpp
  </files>
  <action>
Create tests for HLOD system.

**Test Cases:**
```cpp
IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGSDCrowdHLODClusteringTest,
    "GSD.Crowds.HLOD.Clustering",
    EAutomationTestFlags::ProductFilter | EAutomationTestFlags::ContextMask)

bool FGSDCrowdHLODClusteringTest::RunTest(const FString& Parameters)
{
    // Create test entities
    TArray<FMassEntityHandle> Entities;
    // ... create entities at various positions

    UGSDCrowdHLODManager* Manager = GetHLODManager();
    Manager->ClusterEntitiesForHLOD(Entities);

    // Verify clusters created
    int32 ProxyCount = Manager->GetActiveProxyCount();
    TestTrue("Proxies created", ProxyCount > 0);

    return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGSDCrowdHLODVisibilityTest,
    "GSD.Crowds.HLOD.Visibility",
    EAutomationTestFlags::ProductFilter | EAutomationTestFlags::ContextMask)

bool FGSDCrowdHLODVisibilityTest::RunTest(const FString& Parameters)
{
    // Create proxy at known location
    FVector ProxyLocation(10000.0f, 0.0f, 0.0f);
    // ... create proxy

    // Test visibility at different distances
    FVector NearPlayer(0.0f, 0.0f, 0.0f);
    FVector FarPlayer(15000.0f, 0.0f, 0.0f);

    // Near player - proxy should be hidden
    Manager->UpdateProxyVisibilities(NearPlayer);
    TestFalse("Proxy hidden when near", Proxy->IsVisible());

    // Far player - proxy should be visible
    Manager->UpdateProxyVisibilities(FarPlayer);
    TestTrue("Proxy visible when far", Proxy->IsVisible());

    return true;
}
```
  </action>
  <verify>
    ```bash
    [ -f "Plugins/GSD_Tests/Source/GSD_Tests/Private/Tests/GSDCrowdHLODTests.cpp" ] && echo "✓ HLOD tests created"
    ```
  </verify>
  <done>
    - Clustering tests created
    - Visibility tests created
    - Tests pass
  </done>
</task>

</tasks>

<verification>
1. HLOD proxy actor created
2. HLOD manager subsystem created
3. Clustering algorithm implemented
4. Visibility updates working
5. Configuration DataAsset created
6. Tests pass
</verification>

<success_criteria>
- HLOD proxies represent distant crowd clusters
- Proxies reduce draw calls at distance
- Smooth transition between LOD and HLOD
- Clustering configurable via DataAsset
- Visibility respects player distance
</success_criteria>

<output>
After completion, create `.planning/phases/12-production-enhancements/12-05-SUMMARY.md`
</output>
